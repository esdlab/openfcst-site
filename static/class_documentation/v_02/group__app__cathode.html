<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>OpenFCST: The open-source Fuel Cell Simulation Toolbox: AppCathode Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenFCST: The open-source Fuel Cell Simulation Toolbox
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">AppCathode Tutorial<div class="ingroups"><a class="el" href="group__Tutorials.html">The Tutorials Page</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for AppCathode Tutorial:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__app__cathode.jpg" border="0" alt="" usemap="#group____app____cathode"/>
<map name="group____app____cathode" id="group____app____cathode">
<area shape="rect" id="node1" href="group__Tutorials.html" title="This page will list all the tutorials that have developed for FCST. " alt="" coords="5,5,147,32"/></map>
</td></tr></table></center>
</div>
<div class="textblock"> 
 <table class="tutorial" width="50%" border="1">
 <tr><h1>Table of contents</h1></tr>
 <tr>
  <ul>
    <li> <a href="#Introduction" class=bold>Introduction</a></li>
    <li> <a href="#CommProg" class=bold>The commented program</a></li>
    <ul>
       <li><a href="#Includefiles">Include files</a></li>
       <ul>
        <li><a href="#dealii">deal.II</a></li>
        <li><a href="#applicationcore">ApplicationCore</a></li>
        <li><a href="#FCST">FCST</a></li>
        <li><a href="#memberfunctiondeclaration">Member function declarations</a></li>
        <li><a href="#membervariables">Member variables</a></li>
       </ul>
       <li><a href="#mainapplication">The Main Application</a></li>
       <ul>
          <li><a href="#memberfunctions">The Member Functions</a></li>
       </ul>
     </ul>
     <li value="3"> <a href="#parameter_file" class=bold>The parameter file</a></li>
     <li> <a href="#Results" class=bold>Results</a></li>
     <li> <a href="#PlainProg" class=bold>The plain program</a></li>
  </ul>
 </tr> 
 </table>
 
 <dl class="section author"><dt>Authors</dt><dd>The tutorial was developed by Michael Moore and Marc Secanell and later updated by M. Bhaiya, P. Mangal, M. Sabharwal, J. Zhou and A. Kosakian.</dd></dl>
<p><a class="anchor" id="Introduction"></a></p>
<h1>Introduction</h1>
This tutorial describes how to develop an application using openFCST. The basic building blocks for creating a fuel cell mathematical model in openFCST are explained using AppCathode application as the template. <br/>
AppCathode class implements the polymer electrolyte fuel cell cathode mathematical model proposed in the following publication:  
 <ul>
    <li> M. Secanell et al. "Numerical Optimization of Proton Exchange Membrane Fuel Cell Cathode Electrodes", 
 Electrochimica Acta, 52(7):2668-2682, February 2007. </li>
 </ul>
  The data files used to reproduce the results from the publication can be found in folder: /data/articles/Secanell_EA07_Numerical_Optimization_PEMFC_Cathode_Electrodes. There are several subfolders for analysis, parametric studies and design cases. <br/>
 <br/>
 The mathematical model implemented is steady-state, isobaric and isothermal. Oxygen transport is assumed to be diffusion dominated and therefore is represented using Ficks Law. Electronic and protonic transport are governed by Ohms Law. The electrochemical reactions are modelled using Tafel kinetics. Gas diffusion layer and catalyst layer are considered isotropic. <br/>
 <br/>
 The computational domain is shown in red in the figure below. Due to symmetry of the cell in the vertical direction, the computational domain is reduced to the smaller area encompassed by the red lines by imposing symmetry boundary conditions on the top and bottom boundaries. </p>
<table  width="20%" align="center">
<tr>
<td align="center"><div class="image">
<img src="tutorial_pic_cell.png" alt="tutorial_pic_cell.png"/>
</div>
   </td></tr>
</table>
<p><br/>
 <br/>
 The governing equations of the model are written as follows: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ R_1(\vec{u}) = \nabla \cdot (c_{total}D^{eff}_{O_2} \nabla x_{O_2} ) = \frac{1}{nF}\nabla\cdot i \]" src="form_62.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ R_2(\vec{u}) = \nabla \cdot (\sigma^{eff}_{m}\nabla\phi_m) = \nabla \cdot i \]" src="form_63.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ R_3(\vec{u}) = \nabla \cdot (\sigma^{eff}_{s}\nabla\phi_s) = -\nabla \cdot i \]" src="form_64.png"/>
</p>
<p> where, for the case of a macro-homogeneous catalyst layer, </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \nabla \cdot i = A_v i^{ref}_0 \left( \frac{c_{O_2}} {c^{ref}_{O_2}} \right) \mbox{exp} \left( \frac{-\alpha F}{RT}(\phi_s - \phi_m - E_{th}) \right) \]" src="form_501.png"/>
</p>
<p> The solution variables are the protonic potential, <img class="formulaInl" alt="$\phi_m$" src="form_67.png"/>, the electronic potential, <img class="formulaInl" alt="$\phi_s$" src="form_68.png"/> and, the oxygen molar fraction <img class="formulaInl" alt="$x_{O_2}$" src="form_69.png"/>. Note that the source terms due to current production are only in the catalyst layer, while they are zero in the gas diffusion layer. <br/>
 <br/>
 The boundary conditions are given by the picture below: </p>
<table  width="20%" align="center">
<tr>
<td align="center"><div class="image">
<img src="tutorial_pic_bc.png" alt="tutorial_pic_bc.png"/>
</div>
   </td></tr>
</table>
<p><br/>
 <br/>
 Note that the membrane potential is set to zero at the CCL/membrane interface and that we control the voltage across the cell using the solid phase potential. <br/>
 <br/>
The governing equations above are nonlinear. Therefore, a nonlinear solver needs to be used to solve this problem. In OpenFCST, we solve the system of equations using a nonlinear Newton solver. Several nonlinear solvers are provided within the OpenFCST framework, and therefore we do not need to worry about them. You can specify the most appropriate nonlinear solver in the main_app_cathode_analysis.prm file, as follows: </p>
<div class="fragment"><div class="line">set solver name = Newton3ppC   # Linear | NewtonBasic | Newton3ppC | Newton3pp | NewtonLineSearch</div>
</div><!-- fragment --><p> <br/>
 When solving a nonlinear problem using a Newton method, an initial solution is needed. In OpenFCST, we choose to solve the problem first in a very coarse mesh and then, refine the mesh using a posteriori error estimators. The simulations are intially solved on a relatively coarse grid and it is successively refined after the non-linear system is solved using adaptive refinement. This involves refining the mesh in the areas with the largest error in one of the solution variables between iterations. The routine <a class="el" href="classFuelCell_1_1ApplicationCore_1_1DoFApplication.html#ab091cabc13bc471d6f3e4fe8ad101e3b">estimate </a> is used to implement the error estimator for each cell in the domain, for this application. An error estimator developed by Kelly et al. is used to choose the cells needing refinement. The number of refinement leves is defined in the parameter file. <br/>
 <br/>
 AppCathode and all other applications which you shall develop would need to implemet the linearized form of the governing equations for your problem at the element level. Further routines have already been implemented to loop over the cells in the finite element domain and create the global stiffness matrix and right hand side. The local matrix and right hand side assembly will be implemented in your application in member functions <a class="el" href="classFuelCell_1_1Application_1_1AppCathode.html#aa8645fd06553915ac34e9ff1f820ac08">cell_matrix </a> and <a class="el" href="classFuelCell_1_1Application_1_1AppCathode.html#a77c3e1c09d28fdeb1230a5589603cdf8">cell_residual </a>. The global assembly will take place in <a class="el" href="classFuelCell_1_1ApplicationCore_1_1BlockMatrixApplication.html#a45dd7414e3871275d5c2a80654c618ed">assemble </a> and <a class="el" href="classFuelCell_1_1ApplicationCore_1_1DoFApplication.html#a4e4902dc8cc1731151b5ba70d2b1a991">residual </a> functions in <a class="el" href="namespaceFuelCell_1_1ApplicationCore.html" title="Namespace containing the basic application framework used to loop over cells and create objects passe...">FuelCell::ApplicationCore</a>:: BlockMatrixApplication which is the parent of all applications in OpenFCST. Based on the above explanation, there are several "levels" within each simulation. <br/>
 <br/>
 The highest level is the <a class="el" href="classFuelCell_1_1ApplicationCore_1_1AdaptiveRefinement.html">adaptive refinement </a> loop, which will call the Newton solver to solve the non-linear application and then refine the mesh according to the Kelly Error Estimator (provided by <a href="http://www.dealii.org" target="_blank">deal.II</a>). Again, the number of refinement loops is chosen by the user. <br/>
 <br/>
 The call to the adaptive refinement is made in the <a class="el" href="classSimulatorBuilder.html">simulator builder </a> class. This class is used to set up the simulation at a very high level. It is used to choose a number of key variables which are specified in the main parameter file: the application, solver (there are three Newton solvers with a different line search methods) and the solver method (only adaptive refinement is currently implemented). The simulator builder will also define whether we wish to use Dakota to run an optimisation case or parametric study and is where the parameter file with the fuel cell properties, solver properties is selected. Note that to chose the application, solver and solver method, the simulator builder will call the <a class="el" href="classSimulationSelector.html">simulation selector </a> class. This class will read the main parameter file and will compare the inputs to a list. If a new application or solver is implemented, it will have to be added to this list. Finally, the call to the simulator builder class is made from the main file. <br/>
 <br/>
 The next level is a nonlinear application solver which is implemented in the <a class="el" href="classFuelCell_1_1ApplicationCore_1_1newtonBase.html">Newton </a> solver classes in FCST. The structure on which these classes are based is contained through the <a class="el" href="classFuelCell_1_1ApplicationCore_1_1ApplicationWrapper.html">ApplicationWrapper </a> class. This will ask the application to solve the linear system, will update the solution according to the chosen line search and repeat until the residual meets the chosen tolerance. <br/>
 <br/>
 At the lowest level is the system of linearized equations. AppCathode and all other applications are responsible for creating this system of linearized equations and solving it. The Newton solver uses this information to solve the nonlinear problem. The linearization of the governing equations above is given by </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ -\frac{\partial R_i(\vec{u}^{n-1})}{\partial u_j} (-\delta \vec{u}_j) = -R_i(\vec{u}^{n-1}) \]" src="form_502.png"/>
</p>
<p> where <img class="formulaInl" alt="$ n $" src="form_354.png"/> is the Newton step. The equations are discretised using finite elements and solved using the Galerkin formulation. The solution is updated and the system is solved again until the desired residual is achieved. This is represented graphically below: </p>
<table  width="20%" align="center">
<tr>
<td align="center"><div class="image">
<img src="tutorial_pic_newton.png" alt="tutorial_pic_newton.png"/>
</div>
   </td></tr>
</table>
<p><br/>
 <br/>
 The task of the AppCathode is to create the linearized system of equations above, discretise it and solve it. AppCathode inherits from <a class="el" href="classFuelCell_1_1ApplicationCore_1_1BlockMatrixApplication.html" title="Application handling matrices and assembling linear systems of equations. ">FuelCell::ApplicationCore::BlockMatrixApplication</a>. The latter implements a loop over all elements of the computational domain. Therefore, only the local (element level) assembly of the weak form of the governing equations is required. The global system is obtained using routines already implemented. A system matrix is assembled and then it is solved. The equations are stored in OpenFCST, which therefore provides the coefficients for the matrix and RHS. ApplicationCore provides the data structure for the application (through the BlocMatrixApplication and DoFApplication classes) and the functions to do the assembly. deal.II provides the information about the mesh, the nodes and the finite elements, as well as the solvers for the linear system. <br/>
 <br/>
In summary, creating and running a simulation in OpenFCST will consist of creating an application that uses various FCST classes to build a system of local (element level) linear equations that characterizes the fuel cell and solve the global system. These equations are then used by our already implemented routines to assemble the global system (for the whole mesh) and solve the nonlinear problem using a Newton solver. Finally, to increase accuracy, the problem is solved in different mesh refinements. <br/>
 <br/>
 The loops are represented graphically in the figure below: </p>
<table  width="20%" align="center">
<tr>
<td align="center"><div class="image">
<img src="tutorial_fcst_loops.png" alt="tutorial_fcst_loops.png"/>
</div>
   </td></tr>
</table>
The linear application contained in the application classes of FCST is represented by the green box, while the Newton solver loop is the blue box. Finally the red represents the adaptive refinement loop. Note that in the flow chart above, the optimisation package implemented in Dakota is not included as it is beyond the scope of this tutorial. <br/>
 <br/>
 To use the FCST code to create new simulations, the user should only need to create a new linear application. The code is built so that the user should not need to know the deal.II or ApplicationCore libraries in depth, indeed knowledge of the implementation of the Newton solver or the adaptive refinement (both of which are implemented in FCST) is not crucial. A new simulation can be created and run by simply creating a new application so with this in mind the tutorial will start with the header file of an example application, AppCathode, and will explain at a basic level all the components that are required to build the application by examining each line of code in sequence. Then the source file will be examined and provide more depth to the explanation given in the header file. <br/>
 <br/>
The simulations are defined using parameter files, simple text files with a .prm file extension that can be read by the FCST code (Note that some parameters can be defined using default values in the code itself, in the <a class="el" href="classFuelCell_1_1Application_1_1AppCathode.html#abc68107ed26f068aea929041f7272901">declare_parameters </a> function). <br/>
 <br/>
 In order to run the simulation, do the following:  
 <ul>
  <li> Go to folder /data/cathode//Secanell_EA07_Numerical_Optimization_PEMFC_Cathode_Electrodes/analysis </li>
  <li> In the command terminal type:  $../../../../bin/fuel_cell-2d.bin main_app_cathode_analysis.prm </li>
 </ul>
  The program will run and return the appropriate results. The main and data parameter files will be explained in the following subsections.The application can be used to solve a cathode with and without an MPL by changing the parameters in the data_app_cathode_parametric.prm file. <br/>
 The model can also be used to solve an agglomerate catalyst layer model. The governing equations are similar to the ones outlined above, however, the volumetric current density source, i.e. <img class="formulaInl" alt="$ \nabla \cdot i $" src="form_71.png"/>, is obtained as specified in the following article: </p>
<ul>
<li>
M. Secanell, K. Karan, A. Suleman and N. Djilali, "Multi-Variable Optimization of PEMFC Cathodes using 
 an Agglomerate Model ", Electrochimica Acta, 52(22):6318-6337, 2007. </li>
</ul>
<p>How to modify the parameter file to solve these additional cases will be explained in section <a href="#parameter_file" class="bold">The parameter file</a>. <br/>
 <br/>
 A number of different libraries are involved in the simulation, first being the <a href="http://www.dealii.org">deal.II libraries</a>. These libraries provide the finite elements and linear solvers required to solve the problem. Next are the ApplicationCore libraries that actually assemble the system of equations and form the basis of the applications that are created in FCST. Finally, the <a href="http://dakota.sandia.gov/index.html">Dakota libraries</a> are used to run optimisation studies and parametric studies. <br/>
 <br/>
 <a class="anchor" id="CommProg"></a> </p>
<h1>The commented program</h1>
<a class="anchor" id="Includefiles"></a> </p>
<h2>The include file</h2>
Here, we will step through the include file, <a class="el" href="app__cathode_8h.html">app_cathode.h</a>, and explain each line of code.The first step is to set the compiler flag that defines this file as the app_cathode class </p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef _FCST_APPLICATION_APP_CATHODE_H_</span></div>
<div class="line"><span class="preprocessor">#define _FCST_APPLICATION_APP_CATHODE_H_</span></div>
</div><!-- fragment -->Next we include all the necessary header files, starting with the libraries that form the very core of the simulation, the deal.II libraries. Then the ApplicationCore libraries, which are the basis of the applications used in the FCST code. Finally, we will look at the fuel cell specific FCST libraries.<a class="anchor" id="dealii"></a> </p>
<h3>deal.II</h3>
The deal.II library includes boost as one of its contributing libraries. Here we use the boost shared_pointers instead of C++ pointers because they are more robust in terms of memory leaks. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;boost/shared_ptr.hpp&quot;</span></div>
</div><!-- fragment --><a class="anchor" id="FCST"></a> </p>
<h3>FCST</h3>
The FCST classes are those that are specific to the generation of a fuel cell simulation. The first is geometry class used to store geometry and grid information. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="geometry_8h.html">grid/geometry.h</a>&quot;</span></div>
</div><!-- fragment -->Next are a base class for all applications that provide optimization information and the system management class that contains all the equations, variable names used in FCST, and also used for coupling the equations. Depending on the simulations, relevant equations and variables are accessed. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="optimization__block__matrix__application_8h.html">optimization_block_matrix_application.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="system__management_8h.html">system_management.h</a>&quot;</span></div>
</div><!-- fragment -->The operating conditions class defines variables such as the operating temperature of the cell, the pressure at the cathode or the molar fraction of hydrogen at the anode </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="operating__conditions_8h.html">utils/operating_conditions.h</a>&quot;</span></div>
</div><!-- fragment -->Next are two classes that describe the gases used in the fuel cell and how they interact. The first contains the properties about a number of different gases, for example, the viscosity of oxygen or critical temperature of nitrogen. Also described are hydrogen and water vapour. The second describes their interaction. The class will take two gases and return the diffusion coefficient according to Chapman Enskog theory for gas diffusion and Wilke Chang or Hans Bartels Interpolation for liquid diffusion. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="PureGas_8h.html">materials/PureGas.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="GasMixture_8h.html">materials/GasMixture.h</a>&quot;</span></div>
</div><!-- fragment -->The following three classes are used to store information about catalyst, electrolyte, and catalyst support. Here we select Platinum, Nafion, and Carbon black, respectively. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="platinum_8h.html">materials/platinum.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="nafion_8h.html">materials/nafion.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="carbon_8h.html">materials/carbon.h</a>&quot;</span></div>
</div><!-- fragment -->A fuel cell is made of many composite materials for which effective properties need to be obtained. OpenFCST contains a library of layers for fuel cells under namespace Layers. The layers are made of different materials and are used to compute the coefficients for the governing equations implemented in the classes above. Layer classes will return information about the effective transport properties of species through each layer, e.g. oxygen diffusion, protonic conductivity, permeabilities etc. The catalyst layers also provide the interface to the kinetics class, which handle the electrochemical reactions in the cell. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="gas__diffusion__layer_8h.html">layers/gas_diffusion_layer.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="micro__porous__layer_8h.html">layers/micro_porous_layer.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="catalyst__layer_8h.html">layers/catalyst_layer.h</a>&quot;</span></div>
</div><!-- fragment -->OpenFCST contains classes that implement the weak form of many partial differential equations that govern the physical processes in a fuel cell. For example, classes exist to implement the weak form of Fick's law of diffusion, Ohm's law, the Navier-Stoke equations, etc. All of these classes are stored inside the Equation namespace in FCST. <br/>
 In our application, we need Fick's law, Ohm's law for that electron and protons and a source term for the electrochemical reaction. These objects are included in our application here. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="new__ficks__transport__equation_8h.html">equations/new_ficks_transport_equation.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="electron__transport__equation_8h.html">equations/electron_transport_equation.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="proton__transport__equation_8h.html">equations/proton_transport_equation.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="reaction__source__terms_8h.html">equations/reaction_source_terms.h</a>&quot;</span></div>
</div><!-- fragment -->The next file contains SparseDirectUMFPACK, GMRES, and Schur complement based linear solvers. It also includes ILU preconditioner. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="linear__solvers_8h.html">solvers/linear_solvers.h</a>&quot;</span></div>
</div><!-- fragment -->The next file declares postprocessing namespace with classes used to evaluate current density, oxygen coverages, and relative humidity at each DoF point of the finite element mesh. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="data__out_8h.html">postprocessing/data_out.h</a>&quot;</span></div>
</div><!-- fragment -->Finally, we include the classes used for evaluating current density at catalyst layer. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="response__current__density_8h.html">postprocessing/response_current_density.h</a>&quot;</span></div>
</div><!-- fragment -->Because OpenFCST code relies heavily on the deal.II libraries, the deal.II namespace is used in most of the header files. The ApplicationCore namespace contains a number of basic classes in OpenFCST like application_base which is the parent class of the application_wrapper and dof_application. These save from prefixing all calls to deal.II and ApplicationCore functions and member variables with deal.II and ApplicationCore. </p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>deal.II;</div>
<div class="line"><span class="keyword">using namespace </span>FuelCell::ApplicationCore;</div>
</div><!-- fragment --><a class="anchor" id="memberfunctiondeclaration"></a> </p>
<h3>The Member Function Declaration</h3>
FCST function and member variables use one of the <a class="el" href="namespaceFuelCell.html" title="This namespace contains data and methods that handle initial and boundary data of a problem at hand...">FuelCell</a> namespaces. There are two main namespaces, <a class="el" href="namespaceFuelCell.html" title="This namespace contains data and methods that handle initial and boundary data of a problem at hand...">FuelCell</a> and <a class="el" href="namespaceFuelCellShop.html" title="Container Namespace for Fuel Cell data classes. ">FuelCellShop</a>. <br/>
 <a class="el" href="namespaceFuelCellShop.html" title="Container Namespace for Fuel Cell data classes. ">FuelCellShop</a> is the container for the data classes while <a class="el" href="namespaceFuelCell.html" title="This namespace contains data and methods that handle initial and boundary data of a problem at hand...">FuelCell</a> contains the applications, geometries and intial solutions. The main namespace that is used is the <a class="el" href="namespaceFuelCell_1_1Application.html">FuelCell::Application</a>, the container for all the applications that have been developed for the FCST code.<div class="fragment"><div class="line"><span class="keyword">namespace </span>FuelCell</div>
<div class="line">{</div>
</div><!-- fragment -->Application namespace is used for all applications, i.e. all the routines that implement the linear system to be solved using a Newton solver.<div class="fragment"><div class="line"><span class="keyword">namespace </span>Application</div>
<div class="line">{</div>
</div><!-- fragment -->For any application, the first that needs to be declared is a constructor and a destructor. When creating an application, the constructor will create an object of type application data (<a class="el" href="classFuelCell_1_1ApplicationCore_1_1ApplicationData.html" title="Here we handle general data of applications. ">FuelCell::ApplicationCore::ApplicationData</a>). This is a structure that will handle the general data for the application.<div class="fragment"><div class="line">AppCathode ( boost::shared_ptr&lt;FuelCell::ApplicationCore::ApplicationData&gt; data =</div>
<div class="line">           boost::shared_ptr&lt;FuelCell::ApplicationCore::ApplicationData&gt; () );</div>
</div><!-- fragment -->The class destructor will delete any pointers that have not been used by the class. </p>
<div class="fragment"><div class="line">~AppCathode();</div>
</div><!-- fragment -->All applications have a delcare_parameters function. This function is used to specify the data that is expected from the input file and default data to be used in case the input file does not contain any information for that variable. The data is stored in the ParameterHandler object which is an object in the nonlinear application. </p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> declare_parameters ( ParameterHandler&amp; param );</div>
</div><!-- fragment -->All applications have a routine initialize. This routine is used to read from ParameterHandler object the values for all the data necessary to setup the application problem to be solved. Note that declare_parameters simply specifies the values that will be read from file. In initialize, the values from the input file are actually read and stored inside the application for later use. </p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> initialize ( ParameterHandler&amp; param );</div>
</div><!-- fragment -->Then we form initial guess for the nonlinear problem along with appropriate boundary conditions. </p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> initialize_solution (<a class="code" href="namespaceFuelCell_1_1ApplicationCore.html#a890c83d37e50f658e28fde74c54d7dc8">FEVector</a>&amp; initial_guess,</div>
<div class="line">                                            std::shared_ptr&lt;Function&lt;dim&gt; &gt; initial_function = std::shared_ptr&lt;Function&lt;dim&gt; &gt;());</div>
</div><!-- fragment -->All applications need a member function, cell_matrix, that generates the element wise finite element matrix for the system of equations that is solved. Here we loop over the quadrature points and over degrees of freedom in order to compute the matrix for the cell This routine depends on the problem at hand and is called by assemble() in DoF_Handler class The matrix to be assembled in our case is of the form: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \begin{array}{l} M(i,j).block(0) = \int_{\Omega} a \nabla \phi_i \nabla \phi_j d\Omega + \int_{\Omega} \phi_i \frac{\partial f}{\partial u_0}\Big|_n \phi_j d\Omega \\ M(i,j).block(1) = \int_{\Omega} \phi_i \frac{\partial f}{\partial u_1}\Big|_n \phi_j d\Omega \\ M(i,j).block(2) = \int_{\Omega} \phi_i \frac{\partial f}{\partial u_2}\Big|_n \phi_j d\Omega \end{array} \]" src="form_503.png"/>
</p>
<p> This matrix will be assembled using Equation objects as discussed later.<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> cell_matrix(<a class="code" href="namespaceFuelCell_1_1ApplicationCore.html#a8ca0ab5b96a1a26ea639900d7c36ee64">MatrixVector</a>&amp;                                 cell_matrices,</div>
<div class="line">                                   <span class="keyword">const</span> <span class="keyword">typename</span> DoFApplication&lt;dim&gt;::CellInfo&amp; cell_info);</div>
</div><!-- fragment -->All application need a member function, cell_residual, that generates the element wise finite element right hand side for the system of equations that is solved. Integration of the rhs of the equations. Here we loop over the quadrature points and over degrees of freedom in order to compute the right hand side for each cell This routine depends on the problem at hand and is called by residual() in DoF_Handler class. Note that this function is called residual because in the case of nonlinear systems the rhs is equivalent to the residual </p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> cell_residual(<a class="code" href="namespaceFuelCell_1_1ApplicationCore.html#a890c83d37e50f658e28fde74c54d7dc8">FuelCell::ApplicationCore::FEVector</a>&amp;          cell_res,</div>
<div class="line">                                     <span class="keyword">const</span> <span class="keyword">typename</span> DoFApplication&lt;dim&gt;::CellInfo&amp; cell_info);</div>
</div><!-- fragment -->If Dirichlet boundary conditions need to be applied to the problem, the application will have to implement this member function, i.e. dirichlet_bc. This member function is used to set dirichlet boundary conditions. This function is application specific and it only computes the boundary_value values that are used to constraint the linear system of equations that is being solved </p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> dirichlet_bc ( std::map&lt;unsigned int, double&gt;&amp; boundary_values ) <span class="keyword">const</span>;</div>
</div><!-- fragment -->This routine is used to evaluate a functional such as the current density: </p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">double</span> evaluate ( <span class="keyword">const</span> <a class="code" href="classFuelCell_1_1ApplicationCore_1_1FEVectors.html">FuelCell::ApplicationCore::FEVectors</a>&amp; src );</div>
</div><!-- fragment -->This routine is used to create the output file. A base member function already exists, but in AppCathode we will reimplement it so that the right labels are outputed and so that I can compute and output the source terms. </p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> data_out ( <span class="keyword">const</span> std::string &amp;filename,</div>
<div class="line">                        <span class="keyword">const</span> FEVectors &amp;src );</div>
</div><!-- fragment -->Post-Processing. This routine is used to compute the current density, OH_coverage and O_coverage over the cathode catalyst layer. </p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> cell_responses(std::vector&lt;double&gt;&amp;                          dst,</div>
<div class="line">                            <span class="keyword">const</span> <span class="keyword">typename</span> DoFApplication&lt;dim&gt;::CellInfo&amp; cell_info,</div>
<div class="line">                            <span class="keyword">const</span> <a class="code" href="namespaceFuelCell_1_1ApplicationCore.html#a890c83d37e50f658e28fde74c54d7dc8">FEVector</a>&amp;);</div>
</div><!-- fragment -->This routine is used to compute the volume fraction of the solid phase, void space and electrolyte(Nafion loading) inside the cathode catalyst layer. </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> global_responses(std::vector&lt;double&gt;&amp; resp,</div>
<div class="line">                      <span class="keyword">const</span> <a class="code" href="namespaceFuelCell_1_1ApplicationCore.html#a890c83d37e50f658e28fde74c54d7dc8">FuelCell::ApplicationCore::FEVector</a>&amp;  );</div>
</div><!-- fragment --><a class="anchor" id="membervariables"></a> </p>
<h3>The Member Variables</h3>
In this section we will look at the member variables that are used in this application so the basis of the simulation can be understood. They are usually protected: </p>
<div class="fragment"><div class="line"><span class="keyword">protected</span> :</div>
</div><!-- fragment -->Instead of creating an object, a boost pointer of the base class is used. This is done so that we can select the appropriate child at run-time after checking the input file. This grid object which is derived from the <a class="el" href="classFuelCellShop_1_1Geometry_1_1GridBase.html">geometries </a> class. This object defines dimensions of the cell, generates a grid for each layer and contains material and boundary ids. </p>
<div class="fragment"><div class="line">boost::shared_ptr&lt; FuelCellShop::Geometry::GridBase&lt;dim&gt; &gt; grid;</div>
</div><!-- fragment -->The second member variable is the <a class="el" href="classFuelCell_1_1OperatingConditions.html">operating conditions </a> object that was passed to the initial solution object and explained in more details in the previous section. </p>
<div class="fragment"><div class="line"><a class="code" href="classFuelCell_1_1OperatingConditions.html">FuelCell::OperatingConditions</a> OC;</div>
</div><!-- fragment -->The cathode contains oxygen as the solute and nitrogen as the solvent, so we need to create an object for each gas in order to compute viscosity, density, etc.<div class="fragment"><div class="line"><a class="code" href="classFuelCellShop_1_1Material_1_1Oxygen.html">FuelCellShop::Material::Oxygen</a> solute;</div>
<div class="line"><a class="code" href="classFuelCellShop_1_1Material_1_1Nitrogen.html">FuelCellShop::Material::Nitrogen</a> solvent;</div>
</div><!-- fragment -->Next the cathode gas diffusion layer (CGDL) and cathode catalyst layer (CCL) are created. Again a pointer is used to the base class for each type of layer. We will then select the appropriate CGDL / CCL once we have read the input file. Using a pointer allows us to code everything independently of the layer we want to use. This allows users to develop their own layers. By making them a child of the base class, for example FuelCellShop::Layer::GasDiffusionLayer&lt;dim&gt;, the application will run for your new layer without any modification. For info on how to create your own layer, please consult the documentation on the base layer clases </p>
<div class="fragment"><div class="line">boost::shared_ptr&lt;FuelCellShop::Layer::GasDiffusionLayer&lt;dim&gt; &gt; CGDL;</div>
<div class="line">boost::shared_ptr&lt;FuelCellShop::Layer::MicroPorousLayer&lt;dim&gt; &gt; CMPL;</div>
<div class="line">boost::shared_ptr&lt;FuelCellShop::Layer::CatalystLayer&lt;dim&gt; &gt; CCL;</div>
</div><!-- fragment -->OpenFCST contains a database of materials and layers, but also a database that contains the discrtization of most physical equations relavant to fuel cells. Therefore, we will create an object of the physical processes that are relevant to the cathode. For cathode, we need Ohm's law equation for electrons, Fick's law equation for oxygen, and Ohm's law equation for protons. We also need a source term for the reaction rates.The equation class used to assemble the cell matrix for Fick's mass transport is </p>
<div class="fragment"><div class="line"><a class="code" href="classFuelCellShop_1_1Equation_1_1NewFicksTransportEquation.html">FuelCellShop::Equation::NewFicksTransportEquation&lt;dim&gt;</a> ficks_transport_equation;</div>
</div><!-- fragment --><p> The equation class used to assemble the cell matrix for electron transport is </p>
<div class="fragment"><div class="line"><a class="code" href="classFuelCellShop_1_1Equation_1_1ElectronTransportEquation.html">FuelCellShop::Equation::ElectronTransportEquation&lt;dim&gt;</a> electron_transport_equation;</div>
</div><!-- fragment -->Equation class used to assemble the cell matrix for proton transport is </p>
<div class="fragment"><div class="line"><a class="code" href="classFuelCellShop_1_1Equation_1_1ProtonTransportEquation.html">FuelCellShop::Equation::ProtonTransportEquation&lt;dim&gt;</a> proton_transport_equation;</div>
</div><!-- fragment -->The Equation class to assemble the cell matrix and cell_residual for the reaction source terms is the object of reaction_source_terms. </p>
<div class="fragment"><div class="line"><a class="code" href="classFuelCellShop_1_1Equation_1_1ReactionSourceTerms.html">FuelCellShop::Equation::ReactionSourceTerms&lt; dim &gt;</a> reaction_source_terms;</div>
</div><!-- fragment -->The Class of ORRCurrentDensityResponse is used to calculate the ORR current density and coverages (if provided in the kinetic model) by the catalyst layer.Since the surface area and volume of the catalyst layer is not known, the layer return the total current density produced.And the sum of all coverages at the element.After that, we finish the declaration of the class and the namespaces in the <a class="el" href="app__cathode_8h.html">app_cathode.h</a> file. </p>
<div class="fragment"><div class="line"><a class="code" href="classFuelCellShop_1_1PostProcessing_1_1ORRCurrentDensityResponse.html">FuelCellShop::PostProcessing::ORRCurrentDensityResponse&lt;dim&gt;</a> ORRCurrent;</div>
<div class="line">  };</div>
<div class="line"> } <span class="comment">// Application</span></div>
<div class="line">} <span class="comment">// FuelCell</span></div>
</div><!-- fragment --><a class="anchor" id="mainapplication"></a> </p>
<h2>Source File</h2>
<a class="anchor" id="memberfunctions"></a> </p>
<h3>The Member Functions</h3>
All source files need to include the .h file. Therefore, the first line in our code is </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="app__cathode_8h.html">app_cathode.h</a>&quot;</span></div>
</div><!-- fragment --><p> <br/>
 Since all member functions are in namespace <a class="el" href="namespaceFuelCell_1_1Application.html">FuelCell::Application</a>, it is useful to define a shortcut. </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>NAME = FuelCell::Application;</div>
</div><!-- fragment -->Now, we are ready to start the implementation of all the member functions in AppCathode. <br/>
 <br/>
 Each application is based on the application base class in ApplicationCore (<a class="el" href="classFuelCell_1_1ApplicationCore_1_1ApplicationBase.html" title="Base class for applications. ">FuelCell::ApplicationCore::ApplicationBase</a>), in particular the OptimizationBlockMatrixApplication class (<a class="el" href="classFuelCell_1_1ApplicationCore_1_1OptimizationBlockMatrixApplication.html" title="Application handling matrices and assembling the linear system to solve the sensitivity equations...">FuelCell::ApplicationCore::OptimizationBlockMatrixApplication</a>). This class is the last in a series of inherited classes starting with ApplicationBase that includes DoFApplication (<a class="el" href="classFuelCell_1_1ApplicationCore_1_1DoFApplication.html" title="Base class for all linear applications, i.e., all applications requiring Triangulation and DoFHandler...">FuelCell::ApplicationCore::DoFApplication</a>) and BlockMatrixApplication (<a class="el" href="classFuelCell_1_1ApplicationCore_1_1BlockMatrixApplication.html" title="Application handling matrices and assembling linear systems of equations. ">FuelCell::ApplicationCore::BlockMatrixApplication</a>). The DoFApplication contains a handler for the degrees of freedom, Triangulation and the mesh. BlockMatrixApplication handles the matrices and the assembling of the linear systems of equations. OptimizationBlockMatrixApplication was then added by the OpenFCST developers to handle sensitivity analysis. As such all applications are inherited from OptimizationBlockMatrix. <br/>
 <br/>
 AppCathode constructor will therefore initialize OptimizationBlockMatrixApplication. Also, all equation classes need to be created during the constructor. Finally, we output a line to the terminal stating that this application has been created. </p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">NAME::AppCathode&lt;dim&gt;::AppCathode( boost::shared_ptr&lt; FuelCell::ApplicationCore::ApplicationData &gt; data )</div>
<div class="line">:</div>
<div class="line">FuelCell::ApplicationCore::OptimizationBlockMatrixApplication&lt;<a class="code" href="fcst__constants_8h.html#a665f17c0bbcd89f2925d9ad4c4b077e5">dim</a>&gt;(data),</div>
<div class="line"></div>
<div class="line">ficks_transport_equation(this-&gt;system_management, &amp;solute, &amp;solvent),</div>
<div class="line">electron_transport_equation(this-&gt;system_management),</div>
<div class="line">proton_transport_equation(this-&gt;system_management),</div>
<div class="line">reaction_source_terms(this-&gt;system_management),</div>
<div class="line">ORRCurrent(this-&gt;system_management)</div>
<div class="line">{</div>
<div class="line">  this-&gt;<a class="code" href="namespaceSolverUtils.html#a1ed2e7ed77e8a9ca065d4d01d3dcd245">repair_diagonal</a> = <span class="keyword">true</span>;</div>
<div class="line">  <a class="code" href="namespaceFcstUtilities.html#a376e9c8bd6845e37de9017cb149582fe">FcstUtilities::log</a> &lt;&lt; <span class="stringliteral">&quot;-&gt;FuelCell::Application::AppCathode-&quot;</span> &lt;&lt; <a class="code" href="fcst__constants_8h.html#a665f17c0bbcd89f2925d9ad4c4b077e5">dim</a> &lt;&lt; <span class="stringliteral">&quot;D&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The destructor for AppCathode does not need to remove any extra pointers since boost pointers have their own memory management strategy. </p>
<div class="fragment"><div class="line"> <span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">NAME::AppCathode&lt;dim&gt;::~AppCathode()</div>
<div class="line">{ }</div>
</div><!-- fragment -->Now that the application is created, the next step is to provide the required information to run a simulation. There are three functions that are used to do this. The first is the <code>declare_parameters </code> function. The application needs to declare the parameters it needs from file, but all other objects used by the applicaiton also need to do the same thing. Therefore, declare_parametes contains a call to declare_parameter for all the Materials, Layers and Equation classes. Note that for the Layers and Geometry, a static function is called. The name provided in the call, e.g. "Cathode gas diffusion layer", is the name of the section in the input file where the information need to be provided.<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">NAME::AppCathode&lt;dim&gt;::declare_parameters(ParameterHandler&amp; param)</div>
<div class="line">{</div>
<div class="line">    OptimizationBlockMatrixApplication&lt;dim&gt;::declare_parameters(param);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Declare parameters in operating conditions:</span></div>
<div class="line">    OC.declare_parameters(param);</div>
<div class="line">      </div>
<div class="line">    <span class="comment">// Declare layer and material classes:</span></div>
<div class="line">    solute.declare_parameters(param);</div>
<div class="line">    solvent.declare_parameters(param);</div>
<div class="line">    </div>
<div class="line">    <a class="code" href="classFuelCellShop_1_1Layer_1_1GasDiffusionLayer.html#a4418fbde577dc2e828c87cc86b32a379">FuelCellShop::Layer::GasDiffusionLayer&lt;dim&gt;::declare_GasDiffusionLayer_parameters</a>(<span class="stringliteral">&quot;Cathode gas diffusion layer&quot;</span>, param);</div>
<div class="line">    <a class="code" href="classFuelCellShop_1_1Layer_1_1MicroPorousLayer.html#a6731d13924ec5fab4dee2f06ad238be4">FuelCellShop::Layer::MicroPorousLayer&lt;dim&gt;::declare_MicroPorousLayer_parameters</a>(<span class="stringliteral">&quot;Cathode microporous layer&quot;</span>, param);</div>
<div class="line">    <a class="code" href="classFuelCellShop_1_1Layer_1_1CatalystLayer.html#acb7baaad36ced3a2fea046bfea1ad7ed">FuelCellShop::Layer::CatalystLayer&lt;dim&gt;::declare_CatalystLayer_parameters</a>(<span class="stringliteral">&quot;Cathode catalyst layer&quot;</span>, param);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Declare equation classes:</span></div>
<div class="line">    ficks_transport_equation.declare_parameters(param);</div>
<div class="line">    electron_transport_equation.declare_parameters(param);</div>
<div class="line">    proton_transport_equation.declare_parameters(param);</div>
<div class="line">    reaction_source_terms.declare_parameters(param);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Declare post-processing routines</span></div>
<div class="line">    ORRCurrent.declare_parameters(param);</div>
<div class="line">}</div>
</div><!-- fragment -->The initialise function is the final function in setting up the simulation. It actually parses the prm file, extracts the required values and assigns them to the relevant variables. Again the application function calls the functions of the contributing classes. <br/>
 In initialize, the ParameterHandler object param already contains the information from the input file. Now this information needs to be distributed to all object in the application. <br/>
 First, we initialize <a class="el" href="classFuelCell_1_1ApplicationCore_1_1OptimizationBlockMatrixApplication.html">OptimizationBlockMatrixApplication </a>, operating_conditions (OC), physical properties classes, layer classes, and kinetics parameters in CCL. We also make cell couplings, define kinetics, initialize objects that set initial and boundary conditions, allocate memory for the linear system, and initialize post-processing routines. </p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">NAME::AppCathode&lt;dim&gt;::initialize(ParameterHandler&amp; param)</div>
<div class="line">{   </div>
<div class="line">    <span class="comment">//        </span></div>
<div class="line">    OptimizationBlockMatrixApplication&lt;dim&gt;::initialize(param);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Initialize parameters in operating conditions:</span></div>
<div class="line">    OC.initialize(param);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Initialize materials and layers:</span></div>
<div class="line">    solute.initialize(param);</div>
<div class="line">    solvent.initialize(param);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Initialize gases and material classes:  </span></div>
<div class="line">    std::vector&lt; FuelCellShop::Material::PureGas* &gt; gases;</div>
<div class="line">    gases.push_back(&amp;solute);</div>
<div class="line">    gases.push_back(&amp;solvent);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Initialize layer classes:</span></div>
<div class="line">    CGDL = <a class="code" href="classFuelCellShop_1_1Layer_1_1GasDiffusionLayer.html#a73064f12b7361af73c10bb9cc798c053">FuelCellShop::Layer::GasDiffusionLayer&lt;dim&gt;::create_GasDiffusionLayer</a>(<span class="stringliteral">&quot;Cathode gas diffusion layer&quot;</span>, param);</div>
<div class="line">    CGDL-&gt;set_gases_and_compute(gases, OC.get_pc_atm(), OC.get_T());</div>
<div class="line">    </div>
<div class="line">    CMPL = <a class="code" href="classFuelCellShop_1_1Layer_1_1MicroPorousLayer.html#a1922c3d2b773c2074e04c04c05844889">FuelCellShop::Layer::MicroPorousLayer&lt;dim&gt;::create_MicroPorousLayer</a>(<span class="stringliteral">&quot;Cathode microporous layer&quot;</span>, param);</div>
<div class="line">    CMPL-&gt;set_gases_and_compute(gases, OC.get_pc_atm(), OC.get_T());</div>
<div class="line">    </div>
<div class="line">    CCL  = <a class="code" href="classFuelCellShop_1_1Layer_1_1CatalystLayer.html#aaea6089554e33bbc29c2f5b688a6cb3b">FuelCellShop::Layer::CatalystLayer&lt;dim&gt;::create_CatalystLayer</a>(<span class="stringliteral">&quot;Cathode catalyst layer&quot;</span>, param);</div>
<div class="line">    CCL-&gt;set_gases_and_compute(gases, OC.get_pc_atm(), OC.get_T());</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Initialise the necessary kinetics parameters in CCL.</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="system__management_8h.html#a800da0c8109f6e65327b4de20d4a0c10">ReactionNames</a> name = <a class="code" href="system__management_8h.html#a800da0c8109f6e65327b4de20d4a0c10a51e6b781fcc0468896f60da150026bd5">ORR</a>;</div>
<div class="line">    CCL-&gt;set_reaction_kinetics(name);</div>
<div class="line">    CCL-&gt;set_constant_solution(OC.get_pc_Pa(), <a class="code" href="system__management_8h.html#a905465f7ef35ccf9a9a5fa54e2afd938a55203f2bf9c613ef5d5d6e4307b56003">VariableNames::total_pressure</a>);</div>
<div class="line">    CCL-&gt;set_constant_solution(OC.get_T(), <a class="code" href="system__management_8h.html#a905465f7ef35ccf9a9a5fa54e2afd938a3f92f8366faa0afba7787098cf3b8b87">VariableNames::temperature_of_REV</a>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Setting kinetics in the reaction source terms object.    </span></div>
<div class="line">    reaction_source_terms.set_cathode_kinetics(CCL-&gt;get_kinetics());</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Initialize parameters for physics classes:</span></div>
<div class="line">    ficks_transport_equation.initialize(param);</div>
<div class="line">    electron_transport_equation.initialize(param);</div>
<div class="line">    proton_transport_equation.initialize(param);</div>
<div class="line">    reaction_source_terms.initialize(param);</div>
<div class="line">        </div>
<div class="line">    <span class="comment">// --- second of all we make cell couplings for this problem ---</span></div>
<div class="line">    std::vector&lt;couplings_map&gt; tmp;</div>
<div class="line">    tmp.push_back( ficks_transport_equation.get_internal_cell_couplings()    );</div>
<div class="line">    tmp.push_back( electron_transport_equation.get_internal_cell_couplings() );</div>
<div class="line">    tmp.push_back( proton_transport_equation.get_internal_cell_couplings()   );</div>
<div class="line">    reaction_source_terms.adjust_internal_cell_couplings(tmp);</div>
<div class="line">    this-&gt;system_management.make_cell_couplings(tmp);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Now, initialize object that are used to setup initial solution and boundary conditions:    </span></div>
<div class="line">    this-&gt;component_materialID_value_maps.push_back( ficks_transport_equation.get_component_materialID_value()    );</div>
<div class="line">    this-&gt;component_materialID_value_maps.push_back( electron_transport_equation.get_component_materialID_value() );</div>
<div class="line">    this-&gt;component_materialID_value_maps.push_back( proton_transport_equation.get_component_materialID_value()   );</div>
<div class="line">    OC.adjust_initial_solution(this-&gt;component_materialID_value_maps, this-&gt;mesh_generator);</div>
<div class="line">    </div>
<div class="line">    this-&gt;component_boundaryID_value_maps.push_back( ficks_transport_equation.get_component_boundaryID_value() );</div>
<div class="line">    this-&gt;component_boundaryID_value_maps.push_back( electron_transport_equation.get_component_boundaryID_value() );</div>
<div class="line">    this-&gt;component_boundaryID_value_maps.push_back( proton_transport_equation.get_component_boundaryID_value()   );</div>
<div class="line">    OC.adjust_boundary_conditions(this-&gt;component_boundaryID_value_maps, this-&gt;mesh_generator);</div>
<div class="line">}</div>
</div><!-- fragment -->Let's look closer at this routine. The line </p>
<div class="fragment"><div class="line">std::vector&lt; FuelCellShop::Material::PureGas* &gt; gases;</div>
</div><!-- fragment --><p> creates a vector with all the gases that will exist in the layers.Each entry of this std::vector reflects the following structure (see <a class="el" href="namespaceFuelCell_1_1InitialAndBoundaryData.html">FuelCell::InitialAndBoundaryData</a> namespace docs):</p>
<ul>
<li><code>first</code> <code>argument</code> : name of the solution component,</li>
<li><code>second</code> <code>argument</code> : material id,</li>
<li><code>third</code> <code>argument</code> : value of the solution component. <div class="fragment"><div class="line">std::vector&lt; component_materialID_value_map &gt; component_materialID_value_maps; </div>
</div><!-- fragment --></li>
</ul>
Next, we call create_GasDiffusionLayer. This function reads the parameter file section Fuel Cell Data &gt; Cathode gas diffusion layer, reads the type of GDL that we would like to use, and then initializes the pointer CGDL to the appropriate GasDiffusionLayer child. In this case, DesignFibrousGDL as we will see when discussing the parameter file.<div class="fragment"><div class="line">CGDL = <a class="code" href="classFuelCellShop_1_1Layer_1_1GasDiffusionLayer.html#a73064f12b7361af73c10bb9cc798c053">FuelCellShop::Layer::GasDiffusionLayer&lt;dim&gt;::create_GasDiffusionLayer</a>(<span class="stringliteral">&quot;Cathode gas diffusion layer&quot;</span>, param);</div>
<div class="line">CGDL-&gt;set_gases_and_compute(gases, OC.get_pc_atm(), OC.get_T());</div>
</div><!-- fragment -->Once the layer has been initialized, we "fill" the layer with the gases using CGDL-&gt;set_gases_and_compute(gases, OC.get_pc_atm (), OC.get_T()). This routine is used to store the gases, the temperature and the pressure in the layer and to compute the diffusion coefficients. <br/>
 MicroPorousLayer and CatalystLayer objects are initialized using the same method.<div class="fragment"><div class="line">CMPL = <a class="code" href="classFuelCellShop_1_1Layer_1_1MicroPorousLayer.html#a1922c3d2b773c2074e04c04c05844889">FuelCellShop::Layer::MicroPorousLayer&lt;dim&gt;::create_MicroPorousLayer</a>(<span class="stringliteral">&quot;Cathode microporous layer&quot;</span>, param);</div>
<div class="line">CMPL-&gt;set_gases_and_compute(gases, OC.get_pc_atm(), OC.get_T());</div>
<div class="line"></div>
<div class="line">CCL  = <a class="code" href="classFuelCellShop_1_1Layer_1_1CatalystLayer.html#aaea6089554e33bbc29c2f5b688a6cb3b">FuelCellShop::Layer::CatalystLayer&lt;dim&gt;::create_CatalystLayer</a>(<span class="stringliteral">&quot;Cathode catalyst layer&quot;</span>, param);</div>
<div class="line">CCL-&gt;set_gases_and_compute(gases, OC.get_pc_atm(), OC.get_T());</div>
</div><!-- fragment -->For the CatalystLayer object, in addition to specifying the type of gas inside the layer, we also need to specify the reactions that we are interested in solving for since the catalyst layer class contains a kinetics objects which will compute the reaction rates for different reactions. In order to compute the reactions, we need to know the overpotential, temperature and pressure. Every time we call the cell_matrix and cell_residual function, we pass the solution (which will contain the oxygen molar fraction and the two potentials) to the kinetics class. However the kinetics class expects that the temperature and pressure are solution variables (i.e.that it is set at each quadrature point for each cell). <a class="el" href="classFuelCellShop_1_1Layer_1_1CatalystLayer.html#af917e0fa80d1ef59d0d0c9e01d24439e">(OC.get_pc_Pa(), VariableNames::total_pressure) </a> and <a class="el" href="classFuelCellShop_1_1Layer_1_1CatalystLayer.html#af917e0fa80d1ef59d0d0c9e01d24439e">(OC.get_T(), temperature_of_REV) </a> are used to specify that these variables are constant and should take the value provided as the first argument.<div class="fragment"><div class="line"><span class="comment">// Initialise the necessary kinetics parameters in CCL.</span></div>
<div class="line"><span class="keyword">const</span> <a class="code" href="system__management_8h.html#a800da0c8109f6e65327b4de20d4a0c10">ReactionNames</a> name = <a class="code" href="system__management_8h.html#a800da0c8109f6e65327b4de20d4a0c10a51e6b781fcc0468896f60da150026bd5">ORR</a>;</div>
<div class="line">CCL-&gt;set_reaction_kinetics(name);</div>
<div class="line">CCL-&gt;set_constant_solution(OC.get_pc_Pa(), <a class="code" href="system__management_8h.html#a905465f7ef35ccf9a9a5fa54e2afd938a55203f2bf9c613ef5d5d6e4307b56003">VariableNames::total_pressure</a>);</div>
<div class="line">CCL-&gt;set_constant_solution(OC.get_T(), <a class="code" href="system__management_8h.html#a905465f7ef35ccf9a9a5fa54e2afd938a3f92f8366faa0afba7787098cf3b8b87">VariableNames::temperature_of_REV</a>);</div>
</div><!-- fragment -->Once the layers have been initialized, it is time to initialize the Equation objects. <br/>
 Before initializing the objects, we set the kinetics in the reaction source term object. Next, we allow all Equation object to read all their parameters from file: </p>
<div class="fragment"><div class="line"><span class="comment">// Setting kinetics in the reaction source terms object.</span></div>
<div class="line">reaction_source_terms.set_cathode_kinetics(CCL-&gt;get_kinetics());</div>
<div class="line"></div>
<div class="line"><span class="comment">// Initialize parameters for physics classes:</span></div>
<div class="line">electron_transport_equation.initialize(param);  </div>
<div class="line">proton_transport_equation.initialize(param);  </div>
<div class="line">ficks_transport_equation.initialize(param);  </div>
<div class="line">reaction_source_terms.initialize(param);</div>
</div><!-- fragment -->Next is to prepare the matrix that will contain our system of equations. This involves telling the application how the equations are coupled, i.e. how one solution variable affects the other equations. The blocks for our three equation system are visualised below: </p>
<table  width="20%" align="center">
<tr>
<td align="center"><div class="image">
<img src="tutorial_blocks.png" alt="tutorial_blocks.png"/>
</div>
   </td></tr>
</table>
After the coupling step, we initialize objects that are used to set initial and boundary conditions.Each equation has its corresponding solution values id in the material since <code>component_materialID_value_maps</code> is a vector. By doing the <code>push_back</code>, we store all the solution name with its corresponding material id and values inside the <code>component_materialID_value_maps</code>. The function <code>adjust_initial_solution</code> is used to compute the initial value of of each solution variable inside the material.<div class="fragment"><div class="line">component_materialID_value_maps.push_back( ficks_transport_equation.get_component_materialID_value()    );</div>
<div class="line">component_materialID_value_maps.push_back( electron_transport_equation.get_component_materialID_value() );</div>
<div class="line">component_materialID_value_maps.push_back( proton_transport_equation.get_component_materialID_value()   );</div>
<div class="line">OC.adjust_initial_solution(component_materialID_value_maps, grid);</div>
</div><!-- fragment -->Same for boundaries:<div class="fragment"><div class="line">this-&gt;component_boundaryID_value_maps.push_back( ficks_transport_equation.get_component_boundaryID_value() );</div>
<div class="line">this-&gt;component_boundaryID_value_maps.push_back( electron_transport_equation.get_component_boundaryID_value() );</div>
<div class="line">this-&gt;component_boundaryID_value_maps.push_back( proton_transport_equation.get_component_boundaryID_value()   );</div>
<div class="line">OC.adjust_boundary_conditions(this-&gt;component_boundaryID_value_maps, this-&gt;mesh_generator);</div>
</div><!-- fragment -->The next step is to initialise the matrix that will store the system of equations. </p>
<div class="fragment"><div class="line">this-&gt;remesh_matrices();</div>
</div><!-- fragment -->To compute other variables like O_coverage or OH_coverage, we need to initialize the post_processing routines. </p>
<div class="fragment"><div class="line">ORRCurrent.initialize(param);</div>
</div><!-- fragment --><p> That is all. You might want to call the following routines that are used to print information to screen in order to make sure you have initialized your layers correctly: </p>
<div class="fragment"><div class="line"><span class="comment">// Some info for debugging purposes:</span></div>
<div class="line">  <span class="comment">//system_management.print_system_info ();</span></div>
<div class="line">  CGDL-&gt;print_layer_properties();</div>
<div class="line">  CMPL-&gt;print_layer_properties();</div>
<div class="line">  CCL-&gt;print_layer_properties();</div>
<div class="line">   <span class="comment">//abort();</span></div>
<div class="line">}</div>
</div><!-- fragment -->The last part of the setting up the simulation involves providing information about the initial solution to the nonlinear solver. This is done with the <a class="el" href="classFuelCell_1_1Application_1_1AppCathode.html#ac78043af61d279079c3baefb6814bfd8">initialize_solution </a> function. </p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">NAME::AppCathode&lt;dim&gt;::initialize_solution(<a class="code" href="namespaceFuelCell_1_1ApplicationCore.html#a890c83d37e50f658e28fde74c54d7dc8">FuelCell::ApplicationCore::FEVector</a>&amp; initial_guess,</div>
<div class="line">                                           std::shared_ptr&lt;Function&lt;dim&gt; &gt; initial_function)</div>
<div class="line">{</div>
<div class="line">    DoFApplication&lt;dim&gt;::initialize_solution(initial_guess);    </div>
<div class="line">}</div>
</div><!-- fragment --><br/>
 <br/>
 The simulation has now been set up so we can start to work on the member functions that are used to assemble the local (element-wise) matrix and residual (right hand side). <br/>
 <br/>
 The two most important functions in the application are the <a class="el" href="classFuelCell_1_1Application_1_1AppCathode.html#aa8645fd06553915ac34e9ff1f820ac08">cell_matrix </a> and <a class="el" href="classFuelCell_1_1Application_1_1AppCathode.html#a77c3e1c09d28fdeb1230a5589603cdf8">cell_residual </a> functions. The functions provide the coefficients for the left and right hand side of our linearised system of equations respectively ( <img class="formulaInl" alt="$ \frac{dR(u,p)}{du}(-\delta u) = R(u,p)$" src="form_504.png"/>). <br/>
 <br/>
 We will start with the <a class="el" href="classFuelCell_1_1Application_1_1AppCathode.html#aa8645fd06553915ac34e9ff1f820ac08">cell_matrix </a> function which implements the integration of the local bilinear form. Here we loop over the quadrature points and over degrees of freedom in order to compute the matrix for the cell. This routine depends on the problem at hand and is called in <a class="el" href="classFuelCell_1_1ApplicationCore_1_1BlockMatrixApplication.html#a45dd7414e3871275d5c2a80654c618ed">assemble </a> in BlockMatrixApplication class. <br/>
 <br/>
 In this case, the matrix to be assembled is given below: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \begin{array}{l} M(i,j).block(0) = \int_{\Omega} a \nabla \phi_i \nabla \phi_j d\Omega + \int_{\Omega} \phi_i \frac{\partial f}{\partial u_0}\Big|_n \phi_j d\Omega \quad \qquad \\ M(i,j).block(1) = \int_{\Omega} \phi_i \frac{\partial f}{\partial u_1}\Big|_n \phi_j d\Omega \\ M(i,j).block(2) = \int_{\Omega} \phi_i \frac{\partial f}{\partial u_2}\Big|_n \phi_j d\Omega \\ M(i,j).block(3) = \int_{\Omega} \phi_i \frac{\partial f}{\partial u_0}\Big|_n \phi_j d\Omega \\ M(i,j).block(4) = \int_{\Omega} a \nabla \phi_i \nabla \phi_j d\Omega + \int_{\Omega} \phi_i \frac{\partial f}{\partial u_1}\Big|_n \phi_j d\Omega \quad \qquad \\ M(i,j).block(5) = \int_{\Omega} \phi_i \frac{\partial f}{\partial u_2}\Big|_n \phi_j d\Omega \\ M(i,j).block(6) = \int_{\Omega} \phi_i \frac{\partial f}{\partial u_0}\Big|_n \phi_j d\Omega \\ M(i,j).block(7) = \int_{\Omega} \phi_i \frac{\partial f}{\partial u_1}\Big|_n \phi_j d\Omega \\ M(i,j).block(8) = \int_{\Omega} a \nabla \phi_i \nabla \phi_j d\Omega + \int_{\Omega} \phi_i \frac{\partial f}{\partial u_2}\Big|_n \phi_j d\Omega \end{array} \]" src="form_505.png"/>
</p>
<p> <br/>
 <br/>
 OpenFCST already contains many equation classes which are used to assemble the local cell matrices. Therefore, assembling the matrices is extremely simple. Simply call the Equation classes you want to solve! <br/>
 <code>cell_matrix</code> receives a MatrixVector object containing a vector of local matrices corresponding to all the non-zero matrices in the global matrix such that cell_matrices[0] corresponds to M(i,j).block(0), and a <code>CellInfo</code> object that </p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">NAME::AppCathode&lt;dim&gt;::cell_matrix(<a class="code" href="namespaceFuelCell_1_1ApplicationCore.html#a8ca0ab5b96a1a26ea639900d7c36ee64">FuelCell::ApplicationCore::MatrixVector</a>&amp;                                 cell_matrices,</div>
<div class="line">                                     <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classFuelCell_1_1ApplicationCore_1_1IntegrationInfo.html">FuelCell::ApplicationCore::DoFApplication&lt;dim&gt;::CellInfo</a>&amp; cell_info)</div>
</div><!-- fragment -->In this case, we solve a different set of equations for each layer. In the gas diffusion layer, we solve for Fick's law of diffusion and electron transport. Therefore, we can ask our Equation classes to assemble the local matrices for GDL cells using the information provided by the CGDL class. <br/>
 A particular layer is identified through its material id for any particular cell. The information of material id is accessed using the member function material_id() in the <a class="el" href="classFuelCell_1_1ApplicationCore_1_1DoFApplication.html#af57ff016b9c8bab639f37e580a24f7e6">info </a> object. <br/>
 Equation classes such as <code>ficks_transport_equation</code>, <code>electron_transport_equation</code>,<code> proton_transport_equation</code> and <code>reaction_source</code> have an inbuilt function <code>assemble_cell_matrix</code> which assembles the local matrix and passes the local matrix to the MatrixVector which is a vector of local matrices, it assembles the local matrices and makes them global. The call to <code>assemble_cell_matrix</code> will return M(i,j).block(0) filled based on the properties of the cell and the CGDL.<div class="fragment"><div class="line"><span class="keywordflow">if</span>(      CGDL-&gt;belongs_to_material(cell_info.<a class="code" href="classFuelCell_1_1ApplicationCore_1_1DoFInfo.html#a407b06e87ebc7a3260e5b884cbe157c6">cell</a>-&gt;material_id())   )</div>
<div class="line">{</div>
<div class="line">    ficks_transport_equation.assemble_cell_matrix(cell_matrices, cell_info, CGDL.get());</div>
<div class="line">    electron_transport_equation.assemble_cell_matrix(cell_matrices, cell_info, CGDL.get());</div>
<div class="line">}</div>
</div><!-- fragment -->The same process can be applied to the MPL: </p>
<div class="fragment"><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span>( CMPL-&gt;belongs_to_material(cell_info.<a class="code" href="classFuelCell_1_1ApplicationCore_1_1DoFInfo.html#a407b06e87ebc7a3260e5b884cbe157c6">cell</a>-&gt;material_id())   )</div>
<div class="line">{</div>
<div class="line">    ficks_transport_equation.assemble_cell_matrix(cell_matrices, cell_info, CMPL.get());</div>
<div class="line">    electron_transport_equation.assemble_cell_matrix(cell_matrices, cell_info, CMPL.get());</div>
<div class="line">}</div>
</div><!-- fragment -->In the catalyst layer, we want to solve not only for oxygen and electron transport but also for proton transport and for the reaction terms. Therefore, all four Equation objects are called in order to provide the required information in cell_matrices.<div class="fragment"><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span>( CCL-&gt;belongs_to_material(cell_info.<a class="code" href="classFuelCell_1_1ApplicationCore_1_1DoFInfo.html#a407b06e87ebc7a3260e5b884cbe157c6">cell</a>-&gt;material_id())    )</div>
<div class="line">{</div>
<div class="line">    ficks_transport_equation.assemble_cell_matrix(cell_matrices, cell_info, CCL.get());</div>
<div class="line">    electron_transport_equation.assemble_cell_matrix(cell_matrices, cell_info, CCL.get());</div>
<div class="line">    proton_transport_equation.assemble_cell_matrix(cell_matrices, cell_info, CCL.get());</div>
<div class="line">    reaction_source_terms.assemble_cell_matrix(cell_matrices, cell_info, CCL.get());</div>
<div class="line">}</div>
</div><!-- fragment -->Finally, if the mesh contains cells with a material ID that does not correspond to any of the layers defined in the application, we will ask the program to provide an error message: </p>
<div class="fragment"><div class="line">   <span class="keywordflow">else</span></div>
<div class="line">   {</div>
<div class="line">      <a class="code" href="namespaceFcstUtilities.html#a376e9c8bd6845e37de9017cb149582fe">FcstUtilities::log</a>&lt;&lt;<span class="stringliteral">&quot;Material id: &quot;</span>    &lt;&lt;cell_info.<a class="code" href="classFuelCell_1_1ApplicationCore_1_1DoFInfo.html#a407b06e87ebc7a3260e5b884cbe157c6">cell</a>-&gt;material_id()&lt;&lt;<span class="stringliteral">&quot; does not correspond to any layer&quot;</span>&lt;&lt;std::endl;</div>
<div class="line">      Assert( <span class="keyword">false</span> , ExcNotImplemented() );</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment -->Using the process specified above, local cell matrices are formed for all three layers and equations. <br/>
 <br/>
 This completes the <code>cell_matrix</code> function. We can now move onto the <code>cell_residual</code> and the right hand side (RHS). <br/>
 <br/>
 The <a class="el" href="classFuelCell_1_1Application_1_1AppCathode.html#a77c3e1c09d28fdeb1230a5589603cdf8">cell_residual </a> function works similarly to the <code>cell_matrix</code> member function. The main difference is that in constructing the RHS we are not assembling a matrix, but a vector, which is why <code>cell_vector</code> is passed in the <code>cell_residual</code> function call. <br/>
 The vector we are constructing is given by:<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \begin{array}{l} R(i),block(i) = \int_{\Omega} \phi_j a (\nabla u)^n d\Omega + \int_{\Omega} \phi_j f(u^n) d\Omega \end{array} \]" src="form_506.png"/>
</p>
<p> <br/>
 In our case this can be written as:<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \begin{array}{l} R(i),block(0) = \int_{\Omega} \phi_j D_{O_2} (\nabla x_{O_2})^n d\Omega + \int_{\Omega} \phi_j \left( \frac{i(u^n)}{4F} \right) d\Omega \\ R(i),block(1) = \int_{\Omega} \phi_j \sigma_m (\nabla \phi_m)^n d\Omega + \int_{\Omega} \phi_j \left( \frac{i(u^n)}{F} \right) d\Omega \\ R(i),block(2) = \int_{\Omega} \phi_j \sigma_s (\nabla \phi_m)^n d\Omega + \int_{\Omega} \phi_j \left( \frac{i(u^n)}{-F} \right) d\Omega \end{array} \]" src="form_507.png"/>
</p>
where <img class="formulaInl" alt="$ {u}^n $" src="form_508.png"/> is the solution at the <img class="formulaInl" alt="$ n $" src="form_354.png"/> iteration in the Newton loop. <br/>
 <br/>
 <code>cell_residual</code> takes two arguments, a BlockVector that should be initialized to the local right hand side, i.e. element-wise right hand side, and a CellInfo object that contains information regarding the cell finite element, material id, boundary id and the solution at the quadrature points in the cell. This information is used to setup the right hand side. <br/>
 As in <code>cell_matrix</code>, we first check at which material the cell belongs to and, based on its material id, we use the appropriate Equation class to assemble the right hand side. In this case, this is done by calling the member function <code>assemble_cell_residual</code>.<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">NAME::AppCathode&lt;dim&gt;::cell_residual(<a class="code" href="namespaceFuelCell_1_1ApplicationCore.html#a890c83d37e50f658e28fde74c54d7dc8">FuelCell::ApplicationCore::FEVector</a>&amp;                                     cell_res,</div>
<div class="line">                                       <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classFuelCell_1_1ApplicationCore_1_1IntegrationInfo.html">FuelCell::ApplicationCore::DoFApplication&lt;dim&gt;::CellInfo</a>&amp; cell_info)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span>(      CGDL-&gt;belongs_to_material(cell_info.<a class="code" href="classFuelCell_1_1ApplicationCore_1_1DoFInfo.html#a407b06e87ebc7a3260e5b884cbe157c6">cell</a>-&gt;material_id())   )</div>
<div class="line">    {</div>
<div class="line">        ficks_transport_equation.assemble_cell_residual(cell_res, cell_info, CGDL.get());</div>
<div class="line">        electron_transport_equation.assemble_cell_residual(cell_res, cell_info, CGDL.get());</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>( CMPL-&gt;belongs_to_material(cell_info.<a class="code" href="classFuelCell_1_1ApplicationCore_1_1DoFInfo.html#a407b06e87ebc7a3260e5b884cbe157c6">cell</a>-&gt;material_id())   )</div>
<div class="line">    {</div>
<div class="line">        ficks_transport_equation.assemble_cell_residual(cell_res, cell_info, CMPL.get());</div>
<div class="line">        electron_transport_equation.assemble_cell_residual(cell_res, cell_info, CMPL.get());</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>( CCL-&gt;belongs_to_material(cell_info.<a class="code" href="classFuelCell_1_1ApplicationCore_1_1DoFInfo.html#a407b06e87ebc7a3260e5b884cbe157c6">cell</a>-&gt;material_id())    )</div>
<div class="line">     {</div>
<div class="line">        ficks_transport_equation.assemble_cell_residual(cell_res, cell_info, CCL.get());</div>
<div class="line">        electron_transport_equation.assemble_cell_residual(cell_res, cell_info, CCL.get());</div>
<div class="line">        proton_transport_equation.assemble_cell_residual(cell_res, cell_info, CCL.get());</div>
<div class="line">        reaction_source_terms.assemble_cell_residual(cell_res, cell_info, CCL.get());</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="namespaceFcstUtilities.html#a376e9c8bd6845e37de9017cb149582fe">FcstUtilities::log</a>&lt;&lt;<span class="stringliteral">&quot;Material id: &quot;</span>    &lt;&lt;cell_info.<a class="code" href="classFuelCell_1_1ApplicationCore_1_1DoFInfo.html#a407b06e87ebc7a3260e5b884cbe157c6">cell</a>-&gt;material_id()&lt;&lt;<span class="stringliteral">&quot; does not correspond to any layer&quot;</span>&lt;&lt;std::endl;</div>
<div class="line">      Assert( <span class="keyword">false</span> , ExcNotImplemented() );</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment -->Next, we need to define the boundary conditions for the three solution variables. Note that since we are solving a linearized system, the boundary conditions are not for the solution variables oxygen mole fraction, electrical and proton potential, but for their variation, i.e. <img class="formulaInl" alt="$ \delta u $" src="form_509.png"/> instead of <img class="formulaInl" alt="$ u $" src="form_510.png"/>. Therefore, the variation of each boundary conditon of the nonlinear problem needs to be implemented here. <br/>
 <br/>
Dirichlet boundary conditions on the solution variables have a variation of zero, i.e. if the initial solution satisfies the boundary conditions, the Dirichlet boundary conditions on the variations are that the variation should be zero. <br/>
 <br/>
 Imposing a zero Dirichlet boundary condition is done by the <a class="el" href="classFuelCell_1_1Application_1_1AppCathode.html#ad6b845323128fc024dbfc8479a2fa418">dirichlet_bc </a> function. This function fills a std::map named boundary_values with an unsigned int representing the degree of freedom and the Dirichlet value of the boundary condition. In this case, all Dirichlet boundaries will have a zero value.<div class="fragment"><div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> </div>
<div class="line">NAME::AppCathode&lt;dim&gt;::dirichlet_bc(std::map&lt;unsigned int, double&gt;&amp; boundary_values)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <a class="code" href="namespaceFuelCell_1_1InitialAndBoundaryData.html#ae260a077a802e7d58cce69a57d295d1e">FuelCell::InitialAndBoundaryData::make_zero_boundary_values</a>( boundary_values,</div>
<div class="line">                                                               this-&gt;mapping,</div>
<div class="line">                                                               this-&gt;dof,</div>
<div class="line">                                                               system_management,</div>
<div class="line">                                                               component_boundaryID_value_maps );</div>
<div class="line">}</div>
</div><!-- fragment --><br/>
 <br/>
 <a class="el" href="classFuelCell_1_1Application_1_1AppCathode.html#a09127276e5d6ce56420f6bdf83cc8157">cell_responses </a> function is used to calculate the value of all objective functions and constraints which require looping over cells. </p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">NAME::Application::AppCathode&lt;dim&gt;::cell_responses(std::vector&lt;double&gt;&amp;                                                     dst,</div>
<div class="line">                                        <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classFuelCell_1_1ApplicationCore_1_1IntegrationInfo.html">FuelCell::ApplicationCore::DoFApplication&lt;dim&gt;::CellInfo</a>&amp; cell_info,</div>
<div class="line">                                        <span class="keyword">const</span> <a class="code" href="namespaceFuelCell_1_1ApplicationCore.html#a890c83d37e50f658e28fde74c54d7dc8">FuelCell::ApplicationCore::FEVector</a>&amp; src)</div>
<div class="line">{</div>
</div><!-- fragment --><p> The material id of the active cells or Catalyst Layer (CL) is obtained by querying the <code>dof_active_cell</code> for the <code>material_id</code> property. </p>
<div class="fragment"><div class="line"><span class="comment">// -- Find out what material is the cell made of, i.e. MEA layer)</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> material_id = cell_info.<a class="code" href="classFuelCell_1_1ApplicationCore_1_1DoFInfo.html#acfde9ad770f2f0e3e99561b0ec8da687">dof_active_cell</a>-&gt;material_id();</div>
</div><!-- fragment --><p> Next we define a map for the response object from <code>PostProcessing</code> class and use it to calculate the ORR Response in the Catalyst Layer by comparing the cells to the CL material id </p>
<div class="fragment"><div class="line"><span class="comment">// Compute ORR responses in the CL</span></div>
<div class="line">std::map&lt;FuelCellShop::PostProcessing::ResponsesNames, double&gt; ORR_responses;</div>
<div class="line">  </div>
<div class="line"><span class="keywordflow">if</span> (CCL-&gt;belongs_to_material(material_id)) <span class="comment">//the material is the catalyst layer</span></div>
<div class="line">{  </div>
<div class="line">    ORRCurrent.compute_responses(cell_info, CCL.get(), ORR_responses);        </div>
<div class="line">}</div>
</div><!-- fragment --><p> Finally we calculate the geometric properties like length of catalyst (<code>L_cat</code>), cross-sectional area of CL (<code>area_CL</code> and volume of the CL (<code>volume_CL</code>). Now with these geometric values defined we can normalize our responses like current, OH coverage, and Oxygen coverage w.r.t. the CL. Based on the response names defined by the user we calculate one or all of the above. </p>
<div class="fragment"><div class="line"><span class="comment">// Organize responses:</span></div>
<div class="line"><span class="comment">// -- Used to normalize current density (note necessary since it can be done via input file)</span></div>
<div class="line">std::vector&lt;double&gt; L_cat_vec = grid-&gt;L_cat_c();</div>
<div class="line"><span class="keywordtype">double</span> L_cat = std::accumulate(L_cat_vec.begin(),L_cat_vec.end(),0.0);</div>
<div class="line"><span class="keywordtype">double</span> area_CL = grid-&gt;L_channel_c()/2.0 + grid-&gt;L_land_c()/2.0;</div>
<div class="line"><span class="keywordtype">double</span> volume_CL = (grid-&gt;L_channel_c()/2.0 + grid-&gt;L_land_c()/2.0)*L_cat;</div>
<div class="line">  </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> r = 0; r &lt; this-&gt;n_resp; ++r)</div>
<div class="line"> {</div>
<div class="line">    <span class="keywordflow">if</span> (this-&gt;name_responses[r] == <span class="stringliteral">&quot;current&quot;</span> &amp;&amp; CCL-&gt;belongs_to_material(material_id))</div>
<div class="line">        dst[r] += -1*ORR_responses[<a class="code" href="namespaceFuelCellShop_1_1PostProcessing.html#ac0f58decbd183bb22f85f37c4055e297aeb7ec0064eb6022a4d1c3f786e35627d">FuelCellShop::PostProcessing::ResponsesNames::ORR_current</a>]/ area_CL;</div>
<div class="line">        <span class="comment">//(If using response normalization) resp[r] += ORR_responses[FuelCellShop::PostProcessing::ResponsesNames::current];               </span></div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this-&gt;name_responses[r] == <span class="stringliteral">&quot;OH_coverage&quot;</span> &amp;&amp; CCL-&gt;belongs_to_material(material_id))</div>
<div class="line">        dst[r] += (1/volume_CL)*ORR_responses[<a class="code" href="system__management_8h.html#a905465f7ef35ccf9a9a5fa54e2afd938a22d7fe6e70fd02ace65d601ea6d28283">FuelCellShop::PostProcessing::ResponsesNames::OH_coverage</a>];</div>
<div class="line">        <span class="comment">//(If using response normalization) resp[r] += ORR_responses[FuelCellShop::PostProcessing::ResponsesNames::OH_coverage];</span></div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this-&gt;name_responses[r] == <span class="stringliteral">&quot;O_coverage&quot;</span> &amp;&amp; CCL-&gt;belongs_to_material(material_id))</div>
<div class="line">        dst[r] += (1/volume_CL)*ORR_responses[<a class="code" href="system__management_8h.html#a905465f7ef35ccf9a9a5fa54e2afd938ae54137ec0dd8d6afa9c1b8ecc757e67c">FuelCellShop::PostProcessing::ResponsesNames::O_coverage</a>];</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">}</div>
</div><!-- fragment --><br/>
 Next is the <a class="el" href="classFuelCell_1_1Application_1_1AppCathode.html#a6aa3ea329e3b55ab2d30e11108c69989">global_responses </a> function. The <code>global_responses</code> function is used when computing the volume fraction of each component inside the cathode catalyst layer. In this case, the three constraint components inside the cathode catalyst layer electrolyte loading (Nafion), solid phase (carbon fibres) and the void space (empty space) for oxygen transportation. </p>
<div class="fragment"><div class="line">std::vector&lt;unsigned int&gt; cathode_CL_material_ids;</div>
<div class="line">std::map&lt;std::string, double&gt; volume_fractions;</div>
<div class="line">cathode_CL_material_ids = CCL-&gt;get_material_ids();</div>
</div><!-- fragment -->As the name states, the cathode_CL_material_ids is the material id defined in the parameter file which belongs to CCL. The volume_fractions is actually a map, the key is the name of the component inside the CCL and the value is the volume fraction corresponding to it. cathode_CL_material_ids = CCL-&gt;get_material_ids(); is to find the material id and give the values to cathode_CL_material_ids. </p>
<div class="fragment"><div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; cathode_CL_material_ids.size(); ++i)</div>
<div class="line">{</div>
<div class="line">    </div>
<div class="line">    CCL-&gt;set_local_material_id(cathode_CL_material_ids[i]);</div>
<div class="line">    CCL-&gt;get_volume_fractions(volume_fractions);</div>
<div class="line">    std::string epsilonc = <span class="stringliteral">&quot;epsilon_V_cat_c:&quot;</span>;</div>
<div class="line">    std::stringstream epsilon_c;</div>
<div class="line">    epsilon_c &lt;&lt; epsilonc &lt;&lt; cathode_CL_material_ids[i];</div>
<div class="line">    </div>
<div class="line">    std::string epsilons = <span class="stringliteral">&quot;epsilon_S_cat_c:&quot;</span>;</div>
<div class="line">    std::stringstream epsilon_s;</div>
<div class="line">    epsilon_s &lt;&lt; epsilons &lt;&lt; cathode_CL_material_ids[i];</div>
<div class="line">   </div>
<div class="line">    std::string epsilonn = <span class="stringliteral">&quot;epsilon_N_cat_c:&quot;</span>;</div>
<div class="line">    std::stringstream epsilon_n;</div>
<div class="line">    epsilon_n &lt;&lt; epsilonn &lt;&lt; cathode_CL_material_ids[i];</div>
<div class="line">   </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> r = 0; r &lt; this-&gt;n_resp; ++r)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (this-&gt;name_responses[r].compare(epsilon_c.str()) == 0) {</div>
<div class="line">            resp[r] = volume_fractions.find(<span class="stringliteral">&quot;Void&quot;</span>)-&gt;second;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this-&gt;name_responses[r].compare(epsilon_s.str()) == 0) {</div>
<div class="line">            resp[r] = volume_fractions.find(<span class="stringliteral">&quot;Solid&quot;</span>)-&gt;second;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this-&gt;name_responses[r].compare(epsilon_n.str()) == 0) {</div>
<div class="line">            resp[r] = volume_fractions.find(<span class="stringliteral">&quot;Ionomer&quot;</span>)-&gt;second;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment -->The first loop is looping over the material id and sets local material_id to the actual id it belongs to. The volume_fraction is computed directly through the function calling CCL-&gt;get_volume_fractions(volume_fractions). After that the material id and the the name belongs to it are combined through the std::stringstream epsilon_c, epsilon_c &lt;&lt; epsilonc &lt;&lt; cathode_CL_material_ids[i]. The epsilon_c contains two parts: name and the id. In the second loop, the volume fractions are assigned to the output response correspondingly.The next function in the postprocessing routines is the <a class="el" href="classFuelCell_1_1Application_1_1AppCathode.html#a0612768a6502e2151e37eb41263c65b2">evaluate </a> function. The <code>evaluate</code> function is used when running the optimization problem to evaluate a functional response value. The function has a relatively simple definition where it takes the FEVector which is the solution vector and evaluates the response. </p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">double</span></div>
<div class="line">NAME::AppCathode&lt;dim&gt;::evaluate (<span class="keyword">const</span> <a class="code" href="classFuelCell_1_1ApplicationCore_1_1FEVectors.html">FuelCell::ApplicationCore::FEVectors</a>&amp; src)</div>
<div class="line">{</div>
<div class="line">   std::vector&lt;double&gt; test(this-&gt;n_resp, 0.0);</div>
<div class="line">   this-&gt;responses(test,</div>
<div class="line">                   src);</div>
<div class="line">   <span class="keywordflow">return</span> -test[0];</div>
<div class="line">}</div>
</div><!-- fragment --><br/>
<a class="el" href="classFuelCell_1_1Application_1_1AppCathode.html#a102f9fb3d4963921086bf82200236fd9">data_out </a> function is used to create the .vtk files that will be used to visualise our solution in Paraview. This member fuction takes a string with the name of the output file we would like to create and the FEVectors object with the solution. </p>
<div class="fragment"><div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> </div>
<div class="line">NAME::AppCathode&lt;dim&gt;::data_out(<span class="keyword">const</span> std::string &amp;filename, </div>
<div class="line">                                <span class="keyword">const</span> <a class="code" href="classFuelCell_1_1ApplicationCore_1_1FEVectors.html">FuelCell::ApplicationCore::FEVectors</a> &amp;src)</div>
<div class="line">{             </div>
</div><!-- fragment -->When calling this function, we pass the name of data we want to print out. Once a simulation has run, the code will print out both the grid and the solution .vtk files at each refinement level. In data_out, we are creating the vtk files so we pass the string "fuel_cell_solution_DataFile_00001_Cycle_" plus the cycle number of the adaptive refinement loop. We also pass the <code>FEVectors</code> object that contains the solution and the residual.The following step in the code is to extract the solution vector from the <code>FEVectors</code> object: </p>
<div class="fragment"><div class="line"><span class="comment">// --- Find solution ---</span></div>
<div class="line"><a class="code" href="namespaceFuelCell_1_1ApplicationCore.html#a890c83d37e50f658e28fde74c54d7dc8">FuelCell::ApplicationCore::FEVector</a> solution = src.<a class="code" href="classFuelCell_1_1ApplicationCore_1_1FEVectors.html#a17c8c1358f5626525be497fddf68ae3e">vector</a>( src.<a class="code" href="classFuelCell_1_1ApplicationCore_1_1FEVectors.html#a6b8240a1b6d2a5336e9114388a79eb80">find_vector</a>(<span class="stringliteral">&quot;Solution&quot;</span>) );</div>
</div><!-- fragment -->Next we create a vector of the solution names and then pass it to the data_out function. </p>
<div class="fragment"><div class="line"><span class="comment">// Output solution with its corresponent names:</span></div>
<div class="line">std::vector&lt;std::strings&gt; solution_names;</div>
<div class="line"></div>
<div class="line">solution_names.push_back(<span class="stringliteral">&quot;Oxygen_molar_fraction&quot;</span>);</div>
<div class="line">solution_names.push_back(<span class="stringliteral">&quot;Protonic_electrical_potential&quot;</span>);</div>
<div class="line">solution_names.push_back(<span class="stringliteral">&quot;Electronic_electrical_potential&quot;</span>);</div>
</div><!-- fragment -->Next we clear all the solution names no matter whether it is a scalar or parts of a vector and resize the solution_interpretations with the number of the blocks and make all the solution names to be the scalar. </p>
<div class="fragment"><div class="line"> <span class="comment">// --- Assign solution interpretations ---</span></div>
<div class="line">this-&gt;solution_interpretations.clear();</div>
<div class="line">this-&gt;solution_interpretations.resize(this-&gt;element-&gt;n_blocks(),</div>
<div class="line">                                      DataComponentInterpretation::component_is_scalar);</div>
</div><!-- fragment -->To do further postprocessing, a vector of the type <code>DataPostprocessor&lt;dim&gt;</code> is created to store all the objects from the namespace of <a class="el" href="namespaceFuelCellShop_1_1PostProcessing.html" title="Namespace used for all classes use for post-processing either for evaluating a new quantity at a quad...">FuelCellShop::PostProcessing</a>. The DataPostprocessor is the parent of all the objects in namespace <a class="el" href="namespaceFuelCellShop_1_1PostProcessing.html" title="Namespace used for all classes use for post-processing either for evaluating a new quantity at a quad...">FuelCellShop::PostProcessing</a>. </p>
<div class="fragment"><div class="line"> <span class="comment">// --- Create vector of PostProcessing objects ---</span></div>
<div class="line">std::vector&lt; DataPostprocessor&lt;dim&gt;* &gt; PostProcessing;</div>
</div><!-- fragment --><p> The current density is computed simply by calling the constant function in FuelCellShop::PostProcessing::ORRCurrentDensityDataOut&lt;dim&gt; and passing two arguments, one is the system_management and the other one is the layer for which the current density needs to be computed. </p>
<div class="fragment"><div class="line"><span class="comment">// --- current ---</span></div>
<div class="line"><a class="code" href="classFuelCellShop_1_1PostProcessing_1_1ORRCurrentDensityDataOut.html">FuelCellShop::PostProcessing::ORRCurrentDensityDataOut&lt;dim&gt;</a> current(&amp;this-&gt;system_management, CCL, &amp;OC);</div>
<div class="line">PostProcessing.push_back(&amp;current);</div>
</div><!-- fragment -->Finally, all the objects (filename, solution, solution_names, and PostProcessing) are passed to the function DoFApplication&lt;dim&gt;::data_out to generate .vtk file. If the output option for grid is on then .eps file would be created. The type of the file which would be written out depends on the parameter file. The <code>data_out</code> function which is a member of the <code>DOFApplication</code> and supply the <code>filename</code>,<code>solution</code> vector, <code>solution_names</code> vector and <code>PostProcessing</code> objects as arguments. </p>
<div class="fragment"><div class="line">  <span class="comment">// --- output ---</span></div>
<div class="line">DoFApplication&lt;dim&gt;::data_out( filename,</div>
<div class="line">                               solution,</div>
<div class="line">                               solution_names,</div>
<div class="line">                               PostProcessing);</div>
</div><!-- fragment --><p> This completes the app_cathode application and now we will move onto how to set up the simulations using parameter files. <br/>
 <br/>
 <a class="anchor" id="parameter_file"></a></p>
<h1>The parameter file</h1>
When running a simulation, the FCST code requires two parameter files. The first is the main parameter file mentioned when discussing the different 'levels' in the FCST code. It is used by <a class="el" href="classSimulatorBuilder.html" title="This class is used to output data or to initialize and launch simulations. ">SimulatorBuilder</a> to set up the simulation. It contains key parameters such as the application, solver and solver method, and tells the simulation if we are using Dakota and the name of the file that contains the physical parameters (among other parameters as we will see). The main parameter for the test case developed for app_cathode is given below. Note that these files are located in the examples/cathode/template folder. Please note that these files should not be modified and should only be run in order to test the code. </p>
<div class="fragment"><div class="line"><span class="preprocessor">######################################################################</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#    $Id$</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#  This file is used to simulate a cathode model and to obtain</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#  a polarisation curve. It will call the data_app_cathode_test.prm</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#  file which should produce the results saved in test_results.dat. </span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#  Please do not modify this file, it should only be used to run </span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#  the test case.</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#   Copyright (C) 2011 by Marc Secanell</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">######################################################################</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">subsection Simulator</div>
<div class="line"></div>
<div class="line">  set simulator name = cathode</div>
<div class="line">  set simulator parameter file name = data.prm</div>
<div class="line"> </div>
<div class="line">  set solver name = Newton3pp</div>
<div class="line"></div>
<div class="line">  set Analysis type = Polarization Curve        # Parametric Study  | Polarization Curve</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">  ################################################</span></div>
<div class="line"><span class="preprocessor"></span>  subsection Polarization Curve</div>
<div class="line">    set Initial voltage [V] = 0.94</div>
<div class="line">    set Final voltage [V] = 0.59</div>
<div class="line">    set Increment [V] = 0.0377777778</div>
<div class="line">   set Min. Increment [V] = 0.01</div>
<div class="line">  end  </div>
<div class="line"><span class="preprocessor">  ################################################</span></div>
<div class="line"><span class="preprocessor"></span>  </div>
<div class="line"><span class="preprocessor">  ######################################################################</span></div>
<div class="line"><span class="preprocessor"></span>  subsection Optimization</div>
<div class="line">    set optimization parameter file name = opt.prm</div>
<div class="line">  end</div>
<div class="line"><span class="preprocessor">  ######################################################################</span></div>
<div class="line"><span class="preprocessor"></span> </div>
<div class="line">end</div>
</div><!-- fragment -->As we can see comments in these .prm files are denoted using a # symbol. The structure is the same as was discussed in the <code>declare_parameters</code> function of the application. Note that we are not saying what the solver method is. Currently, only adaptive refinement has been implemented so this has been set as the default value in the <a class="el" href="classSimulationSelector.html" title="This class selects an openFCST application which will run. ">SimulationSelector</a> class. Therefore we do not need to set it in the parameter file. This should always be considered when setting up a simulation, parameters that you do not set will have default values that will be used and there will be no warning if the default is used. <br/>
 <br/>
 Now we can move onto the file containing the bulk of the simulation parameters. The file that will be examined is again for the app_cathode test case. It contains physical data about the fuel cell we wish to model, including dimensions, operating conditions, properties etc. However it also contains information about the grid, the discretisation method, solver information, optimisation and the output. Here, we use the parameter file called "data.prm" from the mentioned folder. </p>
<div class="fragment"><div class="line"><span class="preprocessor">######################################################################</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#   $Id: $</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#  This file is used to simulate an cathode and to obtain</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#  a single point on a polarisation curve. It is based on </span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#  the test case and will be called by the </span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#  main_app_cathode_analysis.prm file. </span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#   Copyright (C) 2011-13 by Marc Secanell</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#</span></div>
<div class="line"><span class="preprocessor">######################################################################</span></div>
</div><!-- fragment --><p> <br/>
 The first section of the input file details the grid generation. We can select the type of geometry we want, e.g. a mesh from file, a cathode or a cathodeMPL. In this case a cathode is used. <br/>
 The Initial refinement states that the initial mesh will be refined twice before the solution starts. Also, Refinement = adaptive states that we will be using adaptive refinement to solve the problem. The properties are specified in a subsequent subsection. <br/>
 The next two parameters specify how to organize the degrees of freedom. We usually select to Sort by component. If the Sort Cuthill-McKee parameter is set to true then we will use the <a href="http://www.dealii.org/7.0.0/doxygen/deal.II/namespaceDoFRenumbering.html">Cuthill-McKee </a> algorithm to arrange the degrees of freedom, leading to a system matrix with non-zero terms more localised around the main diagonal. Instead we are using sort by component which will allow use to use the block matrix format. Note that the refinement parameter has a comment after adaptive. This just details other options that could be used for this parameter, i.e. we could use global instead of adaptive refinement.<div class="fragment"><div class="line">subsection Grid generation</div>
<div class="line"></div>
<div class="line">  set Type of mesh = Cathode  # Cathode | CathodeMPL | GridExternal</div>
<div class="line"></div>
<div class="line">  set Initial refinement = 2</div>
<div class="line">  set Refinement         = adaptive  #global | adaptive</div>
<div class="line">  set Sort Cuthill-McKee = <span class="keyword">false</span></div>
<div class="line">  set Sort by component  = <span class="keyword">true</span></div>
</div><!-- fragment -->When selecting a cathode geometry, we let the OpenFCST mesh generator generate the geometry for us. Therefore, we need to specify the dimension of the cell as well as a number id that specifies the material type and the boundary type. The parameters that need to be specified for use by the internal mesh generator are given in the following section: </p>
<div class="fragment"><div class="line">  subsection Internal mesh generator parameters</div>
<div class="line"><span class="preprocessor">    ####</span></div>
<div class="line"><span class="preprocessor"></span>    subsection Dimensions</div>
<div class="line">       set Cathode current collector width [cm] = 0.1</div>
<div class="line">       set Cathode channel width [cm] = 0.1</div>
<div class="line">       set Cathode CL thickness [cm] =  1.0e-3 #1.18e-3</div>
<div class="line">       set Cathode MPL thickness [cm] =  2.0e-3 #1.18e-3</div>
<div class="line">       set Cathode GDL thickness [cm] = 0.01 #10.0e-2 #</div>
<div class="line">    end</div>
<div class="line"><span class="preprocessor">    ####</span></div>
<div class="line"><span class="preprocessor"></span>    subsection Material ID</div>
<div class="line">       set Cathode GDL = 2</div>
<div class="line">       set Cathode CL = 4</div>
<div class="line">    end</div>
<div class="line"><span class="preprocessor">    ####</span></div>
<div class="line"><span class="preprocessor"></span>    subsection Boundary ID</div>
<div class="line">     set c_CL/Membrane = 1</div>
<div class="line">     set c_BPP/GDL = 2</div>
<div class="line">     set c_Ch/GDL = 3</div>
<div class="line">     set c_GDL/CL = 255</div>
<div class="line">    end</div>
<div class="line"><span class="preprocessor">    ####</span></div>
<div class="line"><span class="preprocessor"></span>  end</div>
<div class="line"><span class="preprocessor">  ####</span></div>
<div class="line"><span class="preprocessor">end</span></div>
</div><!-- fragment -->Note that Material ID and Boundary IDs are used to relate a layer to a domain in the input file as we will show in the layer section. Note that the symmetric boundaries are given a value of 0 while interior boundaries, such as the one here between the CCL and GDL, must be denoted with 255. <br/>
 <br/>
Subsection "Initial solution" is self-explanatory.<div class="fragment"><div class="line">subsection Initial Solution</div>
<div class="line">  set Read in initial solution from file = <span class="keyword">false</span></div>
<div class="line">  set Output initial solution = <span class="keyword">false</span></div>
<div class="line">  set Output solution <span class="keywordflow">for</span> transfer = <span class="keyword">false</span></div>
<div class="line">end</div>
</div><!-- fragment -->Next, we define the parameter for adaptive refinement. Once the grid is created, there will be 4 global refinements (Number of Refinements = 4) before any solvers are called. In general, we will always use adaptive refinement in our simulations rather than global, while the number of refinements is the number of times we adaptively refine our grid, leading to 5 calls to the Newton solver. Make sure you change "Output final solution" to "true" before running the application.<div class="fragment"><div class="line">subsection Adaptive refinement</div>
<div class="line">  set Number of Refinements = 4</div>
<div class="line">  set Output initial mesh = <span class="keyword">false</span></div>
<div class="line">  set Output intermediate solutions = <span class="keyword">false</span></div>
<div class="line">  set Output intermediate responses = <span class="keyword">false</span></div>
<div class="line">  set Output <span class="keyword">final</span> solution = <span class="keyword">false</span></div>
<div class="line">end</div>
</div><!-- fragment -->Next is the information for the Newton solver. Here we set parameters such as the tolerance and the maximum number of steps for each iteration.<div class="fragment"><div class="line">subsection Newton</div>
<div class="line">  set Assemble threshold = 0.0</div>
<div class="line">  set Debug level        = 0</div>
<div class="line">  set Debug residual     = <span class="keyword">false</span></div>
<div class="line">  set Debug solution     = <span class="keyword">false</span></div>
<div class="line">  set Debug update       = <span class="keyword">false</span></div>
<div class="line">  set Max steps          = 100</div>
<div class="line">  set Reduction          = 1.e-20</div>
<div class="line">  set Tolerance          = 1.e-8</div>
<div class="line">end</div>
</div><!-- fragment -->Next, we move to the System management section. Here we specify the name of the solution variables and equations. For the cathode problem we have three unknowns and three equations as specified. </p>
<div class="fragment"><div class="line">subsection System management</div>
<div class="line"></div>
<div class="line"> set Number of solution variables = 3</div>
<div class="line"></div>
<div class="line"> subsection Solution variables</div>
<div class="line">  set Solution variable 1 = <a class="code" href="system__management_8h.html#a905465f7ef35ccf9a9a5fa54e2afd938a4b0cf4d52a8825bdad0e32b865664136">oxygen_molar_fraction</a></div>
<div class="line">  set Solution variable 3 = <a class="code" href="system__management_8h.html#a905465f7ef35ccf9a9a5fa54e2afd938a80fe5fb03110c6b4bc4eba7aae9e20ba">electronic_electrical_potential</a></div>
<div class="line">  set Solution variable 2 = <a class="code" href="system__management_8h.html#a905465f7ef35ccf9a9a5fa54e2afd938a3ea75b563f832072168718e7e30c8b36">protonic_electrical_potential</a></div>
<div class="line"> end</div>
<div class="line"></div>
<div class="line"> subsection Equations</div>
<div class="line">  set Equation 1 = Ficks Transport Equation - oxygen</div>
<div class="line">  set Equation 3 = Electron Transport Equation</div>
<div class="line">  set Equation 2 = Proton Transport Equation</div>
<div class="line"> end</div>
<div class="line"></div>
<div class="line">end</div>
</div><!-- fragment -->Next, we specify the initial solution in the material for each solution variable and sepcify the initial boundary condition for each solution variable at different boundary id. This is necessary since the map of material id to its value is generated through this way. Otherwise, the code will not work.<div class="fragment"><div class="line">subsection Equations</div>
<div class="line"></div>
<div class="line"> subsection Ficks Transport Equation - oxygen</div>
<div class="line"></div>
<div class="line">  subsection Initial data</div>
<div class="line">   set <a class="code" href="system__management_8h.html#a905465f7ef35ccf9a9a5fa54e2afd938a4b0cf4d52a8825bdad0e32b865664136">oxygen_molar_fraction</a> = 2: 1.0, 4: 1.0</div>
<div class="line">  end</div>
<div class="line"></div>
<div class="line">  subsection Boundary data</div>
<div class="line">   set oxygen_molar_fraction = 3: 1.0</div>
<div class="line">  end</div>
<div class="line"></div>
<div class="line">end</div>
<div class="line"></div>
<div class="line">subsection Electron Transport Equation</div>
<div class="line"></div>
<div class="line">  subsection Initial data</div>
<div class="line">   set <a class="code" href="system__management_8h.html#a905465f7ef35ccf9a9a5fa54e2afd938a80fe5fb03110c6b4bc4eba7aae9e20ba">electronic_electrical_potential</a> = 2: 0.7, 4: 0.7</div>
<div class="line">  end</div>
<div class="line"></div>
<div class="line">  subsection Boundary data</div>
<div class="line">   set electronic_electrical_potential = 2: 0.7 # V</div>
<div class="line">  end</div>
<div class="line"></div>
<div class="line"> end</div>
<div class="line"></div>
<div class="line"> subsection Proton Transport Equation</div>
<div class="line"></div>
<div class="line">  subsection Initial data</div>
<div class="line">   set <a class="code" href="system__management_8h.html#a905465f7ef35ccf9a9a5fa54e2afd938a3ea75b563f832072168718e7e30c8b36">protonic_electrical_potential</a> = 2: 0.0, 4: 0.0</div>
<div class="line">  end</div>
<div class="line"></div>
<div class="line">  subsection Boundary data</div>
<div class="line">   set protonic_electrical_potential = 1: 0.0 # V</div>
<div class="line">  end</div>
<div class="line"></div>
<div class="line">end</div>
<div class="line"></div>
<div class="line">end</div>
</div><!-- fragment -->Next we move to the discretisation parameters. In this section we select the type of finite element and the type of quadrature integration. We are using three first order equations, however the commented out parameter part shows another potential option, i.e. a third order element for the first equation and two first order elements. To recap on the how the finite elements are set: In the test case, we are using three first order elements which are defined using: <code>FESystem[FE_Q(1)^3]</code>. If second order elements are required, then we would use: <code>FESystem[FE_Q(2)^3]</code>. To use different elements for an equation, for example, first order for the first equation and second order for the two other two, we would write <code>FESystem[FE_Q(1)]-FESystem[FE_Q(2)^2]</code>. In the matrix and residual subsections we are setting the order of the quadrature points relative to the the degrees of freedom. By setting the value to -1 we are actually saying that the order is one more than that of the degrees of freedom.<div class="fragment"><div class="line">subsection Discretization</div>
<div class="line">  set Element = FESystem[FE_Q(1)^3] #FESystem[FE_Q(3)-FE_Q(1)^2] #FESystem[FE_Q(1)^3] #System of three fe</div>
<div class="line">  subsection Matrix</div>
<div class="line">    set Quadrature cell = -1</div>
<div class="line">    set Quadrature face = -1</div>
<div class="line">  end</div>
<div class="line">  subsection Residual</div>
<div class="line">    set Quadrature cell = -1</div>
<div class="line">    set Quadrature face = -1</div>
<div class="line">  end</div>
<div class="line">end</div>
</div><!-- fragment -->Now we can move onto the physical parameters describing the fuel cell.First, we set the operating conditions for the fuel cell: </p>
<div class="fragment"><div class="line">subsection Operating conditions</div>
<div class="line">   set Adjust initial solution and boundary conditions = <span class="keyword">true</span></div>
<div class="line">   set Temperature cell = 353 #[<a class="code" href="namespaceConstants.html#aa5e92a8c5672b9716adb862563a86d75">K</a>]</div>
<div class="line">   set Cathode pressure = 101265 #[Pa] (1 atm)</div>
<div class="line">   set Cathode relative humidity = 0.6</div>
<div class="line">   set Voltage cell = 0.7 #828 ## Convergence up to 0.66V</div>
<div class="line">end</div>
</div><!-- fragment -->Next we can move onto layer properties. First, let us set up the gas diffusion layer. <br/>
 First, we specify the type of gas diffusion layer we would like to study. There are several types available such as SGL24BA, DummyGDL and DesignFibrousGDL. DesignFibrousGDL uses effective medium theories in order to determine the effective diffusivity, and electrical conductivity of the catalyst layer based on kinetic theory of gases diffusion coefficients for the gas and bulk properties for the fibers respectively. <br/>
 Once the layer type is defined we select the Material id of the layer. Now, the cells in the mesh with id 2 (Cathode gas diffusion layer) as shown in the GridGeneror section, will take the properties of this layer. <br/>
 Finally, we specify the bulk electrical conductivity and the method to obtain effective properties. </p>
<div class="fragment"><div class="line">subsection Fuel cell data</div>
<div class="line"><span class="preprocessor"> ####</span></div>
<div class="line"><span class="preprocessor"></span> subsection Cathode gas diffusion layer</div>
<div class="line"> </div>
<div class="line">   set Gas diffusion layer type = DummyGDL #[ DesignFibrousGDL | DummyGDL | SGL24BA ]</div>
<div class="line">   </div>
<div class="line">   set Material <span class="keywordtype">id</span> = 2</div>
<div class="line"><span class="preprocessor">   ####</span></div>
<div class="line"><span class="preprocessor"></span>   subsection DummyGDL</div>
<div class="line">       set Oxygen diffusion coefficient, [cm^2/s] = 0.22</div>
<div class="line">       set Electrical conductivity, [S/cm] = 40</div>
<div class="line">   end</div>
<div class="line"><span class="preprocessor">   ####   </span></div>
<div class="line"><span class="preprocessor"> end</span></div>
</div><!-- fragment -->Next, we define the catalyst layer properties. Again, we set the material id that corresponds to the layer and select the appropriate layer. A catalyst layer computes all the effective properties but also the current density in the layer. <br/>
 Here we have three options, a DummyCL which would allow the user to set the effective properties directly, a HomogeneousCL and an MultiScaleCL. A homogeneousCL implements a macro-homogeneous model. An MultiScaleCL implements a multi-scale model with an agglomerate model (either analytical or numerical) being solved to predict the current density. </p>
<div class="fragment"><div class="line">subsection Cathode catalyst layer</div>
<div class="line"></div>
<div class="line"> set Material <span class="keywordtype">id</span> = 4</div>
<div class="line"></div>
<div class="line"> set Catalyst layer type = DummyCL   #[ DummyCL | AgglomerateCL | HomogeneousCL ]</div>
</div><!-- fragment -->Once the catalyst layer has been selected, we need to specify the materials that form the layer. In this case, we need to specify the type of catalyst, catalyst support and electrolyte. We select Platinum, Carbon black and Nafion repectively. For each one of the materials, we need to specify its properties since this properties are need to obtain effective transport properties and also to predict the current density in the layer. <br/>
 Note that the platinum section is used to describe its kinetic properties rather than physical properties. The physical properties, such as density, used are the default values in the platinum class. Again it is important to keep this in mind when creating a prm file. Also note that the reference concentration has been modified to include the contribution from Henrys Law. </p>
<div class="fragment"><div class="line">   set Catalyst type = Platinum</div>
<div class="line">   set Catalyst support type = Carbon Black</div>
<div class="line">   set Electrolyte type = Nafion</div>
<div class="line">   </div>
<div class="line">   subsection Materials</div>
<div class="line">     </div>
<div class="line">     subsection Platinum</div>
<div class="line">       set Cathodic transfer coefficient (<a class="code" href="system__management_8h.html#a800da0c8109f6e65327b4de20d4a0c10a51e6b781fcc0468896f60da150026bd5">ORR</a>) = 1 </div>
<div class="line"><span class="preprocessor">       #set Method for kinetics parameters (ORR) = Given</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">       #set Reference exchange current density (ORR) [uA/cm2] = 1.1495E-1        </span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">       #set Reference oxygen concentration (ORR) = 1.2e-6 #(includes henrys) </span></div>
<div class="line"><span class="preprocessor"></span>     end    </div>
<div class="line">     subsection Carbon Black</div>
<div class="line">     </div>
<div class="line">     end</div>
<div class="line">     subsection Nafion</div>
<div class="line">     </div>
<div class="line">     end</div>
<div class="line">   end</div>
<div class="line"><span class="preprocessor">   ##</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">   ##</span></div>
<div class="line"><span class="preprocessor"></span>   subsection DummyCL</div>
<div class="line">     set Oxygen diffusion coefficient, [cm^2/s] = 4:0.0108934499 </div>
<div class="line">     set Electrical conductivity, [S/cm] = 4:12.00845293 </div>
<div class="line">     set Protonic conductivity, [S/cm] = 4:0.00910831814 </div>
<div class="line">     set Active area [cm^2/cm^3] = 4:341183.43125 </div>
<div class="line">   end </div>
<div class="line"><span class="preprocessor">   ##</span></div>
<div class="line"><span class="preprocessor"></span>   </div>
<div class="line"> end</div>
<div class="line">end</div>
</div><!-- fragment -->Once all the layers are specified, we specify if we would like to compute any functionals at post-processing. In this case, we would like to compute the current. </p>
<div class="fragment"><div class="line">subsection Output Variables</div>
<div class="line">  set num_output_vars = 1</div>
<div class="line">  set Output_var_0 = current</div>
<div class="line">end</div>
</div><!-- fragment -->Finally, we need to set the output parameters for the simulation. In this case we only wish to set the format of the output. The data output is set to .vtu, which can be read by Paraview and used to visualise our solution profiles. The grid is outputted in a simple .eps files that can be used to view the grid. However it can't be read by the code and used as a grid in a new simulation. </p>
<div class="fragment"><div class="line">subsection Output</div>
<div class="line"> subsection Data</div>
<div class="line">    set Output format = vtu #tecplot</div>
<div class="line">  end</div>
<div class="line">  subsection Grid</div>
<div class="line">    set Format = eps</div>
<div class="line">  end</div>
<div class="line">end</div>
</div><!-- fragment -->This, along with default values, is enough to describe the fuel cell we wish to model.<a class="anchor" id="Results"></a></p>
<h1>Results</h1>
We can see the results from our simulation in the picture below along with the domain of our simulation. The simulation produces a .vtk file that show the 2D profiles of our three solution variables. We can also produce an image of the source term for each of our equations, i.e. the current production profile. The image shows both the GDL and CCL for the oxygen and electronic potential profiles. However because there is no ionomer and no current production in the GDL, we have cut out the GDL for the protonic potential and source term profiles so as to better visualise the CCL. The CCL is still visible in the oxygen molar fraction profile, on the far left, due to the difference in the oxygen diffusion coefficient between the CCL and the CGDL. Note also that the source term profile is heavily weighted to the upper left. This would indicate a relatively slow transport of protons through the membrane. We can also clearly in the oxygen and solid phase potential profiles where the rib and gas channel are. <br/>
 <br/>
 The software that is normally used to visualise the results is <a href="http://www.paraview.org/">Paraview</a>, an open source data analysis and visualisation package. An introduction and some exercises are available on the ESDL repository, under the manuals section. Also, the following <a href="http://www.math.tamu.edu/~bangerth/videos.676.32.html">lecture</a> by Wolfgang Bangerth and Timo Heister is also very useful.<table  width="40%" align="center">
<tr>
<td align="center"><div class="image">
<img src="tutorial_domain.png" alt="tutorial_domain.png"/>
</div>
   </td></tr>
</table>
<table  width="25%" align="center">
<tr>
<td align="center"><div class="image">
<img src="tutorial_pic.png" alt="tutorial_pic.png"/>
</div>
 <p class="endtd"></p>
</td></tr>
</table>
The application can also be used with Dakota to produce a polarization curve. The necessary files for producing a polarization curve are given in examples/cathode/polarization_curve. Below are the values obtained from a polarization curve study: </p>
<div class="fragment"><div class="line"> Cell voltage [V]       Cathode current [A/cm2] </div>
<div class="line"> 0.94                   0.000660393</div>
<div class="line"> 0.902222               0.00228122</div>
<div class="line"> 0.864444               0.00783672</div>
<div class="line"> 0.826667               0.0264384</div>
<div class="line"> 0.788889               0.0845664</div>
<div class="line"> 0.751111               0.239874</div>
<div class="line"> 0.713333               0.570606</div>
<div class="line"> 0.675556               1.14625</div>
<div class="line">0.637778                2.01858</div>
<div class="line"> 0.6                    3.18371</div>
</div><!-- fragment -->This could then be used to produce a polarisation curve. </p>
<table  width="40%" align="center">
<tr>
<td align="center"><div class="image">
<img src="tutorial_polarization.png" alt="tutorial_polarization.png"/>
</div>
   </td></tr>
</table>
<a class="anchor" id="PlainProg"></a> </p>
<h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">// ----------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// FCST: Fuel Cell Simulation Toolbox</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Copyright (C) 2006-2014 by Energy Systems Design Laboratory, University of Alberta</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// This software is distributed under the MIT License</span></div>
<div class="line"><span class="comment">// For more information, see the README file in /doc/LICENSE</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// - Class: app_cathode.cc</span></div>
<div class="line"><span class="comment">// - Description: This class describes diffusion in fuel cell cathodes</span></div>
<div class="line"><span class="comment">//                Ficks, one gas</span></div>
<div class="line"><span class="comment">// - Developers: Marc Secanell and Valentin N. Zingan, University of Alberta</span></div>
<div class="line"><span class="comment">//               Marc Secanell,      University of Alberta</span></div>
<div class="line"><span class="comment">// - Id: $Id: app_cathode_F1.cc 2616 2014-08-15 22:57:14Z secanell $</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// ----------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="app__cathode_8h.html">app_cathode.h</a>&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>NAME  = FuelCell::Application;</div>
<div class="line"></div>
<div class="line"><span class="comment">// ---              ---</span></div>
<div class="line"><span class="comment">// ---              ---</span></div>
<div class="line"><span class="comment">// --- AppCathode ---</span></div>
<div class="line"><span class="comment">// ---              ---</span></div>
<div class="line"><span class="comment">// ---              ---</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// CONSTRUCTORS, DESTRUCTOR, AND INITIALIZATION //</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">// ---             ---</span></div>
<div class="line"><span class="comment">// --- constructor ---</span></div>
<div class="line"><span class="comment">// ---             ---</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">NAME::AppCathode&lt;dim&gt;::AppCathode( boost::shared_ptr&lt; FuelCell::ApplicationCore::ApplicationData &gt; data )</div>
<div class="line">:</div>
<div class="line">FuelCell::ApplicationCore::OptimizationBlockMatrixApplication&lt;<a class="code" href="fcst__constants_8h.html#a665f17c0bbcd89f2925d9ad4c4b077e5">dim</a>&gt;(data),</div>
<div class="line"></div>
<div class="line">ficks_transport_equation(this-&gt;system_management, &amp;solute, &amp;solvent),</div>
<div class="line">electron_transport_equation(this-&gt;system_management),</div>
<div class="line">proton_transport_equation(this-&gt;system_management),</div>
<div class="line">reaction_source_terms(this-&gt;system_management),</div>
<div class="line">ORRCurrent(this-&gt;system_management)</div>
<div class="line">{</div>
<div class="line">  this-&gt;<a class="code" href="namespaceSolverUtils.html#a1ed2e7ed77e8a9ca065d4d01d3dcd245">repair_diagonal</a> = <span class="keyword">true</span>;</div>
<div class="line">  <a class="code" href="namespaceFcstUtilities.html#a376e9c8bd6845e37de9017cb149582fe">FcstUtilities::log</a> &lt;&lt; <span class="stringliteral">&quot;-&gt;FuelCell::Application::AppCathode-&quot;</span> &lt;&lt; <a class="code" href="fcst__constants_8h.html#a665f17c0bbcd89f2925d9ad4c4b077e5">dim</a> &lt;&lt; <span class="stringliteral">&quot;D&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// ---            ---</span></div>
<div class="line"><span class="comment">// --- destructor ---</span></div>
<div class="line"><span class="comment">// ---            ---</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">NAME::AppCathode&lt;dim&gt;::~AppCathode()</div>
<div class="line">{ }</div>
<div class="line"></div>
<div class="line"><span class="comment">// ---                    ---</span></div>
<div class="line"><span class="comment">// --- declare_parameters ---</span></div>
<div class="line"><span class="comment">// ---                    ---</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">NAME::AppCathode&lt;dim&gt;::declare_parameters(ParameterHandler&amp; param)</div>
<div class="line">{</div>
<div class="line">    OptimizationBlockMatrixApplication&lt;dim&gt;::declare_parameters(param);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Declare parameters in operating conditions:</span></div>
<div class="line">    OC.declare_parameters(param);</div>
<div class="line">      </div>
<div class="line">    <span class="comment">// Declare layer and material classes:</span></div>
<div class="line">    solute.declare_parameters(param);</div>
<div class="line">    solvent.declare_parameters(param);</div>
<div class="line">    </div>
<div class="line">    <a class="code" href="classFuelCellShop_1_1Layer_1_1GasDiffusionLayer.html#a4418fbde577dc2e828c87cc86b32a379">FuelCellShop::Layer::GasDiffusionLayer&lt;dim&gt;::declare_GasDiffusionLayer_parameters</a>(<span class="stringliteral">&quot;Cathode gas diffusion layer&quot;</span>, param);</div>
<div class="line">    <a class="code" href="classFuelCellShop_1_1Layer_1_1MicroPorousLayer.html#a6731d13924ec5fab4dee2f06ad238be4">FuelCellShop::Layer::MicroPorousLayer&lt;dim&gt;::declare_MicroPorousLayer_parameters</a>(<span class="stringliteral">&quot;Cathode microporous layer&quot;</span>, param);</div>
<div class="line">    <a class="code" href="classFuelCellShop_1_1Layer_1_1CatalystLayer.html#acb7baaad36ced3a2fea046bfea1ad7ed">FuelCellShop::Layer::CatalystLayer&lt;dim&gt;::declare_CatalystLayer_parameters</a>(<span class="stringliteral">&quot;Cathode catalyst layer&quot;</span>, param);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Declare equation classes:</span></div>
<div class="line">    ficks_transport_equation.declare_parameters(param);</div>
<div class="line">    electron_transport_equation.declare_parameters(param);</div>
<div class="line">    proton_transport_equation.declare_parameters(param);</div>
<div class="line">    reaction_source_terms.declare_parameters(param);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Declare post-processing routines</span></div>
<div class="line">    ORRCurrent.declare_parameters(param);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Set new default variables for variables and equations in SystemManagement</span></div>
<div class="line">    this-&gt;set_default_parameters_for_application(param);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// ---            ---</span></div>
<div class="line"><span class="comment">// --- initialize ---</span></div>
<div class="line"><span class="comment">// ---            ---</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">NAME::AppCathode&lt;dim&gt;::initialize(ParameterHandler&amp; param)</div>
<div class="line">{   </div>
<div class="line">    <span class="comment">//        </span></div>
<div class="line">    OptimizationBlockMatrixApplication&lt;dim&gt;::initialize(param);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Initialize parameters in operating conditions:</span></div>
<div class="line">    OC.initialize(param);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Initialize materials and layers:</span></div>
<div class="line">    solute.initialize(param);</div>
<div class="line">    solvent.initialize(param);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Initialize gases and material classes:  </span></div>
<div class="line">    std::vector&lt; FuelCellShop::Material::PureGas* &gt; gases;</div>
<div class="line">    gases.push_back(&amp;solute);</div>
<div class="line">    gases.push_back(&amp;solvent);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Initialize layer classes:</span></div>
<div class="line">    CGDL = <a class="code" href="classFuelCellShop_1_1Layer_1_1GasDiffusionLayer.html#a73064f12b7361af73c10bb9cc798c053">FuelCellShop::Layer::GasDiffusionLayer&lt;dim&gt;::create_GasDiffusionLayer</a>(<span class="stringliteral">&quot;Cathode gas diffusion layer&quot;</span>, param);</div>
<div class="line">    CGDL-&gt;set_gases_and_compute(gases, OC.get_pc_atm(), OC.get_T());</div>
<div class="line">    </div>
<div class="line">    CMPL = <a class="code" href="classFuelCellShop_1_1Layer_1_1MicroPorousLayer.html#a1922c3d2b773c2074e04c04c05844889">FuelCellShop::Layer::MicroPorousLayer&lt;dim&gt;::create_MicroPorousLayer</a>(<span class="stringliteral">&quot;Cathode microporous layer&quot;</span>, param);</div>
<div class="line">    CMPL-&gt;set_gases_and_compute(gases, OC.get_pc_atm(), OC.get_T());</div>
<div class="line">    </div>
<div class="line">    CCL  = <a class="code" href="classFuelCellShop_1_1Layer_1_1CatalystLayer.html#aaea6089554e33bbc29c2f5b688a6cb3b">FuelCellShop::Layer::CatalystLayer&lt;dim&gt;::create_CatalystLayer</a>(<span class="stringliteral">&quot;Cathode catalyst layer&quot;</span>, param);</div>
<div class="line">    CCL-&gt;set_gases_and_compute(gases, OC.get_pc_atm(), OC.get_T());</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Initialise the necessary kinetics parameters in CCL.</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="system__management_8h.html#a800da0c8109f6e65327b4de20d4a0c10">ReactionNames</a> name = <a class="code" href="system__management_8h.html#a800da0c8109f6e65327b4de20d4a0c10a51e6b781fcc0468896f60da150026bd5">ORR</a>;</div>
<div class="line">    CCL-&gt;set_reaction_kinetics(name);</div>
<div class="line">    CCL-&gt;set_constant_solution(OC.get_pc_Pa(), <a class="code" href="system__management_8h.html#a905465f7ef35ccf9a9a5fa54e2afd938a55203f2bf9c613ef5d5d6e4307b56003">VariableNames::total_pressure</a>);</div>
<div class="line">    CCL-&gt;set_constant_solution(OC.get_T(), <a class="code" href="system__management_8h.html#a905465f7ef35ccf9a9a5fa54e2afd938a3f92f8366faa0afba7787098cf3b8b87">VariableNames::temperature_of_REV</a>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Setting kinetics in the reaction source terms object.    </span></div>
<div class="line">    reaction_source_terms.set_cathode_kinetics(CCL-&gt;get_kinetics());</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Initialize parameters for physics classes:</span></div>
<div class="line">    ficks_transport_equation.initialize(param);</div>
<div class="line">    electron_transport_equation.initialize(param);</div>
<div class="line">    proton_transport_equation.initialize(param);</div>
<div class="line">    reaction_source_terms.initialize(param);</div>
<div class="line">        </div>
<div class="line">    <span class="comment">// --- second of all we make cell couplings for this problem ---</span></div>
<div class="line">    std::vector&lt;couplings_map&gt; tmp;</div>
<div class="line">    tmp.push_back( ficks_transport_equation.get_internal_cell_couplings()    );</div>
<div class="line">    tmp.push_back( electron_transport_equation.get_internal_cell_couplings() );</div>
<div class="line">    tmp.push_back( proton_transport_equation.get_internal_cell_couplings()   );</div>
<div class="line">    reaction_source_terms.adjust_internal_cell_couplings(tmp);</div>
<div class="line">    this-&gt;system_management.make_cell_couplings(tmp);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Now, initialize object that are used to setup initial solution and boundary conditions:    </span></div>
<div class="line">    this-&gt;component_materialID_value_maps.push_back( ficks_transport_equation.get_component_materialID_value()    );</div>
<div class="line">    this-&gt;component_materialID_value_maps.push_back( electron_transport_equation.get_component_materialID_value() );</div>
<div class="line">    this-&gt;component_materialID_value_maps.push_back( proton_transport_equation.get_component_materialID_value()   );</div>
<div class="line">    OC.adjust_initial_solution(this-&gt;component_materialID_value_maps, this-&gt;mesh_generator);</div>
<div class="line">    </div>
<div class="line">    this-&gt;component_boundaryID_value_maps.push_back( ficks_transport_equation.get_component_boundaryID_value() );</div>
<div class="line">    this-&gt;component_boundaryID_value_maps.push_back( electron_transport_equation.get_component_boundaryID_value() );</div>
<div class="line">    this-&gt;component_boundaryID_value_maps.push_back( proton_transport_equation.get_component_boundaryID_value()   );</div>
<div class="line">    OC.adjust_boundary_conditions(this-&gt;component_boundaryID_value_maps, this-&gt;mesh_generator);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// --- and then allocate memory for vectors and matrices ---</span></div>
<div class="line">    this-&gt;remesh_matrices();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Initialize post-processing routines:</span></div>
<div class="line">    ORRCurrent.initialize(param);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Output options:</span></div>
<div class="line">    <span class="comment">// - system info:</span></div>
<div class="line">    <span class="comment">//this-&gt;system_management.print_system_info();</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// - layers info:</span></div>
<div class="line">    <span class="comment">/*</span></div>
<div class="line"><span class="comment">    CGDL-&gt;print_layer_properties();</span></div>
<div class="line"><span class="comment">    CMPL-&gt;print_layer_properties();</span></div>
<div class="line"><span class="comment">    CCL-&gt;print_layer_properties();</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// - equations info:</span></div>
<div class="line">    <span class="comment">/*</span></div>
<div class="line"><span class="comment">    ficks_transport_equation.print_equation_info();</span></div>
<div class="line"><span class="comment">    electron_transport_equation.print_equation_info();</span></div>
<div class="line"><span class="comment">    proton_transport_equation.print_equation_info();</span></div>
<div class="line"><span class="comment">    reaction_source_terms.print_equation_info();</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// ---               ---</span></div>
<div class="line"><span class="comment">// --- init_solution ---</span></div>
<div class="line"><span class="comment">// ---               ---</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">NAME::AppCathode&lt;dim&gt;::initialize_solution(<a class="code" href="namespaceFuelCell_1_1ApplicationCore.html#a890c83d37e50f658e28fde74c54d7dc8">FuelCell::ApplicationCore::FEVector</a>&amp; initial_guess,</div>
<div class="line">                                           std::shared_ptr&lt;Function&lt;dim&gt; &gt; initial_function)</div>
<div class="line">{</div>
<div class="line">    DoFApplication&lt;dim&gt;::initialize_solution(initial_guess);    </div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// LOCAL CG FEM BASED ASSEMBLERS //</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">// ---             ---</span></div>
<div class="line"><span class="comment">// --- cell_matrix ---</span></div>
<div class="line"><span class="comment">// ---             ---</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">NAME::AppCathode&lt;dim&gt;::cell_matrix(<a class="code" href="namespaceFuelCell_1_1ApplicationCore.html#a8ca0ab5b96a1a26ea639900d7c36ee64">FuelCell::ApplicationCore::MatrixVector</a>&amp;                                 cell_matrices,</div>
<div class="line">                                     <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classFuelCell_1_1ApplicationCore_1_1IntegrationInfo.html">FuelCell::ApplicationCore::DoFApplication&lt;dim&gt;::CellInfo</a>&amp; cell_info)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span>(      CGDL-&gt;belongs_to_material(cell_info.<a class="code" href="classFuelCell_1_1ApplicationCore_1_1DoFInfo.html#a407b06e87ebc7a3260e5b884cbe157c6">cell</a>-&gt;material_id())   )</div>
<div class="line">    {</div>
<div class="line">        ficks_transport_equation.assemble_cell_matrix(cell_matrices, cell_info, CGDL.get());</div>
<div class="line">        electron_transport_equation.assemble_cell_matrix(cell_matrices, cell_info, CGDL.get());</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>( CMPL-&gt;belongs_to_material(cell_info.<a class="code" href="classFuelCell_1_1ApplicationCore_1_1DoFInfo.html#a407b06e87ebc7a3260e5b884cbe157c6">cell</a>-&gt;material_id())   )</div>
<div class="line">    {</div>
<div class="line">        ficks_transport_equation.assemble_cell_matrix(cell_matrices, cell_info, CMPL.get());</div>
<div class="line">        electron_transport_equation.assemble_cell_matrix(cell_matrices, cell_info, CMPL.get());</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>( CCL-&gt;belongs_to_material(cell_info.<a class="code" href="classFuelCell_1_1ApplicationCore_1_1DoFInfo.html#a407b06e87ebc7a3260e5b884cbe157c6">cell</a>-&gt;material_id())    )</div>
<div class="line">    {</div>
<div class="line">        ficks_transport_equation.assemble_cell_matrix(cell_matrices, cell_info, CCL.get());</div>
<div class="line">        electron_transport_equation.assemble_cell_matrix(cell_matrices, cell_info, CCL.get());</div>
<div class="line">        proton_transport_equation.assemble_cell_matrix(cell_matrices, cell_info, CCL.get());</div>
<div class="line">        reaction_source_terms.assemble_cell_matrix(cell_matrices, cell_info, CCL.get());</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="namespaceFcstUtilities.html#a376e9c8bd6845e37de9017cb149582fe">FcstUtilities::log</a>&lt;&lt;<span class="stringliteral">&quot;Material id: &quot;</span>    &lt;&lt;cell_info.<a class="code" href="classFuelCell_1_1ApplicationCore_1_1DoFInfo.html#a407b06e87ebc7a3260e5b884cbe157c6">cell</a>-&gt;material_id()&lt;&lt;<span class="stringliteral">&quot; does not correspond to any layer&quot;</span>&lt;&lt;std::endl;</div>
<div class="line">        Assert( <span class="keyword">false</span> , ExcNotImplemented() );</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// ---               ---</span></div>
<div class="line"><span class="comment">// --- cell_residual ---</span></div>
<div class="line"><span class="comment">// ---               ---</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">NAME::AppCathode&lt;dim&gt;::cell_residual(<a class="code" href="namespaceFuelCell_1_1ApplicationCore.html#a890c83d37e50f658e28fde74c54d7dc8">FuelCell::ApplicationCore::FEVector</a>&amp;                                     cell_res,</div>
<div class="line">                                       <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classFuelCell_1_1ApplicationCore_1_1IntegrationInfo.html">FuelCell::ApplicationCore::DoFApplication&lt;dim&gt;::CellInfo</a>&amp; cell_info)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span>(      CGDL-&gt;belongs_to_material(cell_info.<a class="code" href="classFuelCell_1_1ApplicationCore_1_1DoFInfo.html#a407b06e87ebc7a3260e5b884cbe157c6">cell</a>-&gt;material_id())   )</div>
<div class="line">    {</div>
<div class="line">        ficks_transport_equation.assemble_cell_residual(cell_res, cell_info, CGDL.get());</div>
<div class="line">        electron_transport_equation.assemble_cell_residual(cell_res, cell_info, CGDL.get());</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>( CMPL-&gt;belongs_to_material(cell_info.<a class="code" href="classFuelCell_1_1ApplicationCore_1_1DoFInfo.html#a407b06e87ebc7a3260e5b884cbe157c6">cell</a>-&gt;material_id())   )</div>
<div class="line">    {</div>
<div class="line">        ficks_transport_equation.assemble_cell_residual(cell_res, cell_info, CMPL.get());</div>
<div class="line">        electron_transport_equation.assemble_cell_residual(cell_res, cell_info, CMPL.get());</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>( CCL-&gt;belongs_to_material(cell_info.<a class="code" href="classFuelCell_1_1ApplicationCore_1_1DoFInfo.html#a407b06e87ebc7a3260e5b884cbe157c6">cell</a>-&gt;material_id())    )</div>
<div class="line">    {</div>
<div class="line">        ficks_transport_equation.assemble_cell_residual(cell_res, cell_info, CCL.get());</div>
<div class="line">        electron_transport_equation.assemble_cell_residual(cell_res, cell_info, CCL.get());</div>
<div class="line">        proton_transport_equation.assemble_cell_residual(cell_res, cell_info, CCL.get());</div>
<div class="line">        reaction_source_terms.assemble_cell_residual(cell_res, cell_info, CCL.get());</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="namespaceFcstUtilities.html#a376e9c8bd6845e37de9017cb149582fe">FcstUtilities::log</a>&lt;&lt;<span class="stringliteral">&quot;Material id: &quot;</span>    &lt;&lt;cell_info.<a class="code" href="classFuelCell_1_1ApplicationCore_1_1DoFInfo.html#a407b06e87ebc7a3260e5b884cbe157c6">cell</a>-&gt;material_id()&lt;&lt;<span class="stringliteral">&quot; does not correspond to any layer&quot;</span>&lt;&lt;std::endl;</div>
<div class="line">        Assert( <span class="keyword">false</span> , ExcNotImplemented() );</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">       <span class="comment">// OTHER FUNCTIONS //</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">// ---              ---</span></div>
<div class="line"><span class="comment">// --- dirichlet_bc ---</span></div>
<div class="line"><span class="comment">// ---              ---</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">NAME::AppCathode&lt;dim&gt;::dirichlet_bc(std::map&lt;unsigned int, double&gt;&amp; boundary_values)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <a class="code" href="namespaceFuelCell_1_1InitialAndBoundaryData.html#ae260a077a802e7d58cce69a57d295d1e">FuelCell::InitialAndBoundaryData::make_zero_boundary_values</a>( boundary_values,</div>
<div class="line">                                                              *this-&gt;mapping,</div>
<div class="line">                                                              *this-&gt;dof,</div>
<div class="line">                                                               this-&gt;system_management,</div>
<div class="line">                                                               this-&gt;component_boundaryID_value_maps );</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// POST-PROCESSING //</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">// ---                ---</span></div>
<div class="line"><span class="comment">// --- cell_responses ---</span></div>
<div class="line"><span class="comment">// ---                ---</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">NAME::AppCathode&lt;dim&gt;::cell_responses(std::vector&lt;double&gt;&amp;                                                     dst,</div>
<div class="line">                                        <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classFuelCell_1_1ApplicationCore_1_1IntegrationInfo.html">FuelCell::ApplicationCore::DoFApplication&lt;dim&gt;::CellInfo</a>&amp; cell_info,</div>
<div class="line">                                        <span class="keyword">const</span> <a class="code" href="namespaceFuelCell_1_1ApplicationCore.html#a890c83d37e50f658e28fde74c54d7dc8">FuelCell::ApplicationCore::FEVector</a>&amp; src)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// -- Find out what material is the cell made of, i.e. MEA layer)</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> material_id = cell_info.<a class="code" href="classFuelCell_1_1ApplicationCore_1_1DoFInfo.html#acfde9ad770f2f0e3e99561b0ec8da687">dof_active_cell</a>-&gt;material_id();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Compute ORR responses in the CL</span></div>
<div class="line">    std::map&lt;FuelCellShop::PostProcessing::ResponsesNames, double&gt; ORR_responses;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (CCL-&gt;belongs_to_material(material_id)) <span class="comment">//the material is the catalyst layer</span></div>
<div class="line">    {</div>
<div class="line">        ORRCurrent.compute_responses(cell_info, CCL.get(), ORR_responses);        </div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Organize responses:</span></div>
<div class="line">    <span class="comment">// -- Used to normalize current density (note necessary since it can be done via input file)</span></div>
<div class="line">    std::vector&lt;double&gt; L_cat_vec = this-&gt;mesh_generator-&gt;L_cat_c();</div>
<div class="line">    <span class="keywordtype">double</span> L_cat = std::accumulate(L_cat_vec.begin(),L_cat_vec.end(),0.0);</div>
<div class="line">    <span class="keywordtype">double</span> area_CL = this-&gt;mesh_generator-&gt;L_channel_c()/2.0 + this-&gt;mesh_generator-&gt;L_land_c()/2.0;</div>
<div class="line">    <span class="keywordtype">double</span> volume_CL = (this-&gt;mesh_generator-&gt;L_channel_c()/2.0 + this-&gt;mesh_generator-&gt;L_land_c()/2.0)*L_cat;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> r = 0; r &lt; this-&gt;n_resp; ++r)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> ( (this-&gt;name_responses[r] == <span class="stringliteral">&quot;current&quot;</span> || this-&gt;name_responses[r] == <span class="stringliteral">&quot;cathode_current&quot;</span>) &amp;&amp; CCL-&gt;belongs_to_material(material_id))</div>
<div class="line">            dst[r] += 1*ORR_responses[<a class="code" href="namespaceFuelCellShop_1_1PostProcessing.html#ac0f58decbd183bb22f85f37c4055e297aeb7ec0064eb6022a4d1c3f786e35627d">FuelCellShop::PostProcessing::ResponsesNames::ORR_current</a>]/ area_CL;</div>
<div class="line">            <span class="comment">//(If using response normalization) resp[r] += ORR_responses[FuelCellShop::PostProcessing::ResponsesNames::current];               </span></div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this-&gt;name_responses[r] == <span class="stringliteral">&quot;OH_coverage&quot;</span> &amp;&amp; CCL-&gt;belongs_to_material(material_id))</div>
<div class="line">            dst[r] += (1/volume_CL)*ORR_responses[<a class="code" href="system__management_8h.html#a905465f7ef35ccf9a9a5fa54e2afd938a22d7fe6e70fd02ace65d601ea6d28283">FuelCellShop::PostProcessing::ResponsesNames::OH_coverage</a>];</div>
<div class="line">            <span class="comment">//(If using response normalization) resp[r] += ORR_responses[FuelCellShop::PostProcessing::ResponsesNames::OH_coverage];</span></div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this-&gt;name_responses[r] == <span class="stringliteral">&quot;O_coverage&quot;</span> &amp;&amp; CCL-&gt;belongs_to_material(material_id))</div>
<div class="line">            dst[r] += (1/volume_CL)*ORR_responses[<a class="code" href="system__management_8h.html#a905465f7ef35ccf9a9a5fa54e2afd938ae54137ec0dd8d6afa9c1b8ecc757e67c">FuelCellShop::PostProcessing::ResponsesNames::O_coverage</a>];</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    cell_responses_aux(dst, cell_info, src);</div>
<div class="line">    </div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//-------------------------------------------------------------------</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">NAME::AppCathode&lt;dim&gt;::cell_responses_aux(std::vector&lt;double&gt;&amp;                          dst,</div>
<div class="line">                                            <span class="keyword">const</span> <span class="keyword">typename</span> DoFApplication&lt;dim&gt;::CellInfo&amp; cell_info,</div>
<div class="line">                                            <span class="keyword">const</span> <a class="code" href="namespaceFuelCell_1_1ApplicationCore.html#a890c83d37e50f658e28fde74c54d7dc8">FEVector</a>&amp; src)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// -- Find out what material is the cell made of, i.e. MEA layer)</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> material_id = cell_info.dof_active_cell-&gt;material_id();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Orgaize responses:</span></div>
<div class="line">    <span class="comment">// -- Used to normalize current density (note necessary since it can be done via input file)</span></div>
<div class="line">    std::vector&lt;double&gt; L_cat_vec = this-&gt;mesh_generator-&gt;L_cat_c();</div>
<div class="line">    <span class="keywordtype">double</span> L_cat = std::accumulate(L_cat_vec.begin(),L_cat_vec.end(),0.0);</div>
<div class="line">    <span class="keywordtype">double</span> volume_CL = (this-&gt;mesh_generator-&gt;L_channel_c()/2.0 + this-&gt;mesh_generator-&gt;L_land_c()/2.0)*L_cat;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> r = 0; r &lt; this-&gt;n_resp; ++r)</div>
<div class="line">    {</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (this-&gt;name_responses[r] == <span class="stringliteral">&quot;high_total_coverage&quot;</span> &amp;&amp; CCL-&gt;belongs_to_material(material_id))</div>
<div class="line">        {    </div>
<div class="line">            <span class="comment">// Creating solution variable vector to passed to catalyst layer classes</span></div>
<div class="line">            <span class="comment">// Storing solution indices</span></div>
<div class="line">            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> solution_cell = cell_info.global_data-&gt;find_vector(<span class="stringliteral">&quot;Solution&quot;</span>);</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xO2_index = this-&gt;system_management.solution_name_to_index(<span class="stringliteral">&quot;oxygen_molar_fraction&quot;</span>);</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> phiM_index = this-&gt;system_management.solution_name_to_index(<span class="stringliteral">&quot;protonic_electrical_potential&quot;</span>);</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> phiS_index = this-&gt;system_management.solution_name_to_index(<span class="stringliteral">&quot;electronic_electrical_potential&quot;</span>);</div>
<div class="line">            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fetype_index = this-&gt;system_management.block_info-&gt;base_element[xO2_index];</div>
<div class="line">            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points_cell = (cell_info.fe(fetype_index)).n_quadrature_points;</div>
<div class="line">            </div>
<div class="line">            std::vector&lt; FuelCellShop::SolutionVariable &gt; solution_variables;</div>
<div class="line">            solution_variables.push_back( <a class="code" href="structFuelCellShop_1_1SolutionVariable.html">FuelCellShop::SolutionVariable</a>(&amp;cell_info.values[solution_cell][xO2_index], oxygen_molar_fraction) );</div>
<div class="line">            std::vector&lt;double&gt; temp_phiM(n_q_points_cell, 0.0);</div>
<div class="line">            solution_variables.push_back( <a class="code" href="structFuelCellShop_1_1SolutionVariable.html">FuelCellShop::SolutionVariable</a>(temp_phiM, protonic_electrical_potential) );</div>
<div class="line">            std::vector&lt;double&gt; temp_phiS(n_q_points_cell, 0.85);</div>
<div class="line">            solution_variables.push_back( <a class="code" href="structFuelCellShop_1_1SolutionVariable.html">FuelCellShop::SolutionVariable</a>(temp_phiS, electronic_electrical_potential) );</div>
<div class="line">            </div>
<div class="line">            std::map&lt;FuelCellShop::PostProcessing::ResponsesNames, double&gt; ORR_responses_temp;</div>
<div class="line">            ORRCurrent.compute_responses(solution_variables, cell_info, CCL.get(), ORR_responses_temp);  </div>
<div class="line">            dst[r] += (1/volume_CL)*(ORR_responses_temp[<a class="code" href="system__management_8h.html#a905465f7ef35ccf9a9a5fa54e2afd938a22d7fe6e70fd02ace65d601ea6d28283">FuelCellShop::PostProcessing::ResponsesNames::OH_coverage</a>]+ORR_responses_temp[<a class="code" href="system__management_8h.html#a905465f7ef35ccf9a9a5fa54e2afd938ae54137ec0dd8d6afa9c1b8ecc757e67c">FuelCellShop::PostProcessing::ResponsesNames::O_coverage</a>]);</div>
<div class="line">            </div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this-&gt;name_responses[r] == <span class="stringliteral">&quot;low_total_coverage&quot;</span> &amp;&amp; CCL-&gt;belongs_to_material(material_id))</div>
<div class="line">        {      </div>
<div class="line">            <span class="comment">// Creating solution variable vector to passed to catalyst layer classes</span></div>
<div class="line">            <span class="comment">// Storing solution indices</span></div>
<div class="line">            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> solution_cell = cell_info.global_data-&gt;find_vector(<span class="stringliteral">&quot;Solution&quot;</span>);</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xO2_index = this-&gt;system_management.solution_name_to_index(<span class="stringliteral">&quot;oxygen_molar_fraction&quot;</span>);</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> phiM_index = this-&gt;system_management.solution_name_to_index(<span class="stringliteral">&quot;protonic_electrical_potential&quot;</span>);</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> phiS_index = this-&gt;system_management.solution_name_to_index(<span class="stringliteral">&quot;electronic_electrical_potential&quot;</span>);</div>
<div class="line">            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fetype_index = this-&gt;system_management.block_info-&gt;base_element[xO2_index];</div>
<div class="line">            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points_cell = (cell_info.fe(fetype_index)).n_quadrature_points;</div>
<div class="line">            std::vector&lt; FuelCellShop::SolutionVariable &gt; solution_variables;</div>
<div class="line">            solution_variables.push_back( <a class="code" href="structFuelCellShop_1_1SolutionVariable.html">FuelCellShop::SolutionVariable</a>(&amp;cell_info.values[solution_cell][xO2_index], oxygen_molar_fraction) );</div>
<div class="line">            std::vector&lt;double&gt; temp_phiM(n_q_points_cell, 0.0);</div>
<div class="line">            solution_variables.push_back( <a class="code" href="structFuelCellShop_1_1SolutionVariable.html">FuelCellShop::SolutionVariable</a>(temp_phiM, protonic_electrical_potential) );</div>
<div class="line">            std::vector&lt;double&gt; temp_phiS(n_q_points_cell, 0.4);</div>
<div class="line">            solution_variables.push_back( <a class="code" href="structFuelCellShop_1_1SolutionVariable.html">FuelCellShop::SolutionVariable</a>(temp_phiS, electronic_electrical_potential) );</div>
<div class="line">            </div>
<div class="line">            std::map&lt;FuelCellShop::PostProcessing::ResponsesNames, double&gt; ORR_responses_temp;</div>
<div class="line">            ORRCurrent.compute_responses(solution_variables, cell_info, CCL.get(), ORR_responses_temp);  </div>
<div class="line">            dst[r] += (1/volume_CL)*(ORR_responses_temp[<a class="code" href="system__management_8h.html#a905465f7ef35ccf9a9a5fa54e2afd938a22d7fe6e70fd02ace65d601ea6d28283">FuelCellShop::PostProcessing::ResponsesNames::OH_coverage</a>]+ORR_responses_temp[<a class="code" href="system__management_8h.html#a905465f7ef35ccf9a9a5fa54e2afd938ae54137ec0dd8d6afa9c1b8ecc757e67c">FuelCellShop::PostProcessing::ResponsesNames::O_coverage</a>]);</div>
<div class="line">            </div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// ---          ---</span></div>
<div class="line"><span class="comment">// --- evaluate ---</span></div>
<div class="line"><span class="comment">// ---          ---</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">NAME::AppCathode&lt;dim&gt;::global_responses(std::vector&lt;double&gt;&amp; resp,</div>
<div class="line">                                          <span class="keyword">const</span> <a class="code" href="namespaceFuelCell_1_1ApplicationCore.html#a890c83d37e50f658e28fde74c54d7dc8">FuelCell::ApplicationCore::FEVector</a>&amp; <span class="comment">/*src*/</span>)</div>
<div class="line">{</div>
<div class="line">    </div>
<div class="line">    std::vector&lt;unsigned int&gt; cathode_CL_material_ids;</div>
<div class="line">    std::map&lt;std::string, double&gt; volume_fractions;</div>
<div class="line">    cathode_CL_material_ids = CCL-&gt;get_material_ids();</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; cathode_CL_material_ids.size(); ++i)</div>
<div class="line">    {</div>
<div class="line">        </div>
<div class="line">        CCL-&gt;set_local_material_id(cathode_CL_material_ids[i]);</div>
<div class="line">        CCL-&gt;get_volume_fractions(volume_fractions);</div>
<div class="line">        std::string epsilonc = <span class="stringliteral">&quot;epsilon_V_cat_c:&quot;</span>;</div>
<div class="line">        std::stringstream epsilon_c;</div>
<div class="line">        epsilon_c &lt;&lt; epsilonc &lt;&lt; cathode_CL_material_ids[i];</div>
<div class="line">        </div>
<div class="line">        std::string epsilons = <span class="stringliteral">&quot;epsilon_S_cat_c:&quot;</span>;</div>
<div class="line">        std::stringstream epsilon_s;</div>
<div class="line">        epsilon_s &lt;&lt; epsilons &lt;&lt; cathode_CL_material_ids[i];</div>
<div class="line">        </div>
<div class="line">        std::string epsilonn = <span class="stringliteral">&quot;epsilon_N_cat_c:&quot;</span>;</div>
<div class="line">        std::stringstream epsilon_n;</div>
<div class="line">        epsilon_n &lt;&lt; epsilonn &lt;&lt; cathode_CL_material_ids[i];</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> r = 0; r &lt; this-&gt;n_resp; ++r)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (this-&gt;name_responses[r].compare(epsilon_c.str()) == 0) {</div>
<div class="line">                resp[r] = volume_fractions.find(<span class="stringliteral">&quot;Void&quot;</span>)-&gt;second;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this-&gt;name_responses[r].compare(epsilon_s.str()) == 0) {</div>
<div class="line">                resp[r] = volume_fractions.find(<span class="stringliteral">&quot;Solid&quot;</span>)-&gt;second;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this-&gt;name_responses[r].compare(epsilon_n.str()) == 0) {</div>
<div class="line">                resp[r] = volume_fractions.find(<span class="stringliteral">&quot;Ionomer&quot;</span>)-&gt;second;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// ---          ---</span></div>
<div class="line"><span class="comment">// --- evaluate ---</span></div>
<div class="line"><span class="comment">// ---          ---</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">double</span></div>
<div class="line">NAME::AppCathode&lt;dim&gt;::evaluate (<span class="keyword">const</span> <a class="code" href="classFuelCell_1_1ApplicationCore_1_1FEVectors.html">FuelCell::ApplicationCore::FEVectors</a>&amp; src)</div>
<div class="line">{</div>
<div class="line">    std::vector&lt;double&gt; test(this-&gt;n_resp, 0.0);</div>
<div class="line">    this-&gt;responses(test,</div>
<div class="line">                    src);</div>
<div class="line">    <span class="keywordflow">return</span> -test[0];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// ---          ---</span></div>
<div class="line"><span class="comment">// --- data_out ---</span></div>
<div class="line"><span class="comment">// ---          ---</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">NAME::AppCathode&lt;dim&gt;::data_out(<span class="keyword">const</span> std::string&amp; filename,</div>
<div class="line">                                  <span class="keyword">const</span> <a class="code" href="classFuelCell_1_1ApplicationCore_1_1FEVectors.html">FuelCell::ApplicationCore::FEVectors</a>&amp; src)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// SOLUTION //</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line">  <span class="comment">// --- Find solution ---</span></div>
<div class="line">  <a class="code" href="namespaceFuelCell_1_1ApplicationCore.html#a890c83d37e50f658e28fde74c54d7dc8">FuelCell::ApplicationCore::FEVector</a> solution = src.<a class="code" href="classFuelCell_1_1ApplicationCore_1_1FEVectors.html#a17c8c1358f5626525be497fddf68ae3e">vector</a>( src.<a class="code" href="classFuelCell_1_1ApplicationCore_1_1FEVectors.html#a6b8240a1b6d2a5336e9114388a79eb80">find_vector</a>(<span class="stringliteral">&quot;Solution&quot;</span>) );</div>
<div class="line"></div>
<div class="line">  <span class="comment">// --- Assign solution names ---</span></div>
<div class="line">  std::vector&lt;std::string&gt; solution_names;</div>
<div class="line"></div>
<div class="line">  solution_names.push_back(<span class="stringliteral">&quot;oxygen_molar_fraction&quot;</span>);</div>
<div class="line">  solution_names.push_back(<span class="stringliteral">&quot;protonic_electrical_potential&quot;</span>);</div>
<div class="line">  solution_names.push_back(<span class="stringliteral">&quot;electronic_electrical_potential&quot;</span>);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// --- Assign solution interpretations ---</span></div>
<div class="line">  this-&gt;solution_interpretations.clear();</div>
<div class="line">  this-&gt;solution_interpretations.resize(this-&gt;element-&gt;n_blocks(),</div>
<div class="line">                                        DataComponentInterpretation::component_is_scalar);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Do further POST-PROCESSING    //</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line">  <span class="comment">// --- Create vector of PostProcessing objects ---</span></div>
<div class="line">  std::vector&lt; DataPostprocessor&lt;dim&gt;* &gt; PostProcessing;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// --- current ---</span></div>
<div class="line">  <a class="code" href="classFuelCellShop_1_1PostProcessing_1_1ORRCurrentDensityDataOut.html">FuelCellShop::PostProcessing::ORRCurrentDensityDataOut&lt;dim&gt;</a> current(&amp;this-&gt;system_management, CCL, &amp;OC);</div>
<div class="line">  PostProcessing.push_back(&amp;current);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// --- output ---</span></div>
<div class="line">  DoFApplication&lt;dim&gt;::data_out( filename,</div>
<div class="line">                                 solution,</div>
<div class="line">                                 solution_names,</div>
<div class="line">                                 PostProcessing);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// EXPLICIT INSTANTIATIONS //</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">// ---              ---</span></div>
<div class="line"><span class="comment">// --- AppCathode ---</span></div>
<div class="line"><span class="comment">// ---              ---</span></div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span>NAME::AppCathode&lt;deal_II_dimension&gt;;</div>
</div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Apr 6 2015 21:51:04 for OpenFCST: The open-source Fuel Cell Simulation Toolbox by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
