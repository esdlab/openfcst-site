<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenFCST: The open-source Fuel Cell Simulation Toolbox: AppCathode Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://www.mathjax.org/mathjax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenFCST: The open-source Fuel Cell Simulation Toolbox
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">AppCathode Tutorial</div>  </div>
<div class="ingroups"><a class="el" href="group__Tutorials.html">The Tutorials Page</a></div></div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for AppCathode Tutorial:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__app__cathode.jpg" border="0" alt="" usemap="#group____app____cathode"/>
<map name="group____app____cathode" id="group____app____cathode">
<area shape="rect" id="node1" href="group__Tutorials.html" title="This page will list all the tutorials that have developed for FCST." alt="" coords="5,5,147,32"/></map>
</td></tr></table></center>
</div>
<div class="textblock"> 
 <table class="tutorial" width="50%" border="1">
 <tr><h1>Table of contents</h1></tr>
 <tr>
  <ul>
    <li> <a href="#Introduction" class=bold>Introduction</a></li>
    <li> <a href="#CommProg" class=bold>The commented program</a></li>
    <ul>
       <li><a href="#Includefiles">Include files</a></li>
       <ul>
        <li><a href="#dealii">deal.II</a></li>
        <li><a href="#appframe">Appframe</a></li>
        <li><a href="#FCST">FCST</a></li>
        <li><a href="#memberfunctiondeclaration">Member function declarations</a></li>
        <li><a href="#membervariables">Member variables</a></li>
       </ul>
       <li><a href="#mainapplication">The Main Application</a></li>
       <ul>
          <li><a href="#memberfunctions">The Member Functions</a></li>
       </ul>
     </ul>
     <li value="3"> <a href="#parameter_file" class=bold>The parameter file</a></li>
     <li> <a href="#Results" class=bold>Results</a></li>
     <li> <a href="#PlainProg" class=bold>The plain program</a></li>
  </ul>
 </tr> 
 </table>
 
 <dl class="section author"><dt>Authors</dt><dd>The tutorial was developed by Michael Moore and Marc Secanell and later updated by Madhur Bhaiya and P. Mangal</dd></dl>
<p><a class="anchor" id="Introduction"></a></p>
<h1>Introduction</h1>
This tutorial describes how to develop an application using openFCST. The basic building blocks for creating a fuel cell mathematical model in openFCST are explained using AppCathode application as the template. <br/>
AppCathode class implements the polymer electrolyte fuel cell cathode mathematical model proposed in the following publication:  
 <ul>
    <li> M. Secanell et al. "Numerical Optimization of Proton Exchange Membrane Fuel Cell Cathode Electrodes", 
 Electrochimica Acta, 52(7):2668-2682, February 2007. </li>
 </ul>
  The data files used to reproduce the results from the publication can be found in folder: /data/cathode//Secanell_EA07_Numerical_Optimization_PEMFC_Cathode_Electrodes. There are several subfolders for analysis, parameteric studies and design cases. <br/>
 <br/>
 The mathematical model implemented is steady-state, isobaric and isothermal. Oxygen transport is assumed to be diffusion dominated and therefore is represented using Ficks Law. Electronic and protonic transport are governed by Ohms Law. The electrochemical reactions are modelled using Tafel kinetics. Gas diffusion layer and catalyst layer are considered isotropic. <br/>
 <br/>
 The computational domain is shown in red in the figure below. Due to symmetry of the cell in the vertical direction, the computational domain is reduced to the smaller area encompassed by the red lines by imposing symmetry boundary conditions on the top and bottom boundaries. </p>
<table  width="20%" align="center">
<tr>
<td align="center"><div class="image">
<img src="tutorial_pic_cell.png" alt="tutorial_pic_cell.png"/>
</div>
   </td></tr>
</table>
<p><br/>
 <br/>
 The governing equations of the model are written as follows: </p>
<p class="formulaDsp">
\[ R_1(\vec{u}) = \nabla \cdot (c_{total}D^{eff}_{O_2} \nabla x_{O_2} ) = \frac{1}{nF}\nabla\cdot i \]
</p>
 <p class="formulaDsp">
\[ R_2(\vec{u}) = \nabla \cdot (\sigma^{eff}_{m}\nabla\phi_m) = \nabla \cdot i \]
</p>
 <p class="formulaDsp">
\[ R_3(\vec{u}) = \nabla \cdot (\sigma^{eff}_{s}\nabla\phi_s) = -\nabla \cdot i \]
</p>
<p> where, for the case of a macro-homogeneous catalyst layer, </p>
<p class="formulaDsp">
\[ \nabla \cdot i = A_v i^{ref}_0 \left( \frac{c_{O_2}} {c^{ref}_{O_2}} \right) \mbox{exp} \left( \frac{-\alpha F}{RT}(\phi_s - \phi_m - E_{th}) \right) \]
</p>
<p> The solution variables are the protonic potential, \(\phi_m\), the electronic potential, \(\phi_s\) and, the oxygen molar fraction \(x_{O_2}\). Note that the source terms due to current production are only in the catalyst layer, while they are zero in the gas diffusion layer. <br/>
 <br/>
 The boundary conditions are given by the picture below: </p>
<table  width="20%" align="center">
<tr>
<td align="center"><div class="image">
<img src="tutorial_pic_bc.png" alt="tutorial_pic_bc.png"/>
</div>
   </td></tr>
</table>
<p><br/>
 <br/>
 Note that the membrane potential is set to zero at the CCL/membrane interface and that we control the voltage across the cell using the solid phase potential. <br/>
 <br/>
The govering equations above are nonlinear. Therefore, a nonlinear solver needs to be used to solve this problem. In OpenFCST, we solve the system of equations using a nonlinear Newton solver. Several nonlinear solvers are provided within the OpenFCST framework and therefore, we do not need to worry about them. You can specify the most appropriate nonlinear solver in the main_app_cathode_analysis.prm file, as follows: </p>
<div class="fragment"><div class="line"><span class="keyword">set</span> solver name = Newton3ppC   # Linear | NewtonBasic | Newton3ppC | Newton3pp | NewtonLineSearch</div>
</div><!-- fragment --><p> <br/>
 When solving a nonlinear problem using a Newton method, an initial solution is needed. In OpenFCST we choose to solve the problem first in a very coarse mesh and then, refine the mesh using a posteriori error estimators. The simulations are intially solved on a relatively coarse grid and it is successively refined after the non-linear system is solved using adaptive refinement. This involves refining the mesh in the areas with the largest error in one of the solution variables between iterations. The routine <a class="el" href="classFuelCell_1_1Application_1_1AppCathode.html#a1a515a02a50aac048186be46ebc2e431">estimate </a> is used to implement the error estimator for each cell in the domain, for this application. An error estimator developed by Kelly et al. is used to choose the cells needing refinement. The number of refinement leves is defined in the parameter file. <br/>
 <br/>
AppCathode and all other applications which you shall develop would need to implemet the linearized form of the govering equations for your problem at the element level. Further routines have already been implemented to loop over the cells in the finite element domain and create the global stiffness matrix and right hand side. The local matrix and right hand side assembly will be implemented in your application in member functions <a class="el" href="classFuelCell_1_1Application_1_1AppCathode.html#ab512dff1fe18f13513cef0207bdcbdb7">cell_matrix </a> and <a class="el" href="classFuelCell_1_1Application_1_1AppCathode.html#ac8843b8c92db8fb767a76d0958cd94c6">cell_residual </a>. The global assembly will take place in <a class="el" href="classAppFrame_1_1BlockMatrixApplication.html#a70393cd173480f29244d5f8bb0434eb4">assemble </a> and <a class="el" href="classAppFrame_1_1DoFApplication.html#aaf5840d15412f88091b290fc73a26b43">residual </a> functions in <a class="el" href="classAppFrame_1_1BlockMatrixApplication.html" title="Application handling matrices and assembling linear systems of equations.">AppFrame::BlockMatrixApplication</a> which is the parent of all applications in OpenFCST. Based on the above explanation, there are several "levels" within each simulation. <br/>
 <br/>
 The highest level is the <a class="el" href="classAppFrame_1_1AdaptiveRefinement.html">adaptive refinement </a> loop, which will call the Newton solver to solve the non-linear application and then refine the mesh according to the Kelly Error Estimator (provided by <a href="http://www.dealii.org" target="_blank">deal.II</a>). Again the number of refinement loops is chosen by the user. <br/>
 <br/>
The call to the adaptive refinement is made in the <a class="el" href="classSimulatorBuilder.html">simulator builder </a> class. This class is used to set up the simulation at a very high level. It is used to chose a number of key variables which are specified in the main parameter file: the application, solver (there are three Newton solvers with a different line search method) and the solver method (only adaptive refinement is currently implemented). The simulator builder will also define whether we wish to use Dakota to run an optimisation case or parametric study and is where the parameter file with the fuel cell properties, solver properties is selected. Note that to chose the application, solver and solver method, the simulator builder will call the <a class="el" href="classSimulationSelector.html">simulator selector </a> class. This class will read the main parameter file and will compare the inputs to a list. If a new application or solver is implemented, it will have to be added to this list. Finally, the call to the simulator builder class is made from the main file. <br/>
 <br/>
The next level is a nonlinear application solver which is implemented in the <a class="el" href="classAppFrame_1_1newtonBase.html">Newton </a> solver classes in FCST. The structure on which these classes are based is contained within <a class="el" href="namespaceAppFrame.html" title="Functions and classes of the application framework.">AppFrame</a> through the <a class="el" href="classAppFrame_1_1ApplicationCopy.html">ApplicationCopy </a> class. This will ask the application to solve the linear system, will update the solution according to the chosen line search and repeat until the residual meets the chosen tolerance. <br/>
 <br/>
At the lowest level is the system of linearized equations. AppCathode and all other applications are responsible for creating this system of linearized equations and solving it. The Newton solver uses this information to solve the nonlinear problem. The linearization of the governing equations above is given by </p>
<p class="formulaDsp">
\[ -\frac{\partial R_i(\vec{u}^{n-1})}{\partial u_j} (-\delta \vec{u}_j) = -R_i(\vec{u}^{n-1}) \]
</p>
<p> where \( n \) is the Newton step. The equations are discretised using finite elements and solved using the Galerkin formulation. The solution is updated and the system is solved again until the desired residual is achieved. This is represented graphically below: </p>
<table  width="20%" align="center">
<tr>
<td align="center"><div class="image">
<img src="tutorial_pic_newton.png" alt="tutorial_pic_newton.png"/>
</div>
   </td></tr>
</table>
<p><br/>
 <br/>
The task of the AppCathode is to create the linearized system of equations above, discretise it and solve it. AppCathode inherits from <a class="el" href="classAppFrame_1_1BlockMatrixApplication.html" title="Application handling matrices and assembling linear systems of equations.">AppFrame::BlockMatrixApplication</a>. The latter implements a loop over all elements of the computational domain. Therefore, only the local (element level) assembly of the weak form of the governing equations is required. The global system is obtained using routines already implemented. A system matrix is assembled and then it is solved. The equations are stored in OpenFCST, which therefore provides the coefficients for the matrix and RHS. <a class="el" href="namespaceAppFrame.html" title="Functions and classes of the application framework.">AppFrame</a> provides the data structure for the application (through the BlocMatrixApplication and <a class="el" href="classDoFApplication.html">DoFApplication</a> classes) and the functions to do the assembly. deal.II provides the information about the mesh, the nodes and the finite elements, as well as the solvers for the linear system. <br/>
 <br/>
In summary, creating and running a simulation in OpenFCST will consist of creating an application that uses various FCST classes to build a system of local (element level) linear equations that characterizes the fuel cell and solve the global system. These equations are then used by our already implemented routines to assemble the global system (for the whole mesh) and solve the nonlinear problem using a Newton solver. Finally, to increase accuracy the problem is solved in different mesh refinements. <br/>
 <br/>
 The loops are represented graphically in the figure below: </p>
<table  width="20%" align="center">
<tr>
<td align="center"><div class="image">
<img src="tutorial_fcst_loops.png" alt="tutorial_fcst_loops.png"/>
</div>
   </td></tr>
</table>
The linear application contained in the application classes of FCST is represented by the green box, while the Newton solver loop is the blue box. Finally the red represents the adaptive refinement loop. Note that in the flow chart above, the optimisation package implemented in Dakota is not included as it is beyond the scope of this tutorial. <br/>
 <br/>
To use the FCST code to create new simulations, the user should only need to create a new linear application. The code is built so that the user should not need to know the deal.II or Appframe libraries in depth, indeed knowledge of the implementation of the Newton solver or the adaptive refinement (both of which are implemented in FCST) is not crucial. A new simulation can be created and run by simply creating a new application so with this in mind the tutorial will start with the header file of an example application, AppCathode, and will explain at a basic level all the components that are required to build the application by examining each line of code in sequence. Then the source file will be examined and provide more depth to the explanation given in the header file. <br/>
 <br/>
The simulations are defined using parameter files, simple text files with a .prm file extension that can be read by the FCST code (Note that some parameters can be defined using default values in the code itself, in the <a class="el" href="classFuelCell_1_1Application_1_1AppCathode.html#abc68107ed26f068aea929041f7272901">declare_parameters </a> function). <br/>
 <br/>
 In order to run the simulation, do the following:  
 <ul>
  <li> Go to folder /data/cathode//Secanell_EA07_Numerical_Optimization_PEMFC_Cathode_Electrodes/analysis </li>
  <li> In the command terminal type:  $../../../../bin/fuel_cell-2d.bin main_app_cathode_analysis.prm </li>
 </ul>
  The program will run and return the appropriate results. The main and data parameter files will be explained in the following subsections.The application can be used to solve a cathode with and without an MPL by changing the parameters in the data_app_cathode_parametric.prm file. <br/>
 The model can also be used to solve an agglomerate catalyst layer model. The governing equations are similar to the ones outlined above, however, the volumetric current density source, i.e. \( \nabla \cdot i \) is obtained as specified in the following article: </p>
<ul>
<li>
M. Secanell, K. Karan, A. Suleman and N. Djilali, "Multi-Variable Optimization of PEMFC Cathodes using 
 an Agglomerate Model ", Electrochimica Acta, 52(22):6318-6337, 2007. </li>
</ul>
<p>How to modify the parameter file to solve these additional cases will be explain in section <a href="#parameter_file" class="bold">The parameter file</a> <br/>
 <br/>
A number of different libraries are involved in the simulation, first being the <a href="http://www.dealii.org">deal.II libraries</a>. These libraries provide the finite elements and linear solvers required to solve the problem. Next are the <a class="el" href="namespaceAppFrame.html" title="Functions and classes of the application framework.">AppFrame</a> libraries that actually assemble the system of equations and form the basis of the applications that are created in FCST. Finally, the <a href="http://dakota.sandia.gov/index.html">Dakota libraries</a> are used to run optimisation studies and parametric studies. <br/>
 <br/>
<a class="anchor" id="CommProg"></a> </p>
<h1>The commented program</h1>
<a class="anchor" id="Includefiles"></a> </p>
<h2>The include file</h2>
Here, we will step through the include file, <a class="el" href="app__cathode_8h.html">app_cathode.h</a>, and explain each line of code.The first step is to set the compiler flag that defines this file as the app_cathode class </p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef _FUELCELL__APP_CATHODE__H</span></div>
<div class="line"><span class="preprocessor">#define _FUELCELL__APP_CATHODE__H</span></div>
</div><!-- fragment -->Next we include all the necessary header files, starting with the general C++ libraries.The first classes to be defined are standard C++ libraries that are used to output data to the screen. </p>
<div class="fragment"><div class="line"><span class="comment">//Include STL</span></div>
<div class="line"><span class="preprocessor">#include &quot;fstream&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;iostream&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;sstream&quot;</span></div>
</div><!-- fragment -->Next are the libraries that form the very core of the simulation, the deal.II libraries. Then the appframe libraries, which are the basis of the applications used in the FCST code. Finally, we will look at the fuel cell specific FCST libraries.<a class="anchor" id="dealii"></a> </p>
<h3>deal.II</h3>
The first four are basic components of the FCST code that will be present in all the applications. The parameter_handler class is used to read in the prm files that contain the necessary information to encapsulate a fuel cell simulation. </p>
<div class="fragment"><div class="line"><span class="comment">// Include deal.II classes</span></div>
<div class="line"><span class="preprocessor">#include &quot;base/parameter_handler.h&quot;</span></div>
</div><!-- fragment -->The function classes are used to create an interface that passes the initial solution to the finite element solver in deal.II. An function object is passed to a deal.II function, VectorTools::interpolate, that will call a <a class="el" href="">vector_value </a> function from FCST to return the initial solution for the simulation.<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;base/function_lib.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;base/function.h&quot;</span></div>
</div><!-- fragment -->The quadrature class is used for defining and using <a href="http://www.dealii.org/7.0.0/doxygen/deal.II/group__Quadrature.html">quadrature objects</a>. The main function of these objects is to provide information about the location and weightings of each quadrature point in a cell. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;base/quadrature_lib.h&quot;</span></div>
</div><!-- fragment -->The next block of classes are related to the <a href="http://www.dealii.org/7.0.0/doxygen/deal.II/group__Solvers.html">solvers</a> that will be used to solve the system of equations. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;lac/block_vector.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;lac/full_matrix.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;lac/solver_cg.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;lac/solver_gmres.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;lac/precondition.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;lac/precondition_block.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;lac/block_matrix_array.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;lac/filtered_matrix.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;lac/sparse_ilu.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;lac/sparse_direct.h&quot;</span></div>
</div><!-- fragment -->Next are the <a href="http://www.dealii.org/7.0.0/doxygen/deal.II/group__grid.html">grid classes</a>, with one for generating grid, two for looping over cell or faces and another to handle boundary conditions. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;grid/grid_generator.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;grid/tria_accessor.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;grid/tria_iterator.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;grid/tria_boundary_lib.h&quot;</span></div>
</div><!-- fragment -->The <a href="http://www.dealii.org/7.0.0/doxygen/deal.II/group__feall.html">fe values class</a> is used to store information about the finite elements that are used to discretise the equations. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;fe/fe_values.h&quot;</span></div>
</div><!-- fragment -->The <a href="http://www.dealii.org/7.0.0/doxygen/deal.II/group__numerics.html">numerics classes</a> are used to define convenient objects that are used to store information in a manner more suited to scientific computing. They include vector and matrix classes which are used widely in FCST. Also included is the error_estimator class, which is used for grid refinement. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;numerics/vectors.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;numerics/matrices.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;numerics/error_estimator.h&quot;</span></div>
</div><!-- fragment -->Finally, the deal.II library includes boost as one of its contributing libraries. Here we use the boost shared_pointers instead of C++ pointers because they are more robust in terms of memory leaks. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;boost/shared_ptr.hpp&quot;</span></div>
</div><!-- fragment --><a class="anchor" id="appframe"></a> </p>
<h3>Appframe</h3>
Next is the appframe libraries, which are used to build the system of equations. The block_matrix_application class is one of the parent classes of the applications used in FCST. All applications inherit from block_matrix_application. optimization_block_matrix_application which inherits from block_matrix_application and in turn applications inherit directly from it. It allows for the optimisation of simulations using the Dakota libaries. </p>
<div class="fragment"><div class="line"><span class="comment">// Include appframe classes</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="block__matrix__application_8h.html">appframe/block_matrix_application.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="optimization__block__matrix__application_8h.html">optimization_block_matrix_application.h</a>&quot;</span></div>
</div><!-- fragment -->The last two classes used from appframe, are the appshop classes used to assemble the right and left hand side of our equations. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="matrix__shop__cell_8h.html" title="Matrix integration routines on cells for standard bilinear forms.">appframe/matrix_shop_cell.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="residual__shop__cell_8h.html" title="Residual integration routines on cells for standard bilinear forms.">appframe/residual_shop_cell.h</a>&quot;</span></div>
</div><!-- fragment --><a class="anchor" id="FCST"></a> </p>
<h3>FCST</h3>
The FCST classes are those that are specific to the generation of a fuel cell simulation. The first is Solver_utils which contains a few functions that used by the solvers to check and modify the diagonal entries of the assembled matrix. </p>
<div class="fragment"><div class="line"><span class="comment">// Include FuelCell classes</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="solver__utils_8h.html">solver_utils.h</a>&quot;</span></div>
</div><!-- fragment -->Next is the geometries class which defines the dimensions of the cell, generates the grid for each layer and contains the material id and boundary ids. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="geometries_8h.html">geometries.h</a>&quot;</span></div>
</div><!-- fragment -->The next three classes to be defined are the constants class, which contains universal constants such as Faradays constant or the gas constant. The operating conditions class defines variables such as the operating temperature of the cell, the pressure at the cathode or the molar fraction of hydrogen at the anode and the system management class contains all the equations, variable names used in FCST, and also used for coupling the equations. Depending on the simulations, relevant equations and variables are accessed. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="fcst__constants_8h.html">fcst_constants.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="operating__conditions_8h.html">operating_conditions.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="system__management_8h.html">system_management.h</a>&quot;</span></div>
</div><!-- fragment -->Next are two classes that describe the gases used in the fuel cell and how they interact. The first contains the properties about a number of different gases, for example the viscosity of oxygen or critical temperature of nitrogen. Also described are hydrogen and water vapour. The second describes their interaction. The class will take two gases and return the diffusion coefficient according to Chapman Enskog theory for gas diffusion and Wilke Chang or Hans Bartels Interpolation for liquid diffusion. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="PureGas_8h.html">PureGas.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="BinaryDiffusion_8h.html">BinaryDiffusion.h</a>&quot;</span></div>
</div><!-- fragment -->OpenFCST contains classes that implment the weak form of many partial differential equations that govern the physical processes in a fuel cell. For example, classes exist to implement the weak form of Fick's law of diffusion, Ohm's law, the Navier-Stoke equations, etc. All this classes are stored inside the #Equation namespace in FCST. <br/>
 In our application, we need Fick's law, Ohm's law for that electron and protons and a source term for the electrochemical reaction. This objects are included in our application here.<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="tafel__kinetics_8h.html">tafel_kinetics.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="electron__transport__equation_8h.html">electron_transport_equation.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="proton__transport__equation_8h.html">proton_transport_equation.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="new__ficks__transport__equation_8h.html">new_ficks_transport_equation.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="reaction__source__terms_8h.html">reaction_source_terms.h</a>&quot;</span></div>
</div><!-- fragment -->A fuel cell is made of many composite materials for which effective properties need to be obtained. OpenFCST contains a library of layers for fuel cells under namespace #Layers. The layers are made of different materials and are used to compute the coefficients for the governing equations implemented in the classes above. Layer classes will return information about the effective transport properties of species through each layer, e.g. oxygen diffusion, protonic conductivity, permeabilities etc. The catalyst layers also provide the interface to the kinetics class, which handle the electrochemical reactions in the cell. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="gas__diffusion__layer_8h.html">gas_diffusion_layer.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor"> #include &quot;<a class="code" href="micro__porous__layer_8h.html">micro_porous_layer.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor"> #include &quot;<a class="code" href="catalyst__layer_8h.html">catalyst_layer.h</a>&quot;</span></div>
</div><!-- fragment -->Because OpenFCST code relies heavily on the deal.II libraries, the deal.II namespace is used in most of the header files. This saves from prefixing all calls to deal.II functions and member variables with deal.II. </p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>deal.II;</div>
</div><!-- fragment --><a class="anchor" id="memberfunctiondeclaration"></a> </p>
<h3>The Member Function Declaration</h3>
FCST function and member variables use one of the <a class="el" href="namespaceFuelCell.html" title="This namespace contains data and methods that handle initial and boundary data of a problem at hand...">FuelCell</a> namespaces. There are two main namespaces, <a class="el" href="namespaceFuelCell.html" title="This namespace contains data and methods that handle initial and boundary data of a problem at hand...">FuelCell</a> and <a class="el" href="namespaceFuelCellShop.html" title="Container Namespace for Fuel Cell data classes.">FuelCellShop</a>. <br/>
 <a class="el" href="namespaceFuelCellShop.html" title="Container Namespace for Fuel Cell data classes.">FuelCellShop</a> is the container for the data classes while <a class="el" href="namespaceFuelCell.html" title="This namespace contains data and methods that handle initial and boundary data of a problem at hand...">FuelCell</a> contains the applications, geometries and intial solutions. The main namespace that is used is the <a class="el" href="namespaceFuelCell_1_1Application.html">FuelCell::Application</a>, the container for all the applications that have been developed for the FCST code.<div class="fragment"><div class="line"><span class="keyword">namespace </span>FuelCell</div>
<div class="line">{</div>
</div><!-- fragment -->Application namespace is used for all applications, i.e. all the routines that implement the linear system to be solved using a Newton solver.<div class="fragment"><div class="line"><span class="keyword">namespace </span>Application</div>
<div class="line">{</div>
</div><!-- fragment -->For any application, the first that needs to be declared is a constructor and a destructor. When creating an application, the constructor will create an object of type application data (<a class="el" href="classAppFrame_1_1ApplicationData.html" title="Here we handle general data of applications.">AppFrame::ApplicationData</a>). This is a structure that will handle the general data for the application.<div class="fragment"><div class="line">AppCathode ( boost::shared_ptr&lt;AppFrame::ApplicationData&gt; data =</div>
<div class="line">           boost::shared_ptr&lt;AppFrame::ApplicationData&gt; () );</div>
</div><!-- fragment -->The class destructor will delete any pointers that have not been used by the class. * </p>
<div class="fragment"><div class="line">~AppCathode();</div>
</div><!-- fragment -->All applications have a delcare_parameters function. This function is used to specify the data that is expected from the input file and default data to be used in case the input file does not contain any information for that variable. The data is stored in the ParameterHandler object which is an object in the nonlinear application. </p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> declare_parameters ( ParameterHandler&amp; param );</div>
</div><!-- fragment -->All applications that are used for parameteric and optimization studies with Dakota need the function set_parameters. This function is called by the optimization loop in order to set the values in the ParameterHandler to the new design parameters. <br/>
 Since ParameterHandler depends on the problem we are solving, set_parameters() is set at the most inner loop of the application. </p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> set_parameters ( <span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; name_dvar,</div>
<div class="line">                                         <span class="keyword">const</span> std::vector&lt;double&gt;&amp; value_dvar,</div>
<div class="line">                                         ParameterHandler&amp; param );</div>
</div><!-- fragment -->All applications have a routine initialize. This routine is used to read from ParameterHandler object the values for all the data necessary to setup the application problem to be solved. Note that declare_parameters simply specifies the values that will be read from file. In initialize, the values from the input file are actually read and stored inside the application for later use. </p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="namespaceAppFrame.html#a845ddd93d0345c2f7012e0ff4c0acd82" title="General initialization of the AppFrame in order to simplify main functions.">initialize</a> ( ParameterHandler&amp; param );</div>
</div><!-- fragment --><p> This routine is called by initialize and it is simply used to initialize data unique to the application. </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> _initialize ( ParameterHandler&amp; param );</div>
</div><!-- fragment -->Initilize also creates the computational domain. To do so it will call this routine which determines whether reading from a grid file or creating new mesh </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> initialize_grid ( ParameterHandler&amp; param );</div>
</div><!-- fragment -->This member function is used to create the initial solution for our problem </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> init_solution ( <a class="code" href="classBlockVector.html">AppFrame::FEVector</a>&amp; src ) ;</div>
</div><!-- fragment -->All application need a member function, cell_matrix, that generates the element wise finite element matrix for the system of equations that is solved. Here we loop over the quadrature points and over degrees of freedom in order to compute the matrix for the cell This routine depends on the problem at hand and is called by assemble() in DoF_Handler class The matrix to be assembled in our case is of the form: </p>
<p class="formulaDsp">
\[ \begin{array}{l} M(i,j).block(0) = \int_{\Omega} a \nabla \phi_i \nabla \phi_j d\Omega + \int_{\Omega} \phi_i \frac{\partial f}{\partial u_0}\Big|_n \phi_j d\Omega \\ M(i,j).block(1) = \int_{\Omega} \phi_i \frac{\partial f}{\partial u_1}\Big|_n \phi_j d\Omega \\ M(i,j).block(2) = \int_{\Omega} \phi_i \frac{\partial f}{\partial u_2}\Big|_n \phi_j d\Omega \end{array} \]
</p>
<p> This matrix will be assembled using Equation objects as discussed later.<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> cell_matrix ( <a class="code" href="namespaceAppFrame.html#a2fc5775dc17d00e302c32dc222c5d6d3" title="The matrix vector handed to the local integration routines in MatrixApplication::assemble().">MatrixVector</a>&amp; cell_matrices,</div>
<div class="line">                           <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFApplication.html">DoFApplication&lt;dim&gt;::CellInfo</a>&amp; cell );</div>
</div><!-- fragment -->All application need a member function, cell_residual, that generates the element wise finite element right hand side for the system of equations that is solved. Integration of the rhs of the equations. Here we loop over the quadrature points and over degrees of freedom in order to compute the right hand side for each cell This routine depends on the problem at hand and is called by residual() in DoF_Handler class. Note that this function is called residual because in the case of nonlinear systems the rhs is equivalent to the residual </p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> cell_residual ( <a class="code" href="classBlockVector.html">AppFrame::FEVector</a>&amp; cell_vector,</div>
<div class="line">                             <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFApplication.html">DoFApplication&lt;dim&gt;::CellInfo</a>&amp; cell );</div>
</div><!-- fragment -->If Dirichlet boundary conditions need to be applied to the problem, the application will have to implement this member function, i.e. dirichlet_bc. This member function is used to set dirichlet boundary conditions. This function is application specific and it only computes the boundary_value values that are used to constraint the linear system of equations that is being solved </p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> dirichlet_bc ( std::map&lt;unsigned int, double&gt;&amp; boundary_values ) <span class="keyword">const</span>;</div>
</div><!-- fragment -->All applications need a member function to solve the global system of equations. </p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> solve ( <a class="code" href="classBlockVector.html">AppFrame::FEVector</a>&amp; start,</div>
<div class="line">                     <span class="keyword">const</span> <a class="code" href="classAppFrame_1_1FEVectors.html" title="The data type used in function calls of Application.">AppFrame::FEVectors</a>&amp; rhs );</div>
</div><!-- fragment -->If we want to use adaptive refinement, we need to estimate the error per cell. This value will be used to refine the mesh as needed. </p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">double</span> estimate ( <span class="keyword">const</span> <a class="code" href="classAppFrame_1_1FEVectors.html" title="The data type used in function calls of Application.">AppFrame::FEVectors</a>&amp; sol );</div>
</div><!-- fragment -->Post-processing. This routine is called at post-processing and it is used to evaluate a functional such as the current density </p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">double</span> evaluate ( <span class="keyword">const</span> <a class="code" href="classAppFrame_1_1FEVectors.html" title="The data type used in function calls of Application.">AppFrame::FEVectors</a>&amp; src );</div>
</div><!-- fragment -->This routine is used to create the output file. A base member function already exists, but in AppCathode we will reimplement it so that the right labels are outputed and so that I can compute and output the source terms. </p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> data_out ( <span class="keyword">const</span> std::string &amp;basename,</div>
<div class="line">                        <span class="keyword">const</span> <a class="code" href="classAppFrame_1_1FEVectors.html" title="The data type used in function calls of Application.">AppFrame::FEVectors</a> &amp;src );</div>
</div><!-- fragment --><a class="anchor" id="membervariables"></a> </p>
<h3>The Member Variables</h3>
In this section we will look at the member variables that are used in this application so the basis of the simulation can be understood. This are usually protected: </p>
<div class="fragment"><div class="line"><span class="keyword">protected</span> :</div>
</div><!-- fragment --><p> <br/>
 The first variable is system_management and it is used to store all information related to the system of equations that is being solved such as variable_names, equation_names and couplings between equations. </p>
<div class="fragment"><div class="line"><a class="code" href="classFuelCell_1_1SystemManagement.html" title="IMPORTANT: Add all new solution variables and equations here !">FuelCell::SystemManagement</a> system_management;</div>
</div><!-- fragment --><p> <br/>
 The second member variable is the <a class="el" href="classFuelCell_1_1OperatingConditions.html">operating conditions </a> object that was passed to the initial solution object and explained in more detail in the previous section. </p>
<div class="fragment"><div class="line"><span class="keyword">protected</span> :</div>
<div class="line"><span class="comment">//Operating conditions</span></div>
<div class="line"><a class="code" href="classFuelCell_1_1OperatingConditions.html" title="Class used to store, read from file and define the operating conditions for a fuel cell...">FuelCell::OperatingConditions</a> OC;</div>
</div><!-- fragment -->Next is the grid object which is derived from the <a class="el" href="classFuelCellShop_1_1Geometry_1_1GridBase.html">geometries </a> class. As was previously mentioned this object will define the dimensions of the cell, generates the grid for each layer and contains the material and boundary ids. <br/>
 Instead of creating an object, a boost pointer of the base class is used. This is done so that I can select the appropriate child at run-time after checking the input file. </p>
<div class="fragment"><div class="line"><span class="comment">//Create an object to generate the mesh</span></div>
<div class="line">boost::shared_ptr&lt; FuelCellShop::Geometry::GridBase&lt;dim&gt; &gt; grid;</div>
</div><!-- fragment --><p> <br/>
The cathode contains oxygen, nitrogen and water vapour, so we need to create an object for each gas in order to compute viscosity, density, etc. </p>
<div class="fragment"><div class="line"><a class="code" href="classFuelCellShop_1_1Material_1_1Water.html" title="Water as a publicly derived class of Material.">FuelCellShop::Material::Water</a> water;</div>
<div class="line"><a class="code" href="classFuelCellShop_1_1Material_1_1Oxygen.html" title="Oxygen as a publicly derived class of Material.">FuelCellShop::Material::Oxygen</a> oxygen;</div>
<div class="line"><a class="code" href="classFuelCellShop_1_1Material_1_1Nitrogen.html" title="Nitrogen as a publicly derived class of Material.">FuelCellShop::Material::Nitrogen</a> nitrogen;</div>
</div><!-- fragment --><p> <br/>
Next the cathode gas diffusion layer (CGDL) and cathode catalyst layer (CCL) are created. Again a pointer is used to the base class for each type of layer. We will then select the appropriate CGDL / CCL once we have read the input file. Using a pointer allows us to code everything independently of the layer we want to use. This allows users to develop their own layers. By making them a child of the base class, for example FuelCellShop::Layer::GasDiffusionLayer&lt;dim&gt;, the application will run for your new layer without any modification. For info on how to create your own layer, please consult the documentation on the base layer clases </p>
<div class="fragment"><div class="line">boost::shared_ptr&lt;FuelCellShop::Layer::GasDiffusionLayer&lt;dim&gt; &gt; CGDL;</div>
<div class="line">boost::shared_ptr&lt;FuelCellShop::Layer::MicroPorousLayer&lt;dim&gt; &gt; CMPL;</div>
<div class="line">boost::shared_ptr&lt;FuelCellShop::Layer::CatalystLayer&lt;dim&gt; &gt; CCL;</div>
</div><!-- fragment -->OpenFCST contains a database of materials and layers, but also a database that contains the discrtization of most physical equations relavant to fuel cells. Therefore, we will create an object of the physical processes that are relevant to the cathode. <br/>
 For the cathode we need an Ohm's law equation for electrons, a Fick's law equation for oxygen and an Ohm's law equation for protons. We also need a source term for the reaction rates. <br/>
 The equation class used to assemble the cell matrix for electron transport is </p>
<div class="fragment"><div class="line"><a class="code" href="classFuelCellShop_1_1Equation_1_1ElectronTransportEquation.html" title="This class deals with Electron Transport Equation.">FuelCellShop::Equation::ElectronTransportEquation&lt;dim&gt;</a> electron_transport_equation;</div>
</div><!-- fragment --><p> The equation class used to assemble the cell matrix for Fick's mass transport. </p>
<div class="fragment"><div class="line"><a class="code" href="classFuelCellShop_1_1Equation_1_1NewFicksTransportEquation.html" title="This class deals with Ficks Transport Equation.">FuelCellShop::Equation::NewFicksTransportEquation&lt;dim&gt;</a> ficks_transport_equation;</div>
</div><!-- fragment -->Equation class used to assemble the cell matrix for proton transport </p>
<div class="fragment"><div class="line"><a class="code" href="classFuelCellShop_1_1Equation_1_1ProtonTransportEquation.html" title="This class deals with Proton Transport Equation.">FuelCellShop::Equation::ProtonTransportEquation&lt;dim&gt;</a> proton_transport_equation;</div>
</div><!-- fragment -->The Equation class to assemble the cell matrix and cell_residual for the reaction source terms is the last object. After that, we finish the declaration of the class and the namespaces in the <a class="el" href="app__cathode_8h.html">app_cathode.h</a> file. </p>
<div class="fragment"><div class="line"><a class="code" href="classFuelCellShop_1_1Equation_1_1ReactionSourceTerms.html" title="This class is used to assemble reaction source terms in the catalyst layer.">FuelCellShop::Equation::ReactionSourceTerms&lt; dim &gt;</a> reaction_source;</div>
<div class="line"> };</div>
<div class="line">}</div>
<div class="line">}</div>
<div class="line"><span class="preprocessor">#endif //_FUELCELL__APP_CATHODE_H</span></div>
</div><!-- fragment --><a class="anchor" id="mainapplication"></a> </p>
<h2>Source File</h2>
<a class="anchor" id="memberfunctions"></a> </p>
<h3>The Member Functions</h3>
All source files need to include the .h file. Therefore, the first line in our code is </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="app__cathode_8h.html">app_cathode.h</a>&quot;</span></div>
</div><!-- fragment --><p> <br/>
Since all member functions are in namespace <a class="el" href="namespaceFuelCell_1_1Application.html">FuelCell::Application</a> is useful to define a shortcut. Also, <a class="el" href="namespaceAppFrame.html" title="Functions and classes of the application framework.">AppFrame</a> functions are used all the time, so we use using namespace <a class="el" href="namespaceAppFrame.html" title="Functions and classes of the application framework.">AppFrame</a> so that we do not need to specify the namespace. </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>NAME = FuelCell::Application;</div>
<div class="line"><span class="keyword">using namespace </span>AppFrame;</div>
</div><!-- fragment -->Now, we are ready to start the implementation of all the member functions in AppCathode. <br/>
 <br/>
 Each application is based on the application base class in appframe (<a class="el" href="classAppFrame_1_1ApplicationBase.html" title="Base class for applications.">AppFrame::ApplicationBase</a>), in particular the <a class="el" href="classOptimizationBlockMatrixApplication.html" title="Note: I need to use this class in order to make sure that the compiler knows that it will be defined ...">OptimizationBlockMatrixApplication</a> class (<a class="el" href="classAppFrame_1_1OptimizationBlockMatrixApplication.html" title="Application handling matrices and assembling the linear system to solve the sensitivity equations...">AppFrame::OptimizationBlockMatrixApplication</a>). This class is the last in a series of inherited classes starting with ApplicationBase that includes <a class="el" href="classDoFApplication.html">DoFApplication</a> (<a class="el" href="classAppFrame_1_1DoFApplication.html" title="Integrate the residual using DoFApplication::integrate_1form().">AppFrame::DoFApplication</a>) and BlockMatrixApplication (<a class="el" href="classAppFrame_1_1BlockMatrixApplication.html" title="Application handling matrices and assembling linear systems of equations.">AppFrame::BlockMatrixApplication</a>). The <a class="el" href="classDoFApplication.html">DoFApplication</a> contains a handler for the degrees of freedom, <a class="el" href="classTriangulation.html">Triangulation</a> and the mesh. BlockMatrixApplication handles the matrices and the assembling of the linear systems of equations. <a class="el" href="classOptimizationBlockMatrixApplication.html" title="Note: I need to use this class in order to make sure that the compiler knows that it will be defined ...">OptimizationBlockMatrixApplication</a> was then added by the OpenFCST developers to handle sensitivity analysis. As such all applications are inherited from OptimizationBlockMatrix. <br/>
 <br/>
 AppCathode constructor will therefore initialize <a class="el" href="classOptimizationBlockMatrixApplication.html" title="Note: I need to use this class in order to make sure that the compiler knows that it will be defined ...">OptimizationBlockMatrixApplication</a>. Also, all equation classes need to be created during the constructor. Finally, we output a line to the terminal stating that this application has been created. </p>
<div class="fragment"><div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">NAME::AppCathode&lt;dim&gt;::AppCathode(boost::shared_ptr&lt;AppFrame::ApplicationData&gt; data)</div>
<div class="line"> :</div>
<div class="line"> <a class="code" href="classOptimizationBlockMatrixApplication.html" title="Note: I need to use this class in order to make sure that the compiler knows that it will be defined ...">OptimizationBlockMatrixApplication</a>&lt;<a class="code" href="fcst__constants_8h.html#a665f17c0bbcd89f2925d9ad4c4b077e5">dim</a>&gt;(data),  </div>
<div class="line"> ficks_transport_equation(system_management,&amp;oxygen, &amp;nitrogen),</div>
<div class="line"> electron_transport_equation(system_management),</div>
<div class="line"> proton_transport_equation(system_management),</div>
<div class="line"> reaction_source(system_management)</div>
<div class="line">{</div>
<div class="line"> deallog &lt;&lt; <span class="stringliteral">&quot;-&gt;FuelCell::Application::AppCathode_test-&quot;</span> &lt;&lt; <a class="code" href="fcst__constants_8h.html#a665f17c0bbcd89f2925d9ad4c4b077e5">dim</a> &lt;&lt;<span class="stringliteral">&quot;d&quot;</span>&lt;&lt;std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The destructor for AppCathode does not need to remove any extra pointers since boost pointers have their own memory management strategy. </p>
<div class="fragment"><div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">NAME::AppCathode&lt;dim&gt;::~AppCathode()</div>
<div class="line">{}</div>
</div><!-- fragment -->Now that the application is created, the next step is to provide the required information to run a simulation. There are three functions that are used to do this. The first is the <code>declare_parameters </code> function. The application needs to declare the parameters it needs from file, but all other objects used by the applicaiton also need to do the same thing. Therefore, declare_parametes contains a call to declare_parameter for all the Materials, Layers and Equation classes. Note that for the Layers and Geometry, a static function is called. The name provided in the call, e.g. "Cathode gas diffusion layer", is the name of the section in the input file where the information need to be provided.<div class="fragment"><div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> </div>
<div class="line">NAME::AppCathode&lt;dim&gt;::declare_parameters(ParameterHandler&amp; param)</div>
<div class="line">{</div>
<div class="line"> <a class="code" href="classOptimizationBlockMatrixApplication.html" title="Note: I need to use this class in order to make sure that the compiler knows that it will be defined ...">OptimizationBlockMatrixApplication&lt;dim&gt;::declare_parameters</a>(param);</div>
<div class="line">  system_management.declare_parameters(param);</div>
<div class="line">  <a class="code" href="classFuelCellShop_1_1Geometry_1_1GridBase.html#ac93160db023398f2fb3dc2489d525968" title="Function used to declare all the data necessary in the parameter files for all GridBase children...">FuelCellShop::Geometry::GridBase&lt;dim&gt;::declare_GridGenerator_parameters</a>(param);</div>
<div class="line">  OC.declare_parameters(param);</div>
<div class="line">  <a class="code" href="classFuelCellShop_1_1Layer_1_1GasDiffusionLayer.html#a1066e6a38babea3772e71abddcfb736d" title="Function used to declare all the data necessary in the parameter files for all GasDiffusionLayer chil...">FuelCellShop::Layer::GasDiffusionLayer&lt;dim&gt;::declare_GasDiffusionLayer_parameters</a>(<span class="stringliteral">&quot;Cathode gas diffusion layer&quot;</span>, param);</div>
<div class="line">  <a class="code" href="classFuelCellShop_1_1Layer_1_1MicroPorousLayer.html#a6731d13924ec5fab4dee2f06ad238be4" title="Function used to declare all the data necessary in the parameter files former all MicroPorousLayer ch...">FuelCellShop::Layer::MicroPorousLayer&lt;dim&gt;::declare_MicroPorousLayer_parameters</a>(<span class="stringliteral">&quot;Cathode microporous layer&quot;</span>, param);</div>
<div class="line">  <a class="code" href="classFuelCellShop_1_1Layer_1_1CatalystLayer.html#acb7baaad36ced3a2fea046bfea1ad7ed" title="Function used to declare all the data necessary in the parameter files former all CatalystLayer child...">FuelCellShop::Layer::CatalystLayer&lt;dim&gt;::declare_CatalystLayer_parameters</a>(<span class="stringliteral">&quot;Cathode catalyst layer&quot;</span>, param);</div>
<div class="line">  electron_transport_equation.declare_parameters(param);</div>
<div class="line">  proton_transport_equation.declare_parameters(param);</div>
<div class="line">  ficks_transport_equation.declare_parameters(param);</div>
<div class="line">  reaction_source.declare_parameters(param);</div>
<div class="line">}</div>
</div><!-- fragment -->Each one of the declare_parameter calls tells the application what parameters might be passed to it by the .prm file. In the operating conditions class for example, 'entries' such as the temperature of the cell, the cathode pressure or the RH of the cathode are created by the function and are given a default value. The function also tells the application what type of a value to expect, double, int, bool etc. and optionally a short description of the parameter.For example, the OperatingConditions <code>declare_parameters</code> code looks as follows: </p>
<div class="fragment"><div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line"><a class="code" href="classFuelCell_1_1OperatingConditions.html#a485d6953355c4989b1ad89dd1022d390" title="Declare all necessary parameters in order to compute the coefficients.">FuelCell::OperatingConditions::declare_parameters</a> (ParameterHandler &amp;param)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">param.enter_subsection(<span class="stringliteral">&quot;Fuel cell* data&quot;</span>);</div>
<div class="line">{</div>
<div class="line">    param.enter_subsection(<span class="stringliteral">&quot;Operating conditions&quot;</span>);</div>
<div class="line">    {</div>
<div class="line">        param.declare_entry (<span class="stringliteral">&quot;Temperature cell&quot;</span>,</div>
<div class="line">                             <span class="stringliteral">&quot;353&quot;</span>, <span class="comment">// K, or 80 Celsius</span></div>
<div class="line">                             Patterns::Double());</div>
<div class="line">        param.declare_entry (<span class="stringliteral">&quot;Cathode pressure&quot;</span>,</div>
<div class="line">                             <span class="stringliteral">&quot;101325&quot;</span>, <span class="comment">// Pa, or 1 atm</span></div>
<div class="line">                             Patterns::Double(),</div>
<div class="line">                            <span class="stringliteral">&quot;Pressure at the cathode channel in Pa&quot;</span>);</div>
<div class="line">         param.declare_entry (<span class="stringliteral">&quot;Cathode relative humidity&quot;</span>,</div>
<div class="line">                              <span class="stringliteral">&quot;0.7&quot;</span>,</div>
<div class="line">                              Patterns::Double(),</div>
<div class="line">                              <span class="stringliteral">&quot;Relative humidity (fraction) in the cathode channel&quot;</span>);</div>
<div class="line">         param.declare_entry (<span class="stringliteral">&quot;Anode pressure&quot;</span>,</div>
<div class="line">                              <span class="stringliteral">&quot;101325&quot;</span>, <span class="comment">// Pa, or 1 atm</span></div>
<div class="line">                              Patterns::Double(),</div>
<div class="line">                              <span class="stringliteral">&quot;Pressure at the anode channel in Pa&quot;</span>);</div>
<div class="line">         param.declare_entry (<span class="stringliteral">&quot;Anode relative humidity&quot;</span>,</div>
<div class="line">                              <span class="stringliteral">&quot;0.7&quot;</span>,</div>
<div class="line">                              Patterns::Double(),</div>
<div class="line">                              <span class="stringliteral">&quot;Relative humidity (fraction) in the anode channel&quot;</span>);</div>
<div class="line">         param.declare_entry (<span class="stringliteral">&quot;Voltage cell&quot;</span>,</div>
<div class="line">                              <span class="stringliteral">&quot;0.6&quot;</span>, </div>
<div class="line">                              Patterns::Double());</div>
<div class="line">         param.declare_entry(<span class="stringliteral">&quot;Voltage drop in the anode&quot;</span>,</div>
<div class="line">                              <span class="stringliteral">&quot;0.015&quot;</span>,</div>
<div class="line">       Patterns::Double());</div>
<div class="line">    param.declare_entry (<span class="stringliteral">&quot;Open circuit voltage&quot;</span>,</div>
<div class="line">             <span class="stringliteral">&quot;1.23&quot;</span>,</div>
<div class="line">             Patterns::Double());</div>
<div class="line">  }</div>
<div class="line">  param.leave_subsection();</div>
<div class="line">}</div>
<div class="line">param.leave_subsection(); </div>
<div class="line">}</div>
</div><!-- fragment -->The prm file is a file containing a list of these parameters as specified by all the <code>declare_parameters</code> functions. It is divided into sections and subsections each having their own label as defined by the <code>declare_parameters</code> functions. For example the operating conditions parameters are found in the "Operating conditions" subsection under the "Fuel cell data" subsection. This section from the prm file is given below: </p>
<div class="fragment"><div class="line">subsection Fuel cell data</div>
<div class="line"> subsection Operating conditions</div>
<div class="line">    <span class="keyword">set</span> Temperature cell = 383 #[<a class="code" href="namespaceConstants.html#aa5e92a8c5672b9716adb862563a86d75" title="Boltzmann constant = 8.617332478e-5 eV/K.">K</a>]</div>
<div class="line">    <span class="keyword">set</span> Cathode pressure = 101265 #[Pa] (1 atm)</div>
<div class="line">    <span class="keyword">set</span> Cathode relative humidity = 0.6</div>
<div class="line">    <span class="keyword">set</span> Voltage cell = 0.822 ## Convergence up to 0.66V</div>
<div class="line"> end</div>
<div class="line">end</div>
</div><!-- fragment -->Note that not all the entries declared in the source code are found in the prm file, for example "Anode 
 relative humidity". In this case the default value will be used. Also when defining a parameter, the units should be included. For example the entry for the cell temperature should be "Temperature cell [K]". <br/>
 Users do not usually need to look at the code to see the parameters that are declared, the DOxygen documentation, under declare_parameters, will explain the values declared. <br/>
 <br/>
 If an optimisation case is being run, then the application will need to know the parameters that are to be optimised. This is done using the <code>set_parameters</code> function. Here the function stores the names of the parameters to be optimised, in the vector of strings <code>name_dvar</code>, and it's values, in the vector of doubles <code>value_dvar</code>. These are then handled by the optimization_block_matrix_application class. In the application, the function simply calls the <code>set_parameters</code> functions of the relevant classes:<div class="fragment"><div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> </div>
<div class="line">NAME::AppCathode&lt;dim&gt;::set_parameters(<span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; name_dvar,</div>
<div class="line">                       <span class="keyword">const</span> std::vector&lt;double&gt;&amp; value_dvar,</div>
<div class="line">                       ParameterHandler&amp; param)</div>
<div class="line">{</div>
<div class="line"> OC.set_parameters(name_dvar, value_dvar, param);  </div>
<div class="line"> <a class="code" href="classFuelCellShop_1_1Geometry_1_1GridBase.html#af7b1f465965b7256c911d4792671efe8" title="Used for optimization.">FuelCellShop::Geometry::GridBase&lt;dim&gt;::set_GridGenerator_parameters</a> (name_dvar, value_dvar, param);</div>
<div class="line"> <a class="code" href="classFuelCellShop_1_1Layer_1_1GasDiffusionLayer.html#a99fa86b2e51ad2744a599a56d73bfcd9">FuelCellShop::Layer::GasDiffusionLayer&lt;dim&gt;::set_GasDiffusionLayer_parameters</a>(name_dvar, value_dvar, <span class="stringliteral">&quot;Cathode gas diffusion layer&quot;</span>, param);</div>
<div class="line"> <a class="code" href="classFuelCellShop_1_1Layer_1_1MicroPorousLayer.html#aff83f5ccec86541b9097aa2a63757de0" title="This routine is only used for optimization and parameteric studies purposes when using the Dakota Int...">FuelCellShop::Layer::MicroPorousLayer&lt;dim&gt;::set_MicroPorousLayer_parameters</a>(name_dvar, value_dvar, <span class="stringliteral">&quot;Cathode microporous layer&quot;</span>, param);</div>
<div class="line"> <a class="code" href="classFuelCellShop_1_1Layer_1_1CatalystLayer.html#a54c277eb13467a7635380c1b96a08184">FuelCellShop::Layer::CatalystLayer&lt;dim&gt;::set_CatalystLayer_parameters</a>(name_dvar, value_dvar, <span class="stringliteral">&quot;Cathode catalyst layer&quot;</span>, param);</div>
<div class="line"> design_var = name_dvar;</div>
<div class="line"> design_var_value = value_dvar;</div>
<div class="line">}    </div>
</div><!-- fragment -->The initialise function is the final function in setting up the simulation. It actually parses the prm file, extracts the required values and assigns them to the relevant variables. Again the application function calls the functions of the contributing classes. <br/>
 In initialize, the ParameterHandler object param already contains the information from the input file. Now this information needs to be distributed to all object in the application. <br/>
 First, we initialize system_management and operating_conditions (OC): </p>
<div class="fragment"><div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">NAME::AppCathode&lt;dim&gt;::_initialize(ParameterHandler&amp; param)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Initialize parameters in system management:</span></div>
<div class="line">   system_management.initialize(param);</div>
<div class="line"></div>
<div class="line">   <span class="comment">// Initialize coefficients</span></div>
<div class="line">   OC.initialize(param);</div>
<div class="line">}</div>
</div><!-- fragment -->The contributing classes initialise functions actually extract and set the required values, for example, the call <code>OC.initialize(param);</code> will run the following function: </p>
<div class="fragment"><div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line"><a class="code" href="classFuelCell_1_1OperatingConditions.html#a86549242588fa5abb61bb627b05238ab" title="Class used to read in data and initialize the necessary data to compute the coefficients.">FuelCell::OperatingConditions::initialize</a> (ParameterHandler&amp; param)</div>
<div class="line">{</div>
<div class="line"> <a class="code" href="classFuelCell_1_1OperatingConditions.html#a7bd1dc464e9d1093f007b65495532f82">R</a> = <a class="code" href="namespaceConstants.html#a75e575cc919990da7a68ec1d509bce58" title="Universal gas constant = 8.314462176 J/(mol K)">Constants::R</a>();</div>
<div class="line"> param.enter_subsection(<span class="stringliteral">&quot;Fuel cell data&quot;</span>);</div>
<div class="line"> {</div>
<div class="line">   param.enter_subsection(<span class="stringliteral">&quot;Operating conditions&quot;</span>);</div>
<div class="line">   {</div>
<div class="line">     <a class="code" href="classFuelCell_1_1OperatingConditions.html#aba373c5a1efe50601b532c997805d344" title="Operating temperature of the cell.">T_cell</a> = param.get_double(<span class="stringliteral">&quot;Temperature cell&quot;</span>);</div>
<div class="line">     <a class="code" href="classFuelCell_1_1OperatingConditions.html#af1859ba8c6010ff8b5d11220ba0c84aa" title="Operating voltage of the cell.">V_cell</a> = param.get_double(<span class="stringliteral">&quot;Voltage cell&quot;</span>);</div>
<div class="line">     <span class="comment">// Cathode</span></div>
<div class="line">     <a class="code" href="classFuelCell_1_1OperatingConditions.html#aba59338fd662494c7bfb5846c58d703e" title="Pressure of the gas mixture in the cathode B.C.">p_c</a> = param.get_double(<span class="stringliteral">&quot;Cathode pressure&quot;</span>);</div>
<div class="line">     <a class="code" href="classFuelCell_1_1OperatingConditions.html#a5c0c9bd92c1f18ccb405d7dbbb8f36e0" title="Concentration of the gas mixture in the cathode B.C.">c_c</a> = <a class="code" href="classFuelCell_1_1OperatingConditions.html#aba59338fd662494c7bfb5846c58d703e" title="Pressure of the gas mixture in the cathode B.C.">p_c</a>/(<a class="code" href="classFuelCell_1_1OperatingConditions.html#a7bd1dc464e9d1093f007b65495532f82">R</a>*<a class="code" href="classFuelCell_1_1OperatingConditions.html#aba373c5a1efe50601b532c997805d344" title="Operating temperature of the cell.">T_cell</a>)*1E-6; <span class="comment">//mol/cm^3</span></div>
<div class="line">     <a class="code" href="classFuelCell_1_1OperatingConditions.html#a6ef2550fb91439b65b8a27f75e16ab19" title="Relative humidity of the gas mixture in the anode B.C.">RH_c</a> = param.get_double(<span class="stringliteral">&quot;Cathode relative humidity&quot;</span>);</div>
<div class="line">     <span class="comment">// Anode</span></div>
<div class="line">     <a class="code" href="classFuelCell_1_1OperatingConditions.html#a42a3f08025355984a616724bfc0cd039" title="Pressure of the gas mixture in the anode B.C.">p_a</a> = param.get_double(<span class="stringliteral">&quot;Anode pressure&quot;</span>);</div>
<div class="line">     <a class="code" href="classFuelCell_1_1OperatingConditions.html#a38d05609be24ea0c41cff85ce9be2951" title="Concentration of the gas mixture in the anode B.C.">c_a</a> = <a class="code" href="classFuelCell_1_1OperatingConditions.html#a42a3f08025355984a616724bfc0cd039" title="Pressure of the gas mixture in the anode B.C.">p_a</a>/(<a class="code" href="classFuelCell_1_1OperatingConditions.html#a7bd1dc464e9d1093f007b65495532f82">R</a>*<a class="code" href="classFuelCell_1_1OperatingConditions.html#aba373c5a1efe50601b532c997805d344" title="Operating temperature of the cell.">T_cell</a>)*1E-6; <span class="comment">//mol/cm^3</span></div>
<div class="line">     <a class="code" href="classFuelCell_1_1OperatingConditions.html#a25fa276c027da536a524ef227e334a2f" title="Relative humidity of the gas mixture in the anode B.C.">RH_a</a> = param.get_double(<span class="stringliteral">&quot;Anode relative humidity&quot;</span>);</div>
<div class="line">     <span class="comment">// Cell voltage</span></div>
<div class="line">     <a class="code" href="classFuelCell_1_1OperatingConditions.html#af1859ba8c6010ff8b5d11220ba0c84aa" title="Operating voltage of the cell.">V_cell</a> = param.get_double(<span class="stringliteral">&quot;Voltage cell&quot;</span>);</div>
<div class="line">     <a class="code" href="classFuelCell_1_1OperatingConditions.html#a6ad2ab12eb45dcaaa3d543158360104a" title="Voltage drop in the anode.">dV_a</a> = param.get_double(<span class="stringliteral">&quot;Voltage drop in the anode&quot;</span>);</div>
<div class="line">     <a class="code" href="classFuelCell_1_1OperatingConditions.html#a0ca4bf4c6ddc58a719b186b32d178671" title="Open circuit voltage for the cell.">OCV</a> = param.get_double(<span class="stringliteral">&quot;Open circuit voltage&quot;</span>);</div>
<div class="line">     <span class="keywordflow">if</span> (<a class="code" href="classFuelCell_1_1OperatingConditions.html#a0ca4bf4c6ddc58a719b186b32d178671" title="Open circuit voltage for the cell.">OCV</a> &gt; <a class="code" href="classFuelCell_1_1OperatingConditions.html#a7db924fc442581e3b235952b33580245" title="NOTE: This function is redefined in base_kinetics class, considering variable temperature and gas pre...">voltage_cell_th</a>()) <span class="comment">// NOTE: This also initializes E_th</span></div>
<div class="line">     {</div>
<div class="line">       <a class="code" href="classFuelCell_1_1OperatingConditions.html#a0ca4bf4c6ddc58a719b186b32d178671" title="Open circuit voltage for the cell.">OCV</a> = <a class="code" href="classFuelCell_1_1OperatingConditions.html#a6e757ea106ec32497dcd805971df3dad" title="Theoretical voltage for the cell.">E_th</a>;</div>
<div class="line">       param.set(<span class="stringliteral">&quot;Open circuit voltage&quot;</span>, <a class="code" href="classFuelCell_1_1OperatingConditions.html#a0ca4bf4c6ddc58a719b186b32d178671" title="Open circuit voltage for the cell.">OCV</a>); <span class="comment">// For other (old) classes that may use this</span></div>
<div class="line">   }</div>
<div class="line">   }</div>
<div class="line">   param.leave_subsection();</div>
<div class="line"> }</div>
<div class="line"> param.leave_subsection();</div>
<div class="line">}</div>
</div><!-- fragment -->The next step is to set up the grid. For this, we call the #initialize_grid function which will be implemented next. This member function will read in and set variables such as the number of divisions in the CGDL and CCL, the material and boundary IDs and the physical dimensions and then generate the mesh and store it the object this-&gt;tr. </p>
<div class="fragment"><div class="line"><span class="comment">// Generate grid and refine</span></div>
<div class="line">  this-&gt;initialize_grid(param);</div>
</div><!-- fragment -->The initialise function in the application actually does more than set up the parameters for the simulation, it also initialises the Materials, Layers and Equation objects and also the kinetics class for cathode catalyst layer. In this case, we first create a vector with all the gases that will exist in the layers. <br/>
 Next, we call create_GasDiffusionLayer("Cathode gas diffusion layer",param) This function reads the parameter file section Fuel Cell Data &gt; Cathode gas diffusion layer, reads the type of GDL that we would like to use, and then initializes the pointer CGDL to the appropriate GasDiffusionLayer child. In this case, DesignFibrousGDL as we will see when discussing the parameter file. <br/>
 One the layer has been initialized, we "fill" the layer with the gases using CGDL-&gt;set_gases_and_compute(gases, OC.get_pc_atm (), OC.get_T()). This routine is used to store the gases, the temperature and the pressure in the layer and to compute the diffusion coefficients. <br/>
 The MicroPorousLayer and CatalystLayer objects are initialized using the same method.<div class="fragment"><div class="line"><span class="comment">// Initialize gases and material classes:</span></div>
<div class="line"> std::vector&lt; FuelCellShop::Material::PureGas * &gt; gases;</div>
<div class="line"> gases.push_back(&amp;oxygen);</div>
<div class="line"> gases.push_back(&amp;nitrogen);</div>
<div class="line"> <span class="comment">// Initialize layer classes:    </span></div>
<div class="line"> CGDL = <a class="code" href="classFuelCellShop_1_1Layer_1_1GasDiffusionLayer.html#a73064f12b7361af73c10bb9cc798c053" title="Function used to select the appropriate GasDiffusionLayer type as specified in the ParameterHandler u...">FuelCellShop::Layer::GasDiffusionLayer&lt;dim&gt;::create_GasDiffusionLayer</a>(<span class="stringliteral">&quot;Cathode gas diffusion layer&quot;</span>,param);</div>
<div class="line"> CGDL-&gt;set_gases_and_compute(gases, OC.get_pc_atm (), OC.get_T());</div>
<div class="line"> </div>
<div class="line"> CMPL = <a class="code" href="classFuelCellShop_1_1Layer_1_1MicroPorousLayer.html#a1922c3d2b773c2074e04c04c05844889" title="Function used to select the appropriate MicroPorousLayer.">FuelCellShop::Layer::MicroPorousLayer&lt;dim&gt;::create_MicroPorousLayer</a>(<span class="stringliteral">&quot;Cathode microporous layer&quot;</span>,param);</div>
<div class="line"> CMPL-&gt;set_gases_and_compute(gases, OC.get_pc_atm (), OC.get_T());</div>
<div class="line"></div>
<div class="line"> CCL = <a class="code" href="classFuelCellShop_1_1Layer_1_1CatalystLayer.html#aaea6089554e33bbc29c2f5b688a6cb3b" title="Function used to select the appropriate CatalystLayer type as specified in the ParameterHandler under...">FuelCellShop::Layer::CatalystLayer&lt;dim&gt;::create_CatalystLayer</a>(<span class="stringliteral">&quot;Cathode catalyst layer&quot;</span>, param);</div>
<div class="line"> CCL-&gt;set_gases_and_compute (gases, OC.get_pc_atm (), OC.get_T());</div>
</div><!-- fragment -->For the CatalystLayer object, in addition to specifying the type of gas inside the layer, we also need to specify the reactions that we are interested in solvign for since the catalyst layer class contains a kinetics objects which will compute the reaction rates for different reactions. In order to compute the reactions, we need to know the overpotential, temperature and pressure. Every time we call the cell_matrix and cell_residual function, we pass the solution (which will contain the oxygen molar fraction and the two potentials) to the kinetics class. However the kinetics class expects that the temperature and pressure are solution variables (i.e.that it is set at each quadrature point for each cell). <a class="el" href="">(OC.get_pc_Pa(), total_pressure)</a> and <a class="el" href="">(OC.get_T(), temperature_of_REV)</a> are used to specify that these variables are constant and should take the value provided as the first argument.<div class="fragment"><div class="line"><span class="comment">// Initialise the necessary kinetics parameters in CCL.</span></div>
<div class="line"> std::string name = <span class="stringliteral">&quot;ORR&quot;</span>;</div>
<div class="line"> CCL-&gt;set_reaction_kinetics(name);</div>
<div class="line"> CCL-&gt;set_constant_solution(OC.get_pc_Pa(),  <a class="code" href="system__management_8h.html#a905465f7ef35ccf9a9a5fa54e2afd938a55203f2bf9c613ef5d5d6e4307b56003">VariableNames::total_pressure</a>);   <span class="comment">//Note: Pressure and temp. can only be set after setting kinetics.</span></div>
<div class="line"> CCL-&gt;set_constant_solution(OC.get_T(),  <a class="code" href="system__management_8h.html#a905465f7ef35ccf9a9a5fa54e2afd938a3f92f8366faa0afba7787098cf3b8b87">VariableNames::temperature_of_REV</a>);</div>
</div><!-- fragment -->Once the layers have been initialized, it is time to initialize the Equation objects. <br/>
 Before initializing the objects, we set the kinetics in the reaction source term object. Next, we allow all Equation object to read all their parameters from file: * </p>
<div class="fragment"><div class="line"><span class="comment">// Setting kinetics in the reaction source terms object.</span></div>
<div class="line">reaction_source.set_cathode_kinetics(CCL-&gt;get_kinetics());</div>
<div class="line"></div>
<div class="line"><span class="comment">// Initialize parameters for physics classes:</span></div>
<div class="line">electron_transport_equation.initialize(param);  </div>
<div class="line">proton_transport_equation.initialize(param);  </div>
<div class="line">ficks_transport_equation.initialize(param);  </div>
<div class="line">reaction_source.initialize(param);</div>
</div><!-- fragment -->Next is to prepare the matrix that will contain our system of equations. This involves telling the application how the equations are coupled, i.e. how one solution variable affects the other equations. The blocks for our three equation system are visualised below: </p>
<table  width="20%" align="center">
<tr>
<td align="center"><div class="image">
<img src="tutorial_blocks.png" alt="tutorial_blocks.png"/>
</div>
   </td></tr>
</table>
If the variable is not in the equation then this block will contain zeros. To save memory, <a class="el" href="namespaceAppFrame.html" title="Functions and classes of the application framework.">AppFrame</a> will not store this block: if, for example, the membrane potential was not present in the third equation for the solid phase potential then there would only be 8 blocks. In this case the system of equations is fulled coupled as the source term for each equation contains each of the solution variables. To get the information about coupling, a vector "tmp" is created, push_back function is used to get internal cell couplings for all three equations then the couplings are adjusted after including the source term. Finally the couplings are generated in system management.<div class="fragment"><div class="line"><span class="comment">// Initialize system of equations based on the physical phenomena being solved for:</span></div>
<div class="line">std::vector&lt;couplings_map&gt; tmp;</div>
<div class="line">tmp.push_back(ficks_transport_equation.get_internal_cell_couplings() );</div>
<div class="line">tmp.push_back(proton_transport_equation.get_internal_cell_couplings() );</div>
<div class="line">tmp.push_back(electron_transport_equation.get_internal_cell_couplings() );</div>
<div class="line">reaction_source.adjust_internal_cell_couplings(tmp);</div>
<div class="line">system_management.make_cell_couplings(tmp);  </div>
</div><!-- fragment -->Given that the grid has now been set up, we can now give it the information about the degrees of freedom (dof) to be associated with each cell. This information is stored using a deal.II object called <a href="http://www.dealii.org/7.3.0/doxygen/tutorial/index.html">DoFHandler</a> that will look at the type of finite elements that the simulation is using and allocate space for the dof. The finite elements we are using are defined in the parameter file, under the section Discretisation &gt; Element. In the test case, we are using three first order elements which are defined using: <code>FESystem[FE_Q(1)^3]</code>. If second order elements are required, then we would use: <code>FESystem[FE_Q(2)^3]</code>. To use different elements for an equation, for example first order for the first equation and second order for the other two, we would write <code>FESystem[FE_Q(1)]-FESystem[FE_Q(2)^2]</code>. This is implemented in the deal.II <a href="http://www.dealii.org/7.3.0/doxygen/deal.II/group__feall.html">FiniteElement</a> classes.<div class="fragment"><div class="line"><span class="comment">// Initialize dof per cell for the system of equations and information on</span></div>
<div class="line"><span class="comment">//block sizes and indices</span></div>
<div class="line">this-&gt;remesh_dofs();</div>
</div><!-- fragment -->The <a class="el" href="classAppFrame_1_1DoFApplication.html#a1cb7232d6ffd4b123b587cf4013cd313">remesh_dofs()</a> will also assign indices to the cells and faces that will be used later in the error estimator.The next step is to initialise the matrix that will store the system of equations. </p>
<div class="fragment"><div class="line"><span class="comment">// Initialize matrices and spartisity pattern for the whole system</span></div>
<div class="line">this-&gt;remesh_matrices();</div>
</div><!-- fragment -->This is all. Finally, we simply call some routines that are used to print information to screen in order to make sure we have initialized our layers correct. </p>
<div class="fragment"><div class="line"><span class="comment">// Some info for debugging purposes:</span></div>
<div class="line">   <span class="comment">//system_management.print_system_info ();</span></div>
<div class="line">   CCL-&gt;print_layer_properties ();</div>
<div class="line">   <span class="comment">//abort();</span></div>
<div class="line">}</div>
</div><!-- fragment -->The initialise function above is used to initialise the FCST classes, however the FCST applications are built on a hierarchy of appframe classes that also have to be initialised. For that reason, the main program doesn't call the <code>_initialise</code> function described above, but <code>intialise</code> instead. This function will call the <code>_initialise</code> function but will also call the initialise function of the applications parent class, <a class="el" href="classAppFrame_1_1OptimizationBlockMatrixApplication.html">OptimizationBlockMatrixApplication </a>. This has its own initialise function that will initialise its classes, and also call the initialise function of its parent class, <a class="el" href="classAppFrame_1_1BlockMatrixApplication.html">BlockMatrixApplication </a>. This continues on to <a class="el" href="classAppFrame_1_1DoFApplication.html">DoFApplication </a> and <a class="el" href="classAppFrame_1_1ApplicationBase.html">ApplicationBase </a>.<div class="fragment"><div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line"><a class="code" href="namespaceAppFrame.html#a845ddd93d0345c2f7012e0ff4c0acd82" title="General initialization of the AppFrame in order to simplify main functions.">NAME::AppCathode&lt;dim&gt;::initialize</a>(ParameterHandler&amp; param)</div>
<div class="line">{</div>
<div class="line"> <a class="code" href="namespaceAppFrame.html#a845ddd93d0345c2f7012e0ff4c0acd82" title="General initialization of the AppFrame in order to simplify main functions.">OptimizationBlockMatrixApplication&lt;dim&gt;::initialize</a>(param);</div>
<div class="line"> _initialize(param);</div>
<div class="line">}</div>
</div><!-- fragment -->The grid can be initialized in two ways. If we have a mesh from a file (i.e. read_grid_from_file == true) or we have a mesh from a previous simulation (this-&gt;read_in_initial_solution == true), e.g. if running a polarization curve, then, the previous mesh can be read from file and used to initialize the mesh. <br/>
 Otherwise, use our boost::shared_ptr&lt; FuelCellShop::Geometry::GridBase&lt;dim&gt; &gt; object to generate the mesh using grid-&gt;generate_grid(*this-&gt;tr);<div class="fragment"><div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">NAME::AppCathode&lt;dim&gt;::initialize_grid(ParameterHandler&amp; param)</div>
<div class="line">{</div>
<div class="line">   </div>
<div class="line">grid = <a class="code" href="classFuelCellShop_1_1Geometry_1_1GridBase.html#a948b34d84151e90059185709259b9819">FuelCellShop::Geometry::GridBase&lt;dim&gt;::create_GridGenerator</a> (param);</div>
<div class="line">  </div>
<div class="line"><span class="comment">// Make sure that grid is appropriate for application</span></div>
<div class="line">AssertThrow (( (grid-&gt;get_mesh_type()).compare(<span class="stringliteral">&quot;Cathode&quot;</span>) == 0 || (grid-&gt;get_mesh_type()).compare(<span class="stringliteral">&quot;CathodeMPL&quot;</span>) == 0 || (grid-&gt;get_mesh_type()).compare(<span class="stringliteral">&quot;GridExternal&quot;</span>) == 0),</div>
<div class="line">ExcMessage(<span class="stringliteral">&quot;Only GridExternal, Cathode and CathodeMPL meshes are permitted for AppCathode. Check entry Type of mesh in subsection Grid generation in the parameter file&quot;</span>));</div>
<div class="line">   </div>
<div class="line"><span class="comment">// Check to see whether we are reading the grid from a file</span></div>
<div class="line"><span class="comment">// Must read grid if we are reading a stored solution</span></div>
<div class="line"> <span class="keywordtype">bool</span> read_grid_from_file = grid-&gt;read_from_file;</div>
<div class="line"></div>
<div class="line"><span class="comment">// If not reading from a grid from a previous solution,</span></div>
<div class="line"><span class="comment">//check whether we can use one from external source</span></div>
<div class="line"><span class="keywordflow">if</span> (this-&gt;read_in_initial_solution || read_grid_from_file)</div>
<div class="line">{</div>
<div class="line">      <span class="comment">//Read grid_file name and format from parameter handler</span></div>
<div class="line">       std::ifstream grid_file(<span class="stringliteral">&quot;._mesh_to_be_transfered.msh&quot;</span>);</div>
<div class="line">       <span class="keywordflow">if</span>(!grid_file.fail())</div>
<div class="line">       {</div>
<div class="line">           deallog &lt;&lt; <span class="stringliteral">&quot;Reading grid from file&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">           GridIn&lt;dim&gt; grid_in;</div>
<div class="line">           grid_in.attach_triangulation(*this-&gt;tr);</div>
<div class="line">           grid_in.read_msh(grid_file);</div>
<div class="line">           grid_file.close();</div>
<div class="line">           read_grid_from_file = <span class="keyword">true</span>;</div>
<div class="line">       }</div>
<div class="line">       <span class="keywordflow">else</span></div>
<div class="line">       {</div>
<div class="line">           <span class="comment">// if grid fails to read, generate standard grid, don&#39;t read initial solution</span></div>
<div class="line">           deallog &lt;&lt; <span class="stringliteral">&quot;Grid file not available for reading&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">           read_grid_from_file = <span class="keyword">false</span>;</div>
<div class="line">           this-&gt;read_in_initial_solution = <span class="keyword">false</span>;</div>
<div class="line">       }</div>
<div class="line">   }</div>
<div class="line">   <span class="keywordflow">if</span>(!read_grid_from_file)</div>
<div class="line">   {</div>
<div class="line">       deallog &lt;&lt; <span class="stringliteral">&quot;Generating new grid&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">       grid-&gt;generate_grid(*this-&gt;tr);</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment -->To actually generate a grid using deal.ii, an object of type <a href="http://www.dealii.org/7.0.0/doxygen/deal.II/group__grid.html">triangulation</a> is used (here its pointed to by <code>this-&gt;tr</code>). This is a deal.II object that contains information about the geometric and topological properties of a mesh, for example the location of vertices of the cell and how they are connected. The same triangulation object is also used while reading grid from file.The geometries class contains a number of methods for generating a grid depending on whether we are running a cathode, pemfc, anode with MPL etc. simulation. In this case we are running a simple cathode catalyst layer with GDL/MPL simulation. <code>generate_grid</code> will take the dimensions of the fuel cell and divide it up into a mesh depending on how many horizontal and vertical divisions we set. Then it will loop over all cells and their vertices and assign material and boundary ids according to how far a vertex is from the origin in the horizontal direction. Optionally, the grid will then be refined once. <br/>
 <br/>
The last part of the setting up the simulation involves providing information about the initial solution to the nonlinear solver. This is done with the <a class="el" href="classFuelCell_1_1Application_1_1AppCathode.html#ab9fa974ae9a38115da6fcbf0a7780206">init_solution </a> function. </p>
<div class="fragment"><div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">NAME::AppCathode&lt;dim&gt;::init_solution(<a class="code" href="classBlockVector.html">AppFrame::FEVector</a>&amp; dst)</div>
<div class="line">{</div>
</div><!-- fragment --><p> The operating molar fraction of oxygen in the channel and voltage cell are first read from operating_conditions class. </p>
<div class="fragment"><div class="line"><span class="comment">// Obtain the oxygen concentration in the channel and the</span></div>
<div class="line"><span class="comment">// cell potential:</span></div>
<div class="line"><span class="keywordtype">double</span> x_o2   = OC.get_x_o2();</div>
<div class="line"><span class="keywordtype">double</span> V_cell = - OC.get_V();</div>
</div><!-- fragment -->The vector <code>dst</code> has to be initialized to the initial solution. The first step is to resize the <code>dst</code> vector to the size of the solution vector. </p>
<div class="fragment"><div class="line"><span class="comment">// resize vector:</span></div>
<div class="line">dst.reinit(this-&gt;block_info.global);</div>
</div><!-- fragment -->To input the initial solution to the solution vector, two functions are created called function_map and component_mask. The former is used to relate a material ID to a function type. For example, for the catalyst layer material id, the oxygen concentration should be \( c_0 \).<div class="fragment"><div class="line"><span class="comment">// Create the function map for each variable and the component mask</span></div>
<div class="line">std::map&lt;types::material_id, const Function&lt;dim&gt;* &gt; function_map;</div>
<div class="line">std::vector&lt;bool&gt; component_mask(3, <span class="keyword">false</span>);</div>
</div><!-- fragment -->We will use a piece-wise constant function as the initial solution. The solution will be constant within each layer and will change in value between layers. Therefore, we need the functions that will provide the value of the solution at each point in the mesh. These functions are defined below and are given to the function_map such that the mole fraction in the GDL is the same as in the channel and MPL and catalyst layer contain half and a quarter of the oxygen respectively. function_map is used to identify the layer via material id.<div class="fragment"><div class="line"><span class="comment">// --- xo2 ---     </span></div>
<div class="line"><span class="keyword">const</span> ConstantFunction&lt;dim&gt; f_xo2_GDL(x_o2, 3);</div>
<div class="line"><span class="keyword">const</span> ConstantFunction&lt;dim&gt; f_xo2_MPL(x_o2/2.0, 3);</div>
<div class="line"><span class="keyword">const</span> ConstantFunction&lt;dim&gt; f_xo2_CL(x_o2/4.0, 3);</div>
<div class="line"></div>
<div class="line">function_map[CGDL-&gt;get_material_id()] = &amp;f_xo2_GDL;</div>
<div class="line">function_map[CMPL-&gt;get_material_id()] = &amp;f_xo2_MPL;</div>
<div class="line">function_map[CCL-&gt;get_material_id()] = &amp;f_xo2_CL;</div>
</div><!-- fragment -->Next, component_mask is used to identify the solution variable name for which the initial solution is being set up. Finally the deal.II function <a href="http://www.dealii.org/7.0.0/doxygen/deal.II/classVectorTools.html#a0fd1d3be6e35d67442f4d2e5a4864155">interpolate</a> is used to distribute the initial solution on the cell.<div class="fragment"><div class="line">std::vector&lt; std::string &gt; solution_names( system_management.get_solution_names () );</div>
<div class="line">       </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i&lt;solution_names.size(); i++)</div>
<div class="line">{</div>
<div class="line">   <span class="keywordflow">if</span> (solution_names[i] == <span class="stringliteral">&quot;oxygen_molar_fraction&quot;</span>)</div>
<div class="line">      component_mask[i] = <span class="keyword">true</span>;</div>
<div class="line">   <span class="keywordflow">else</span></div>
<div class="line">      component_mask[i] = <span class="keyword">false</span>;</div>
<div class="line"> }</div>
<div class="line"> VectorTools::interpolate( dst,</div>
<div class="line">                           this-&gt;mapping,</div>
<div class="line">                           this-&gt;dof,</div>
<div class="line">                           function_map,</div>
<div class="line">                           component_mask );</div>
</div><!-- fragment -->We repeat the same process for the electrolyte and electrical potential:<div class="fragment"><div class="line"><span class="comment">// --- fp ---</span></div>
<div class="line"><span class="keyword">const</span> ConstantFunction&lt;dim&gt; f_fp(0.0, 3);</div>
<div class="line">function_map[CGDL-&gt;get_material_id()] = &amp;f_fp;</div>
<div class="line">function_map[CMPL-&gt;get_material_id()] = &amp;f_fp;</div>
<div class="line">function_map[CCL-&gt;get_material_id()] = &amp;f_fp;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i&lt;solution_names.size(); i++)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (solution_names[i] == <span class="stringliteral">&quot;protonic_electrical_potential&quot;</span>)</div>
<div class="line">     component_mask[i] = <span class="keyword">true</span>;</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">     component_mask[i] = <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line">VectorTools::interpolate( dst,</div>
<div class="line">                          this-&gt;mapping,</div>
<div class="line">                          this-&gt;dof,</div>
<div class="line">                          function_map,</div>
<div class="line">                          component_mask );</div>
<div class="line"><span class="comment">// --- fe ---</span></div>
<div class="line"><span class="keyword">const</span> ConstantFunction&lt;dim&gt; f_fe(V_cell, 3);</div>
<div class="line">function_map[CGDL-&gt;get_material_id()] = &amp;f_fe;</div>
<div class="line">function_map[CMPL-&gt;get_material_id()] = &amp;f_fe;</div>
<div class="line">function_map[CCL-&gt;get_material_id()] = &amp;f_fe;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i&lt;solution_names.size(); i++)</div>
<div class="line">{</div>
<div class="line">   <span class="keywordflow">if</span> (solution_names[i] == <span class="stringliteral">&quot;electronic_electrical_potential&quot;</span>)</div>
<div class="line">     component_mask[i] = <span class="keyword">true</span>;</div>
<div class="line">   <span class="keywordflow">else</span></div>
<div class="line">     component_mask[i] = <span class="keyword">false</span>;</div>
<div class="line"> }</div>
<div class="line"> VectorTools::interpolate( dst,</div>
<div class="line">                           this-&gt;mapping,</div>
<div class="line">                           this-&gt;dof,</div>
<div class="line">                           function_map,</div>
<div class="line">                           component_mask );</div>
<div class="line"> }</div>
</div><!-- fragment -->Please note that our initial solution meets the Dirichlet boundary conditions. This is necessary when setting up the problem. <br/>
 <br/>
 The simulation has now been set up so we can start to work on the member functions that are used to assemble the local (element-wise) matrix and residual (right hand side). <br/>
 <br/>
 The two most important functions in the application are the <a class="el" href="classFuelCell_1_1Application_1_1AppCathode.html#ab512dff1fe18f13513cef0207bdcbdb7">cell_matrix </a> and <a class="el" href="classFuelCell_1_1Application_1_1AppCathode.html#ac8843b8c92db8fb767a76d0958cd94c6">cell_residual </a> functions. The functions provide the coefficients for the left and right hand side of our linearised system of equations respectively ( \(\frac{dR(u,p)}{du}(-\delta u) = R(u,p)\)). <br/>
 <br/>
 We will start with the <a class="el" href="classFuelCell_1_1Application_1_1AppCathode.html#ab512dff1fe18f13513cef0207bdcbdb7">cell_matrix </a> function which implements the integration of the local bilinear form. Here we loop over the quadrature points and over degrees of freedom in order to compute the matrix for the cell. This routine depends on the problem at hand and is called in <a class="el" href="classAppFrame_1_1BlockMatrixApplication.html#a70393cd173480f29244d5f8bb0434eb4">assemble </a> in BlockMatrixApplication class. <br/>
 <br/>
 In this case, the matrix to be assembled is given below: </p>
<p class="formulaDsp">
\begin{eqnarray} M(i,j).block(0) &amp; = &amp; \int_{\Omega} a \nabla \phi_i \nabla \phi_j d\Omega + \int_{\Omega} \phi_i \frac{\partial f}{\partial u_0}\Big|_n \phi_j d\Omega \quad \qquad &amp; M(i,j).block(1) &amp; = &amp; \int_{\Omega} \phi_i \frac{\partial f}{\partial u_1}\Big|_n \phi_j d\Omega &amp; M(i,j).block(2) &amp; = &amp; \int_{\Omega} \phi_i \frac{\partial f}{\partial u_2}\Big|_n \phi_j d\Omega \\ M(i,j).block(3) &amp; = &amp; \int_{\Omega} \phi_i \frac{\partial f}{\partial u_0}\Big|_n \phi_j d\Omega &amp; M(i,j).block(4) &amp; = &amp; \int_{\Omega} a \nabla \phi_i \nabla \phi_j d\Omega + \int_{\Omega} \phi_i \frac{\partial f}{\partial u_1}\Big|_n \phi_j d\Omega \quad \qquad &amp; M(i,j).block(5) &amp; = &amp; \int_{\Omega} \phi_i \frac{\partial f}{\partial u_2}\Big|_n \phi_j d\Omega \\ M(i,j).block(6) &amp; = &amp; \int_{\Omega} \phi_i \frac{\partial f}{\partial u_0}\Big|_n \phi_j d\Omega &amp; M(i,j).block(7) &amp; = &amp; \int_{\Omega} \phi_i \frac{\partial f}{\partial u_1}\Big|_n \phi_j d\Omega&amp; M(i,j).block(8) &amp; = &amp; \int_{\Omega} a \nabla \phi_i \nabla \phi_j d\Omega + \int_{\Omega} \phi_i \frac{\partial f}{\partial u_2}\Big|_n \phi_j d\Omega \end{eqnarray}
</p>
<p> <br/>
 <br/>
OpenFCST already contains many equation classes which are used to assemble the local cell matrices. Therefore, assembling the matrices is extremely simple. Simply call the Equation classes you want to solve! <br/>
 <code>cell_matrix</code> receives a MatrixVector object containing a vector of local matrices corresponding to all the non-zero matrices in the global matrix such that cell_matrices[0] corresponds to M(i,j).block(0), and a <code>CellInfo</code> object that </p>
<div class="fragment"><div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> </div>
<div class="line">NAME::AppCathode&lt;dim&gt;::cell_matrix(<a class="code" href="namespaceAppFrame.html#a2fc5775dc17d00e302c32dc222c5d6d3" title="The matrix vector handed to the local integration routines in MatrixApplication::assemble().">MatrixVector</a>&amp; cell_matrices,</div>
<div class="line">                                   <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFApplication.html">DoFApplication&lt;dim&gt;::CellInfo</a>&amp; info)</div>
<div class="line">{</div>
</div><!-- fragment -->In this case, we solve a different set of equations for each layer. In the gas diffusion layer, we solve for Fick's law of diffusion and electron transport. Therefore, we can ask our Equation classes to assemble the local matrices for GDL cells using the information provided by the CGDL class. <br/>
 A particular layer is identified through its material id for any particular cell. The information of material id is accessed using the member function material_id() in the <a class="el" href="">info </a> object. <br/>
 Equation classes such as <code>ficks_transport_equation</code>, <code>electron_transport_equation</code>,<code> proton_transport_equation</code> and <code>reaction_source</code> have an inbuilt function <code>assemble_cell_matrix</code> which assembles the local matrix and passes the local matrix to the MatrixVector which is a vector of local matrices, it assembles the local matrices and make them global. The call to <code>assemble_cell_matrix</code> will return M(i,j).block(0) filled based on the properties of the cell and the CGDL.<div class="fragment"><div class="line"><span class="keywordflow">if</span> (CGDL-&gt;belongs_to_material(info.cell-&gt;material_id()))</div>
<div class="line">   { </div>
<div class="line">       ficks_transport_equation.assemble_cell_matrix(cell_matrices, info, CGDL.get());</div>
<div class="line">       electron_transport_equation.assemble_cell_matrix(cell_matrices, info, CGDL.get());</div>
<div class="line">   }</div>
</div><!-- fragment -->The same process can be applied the MPL: </p>
<div class="fragment"><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (CMPL-&gt;belongs_to_material(info.cell-&gt;material_id()))</div>
<div class="line">   { </div>
<div class="line">       ficks_transport_equation.assemble_cell_matrix(cell_matrices, info, CMPL.get());</div>
<div class="line">       electron_transport_equation.assemble_cell_matrix(cell_matrices, info, CMPL.get());</div>
<div class="line">   }</div>
</div><!-- fragment -->For the catalyst layer, we wish to solve not only for oxygen and electron transport but also for proton transport and for the reaction terms. Therefore, all four Equation objects are called in order to provide the required information in cell_matrices.<div class="fragment"><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (CCL-&gt;belongs_to_material(info.cell-&gt;material_id()))</div>
<div class="line">   {</div>
<div class="line">       ficks_transport_equation.assemble_cell_matrix(cell_matrices, info, CCL.get());</div>
<div class="line">       electron_transport_equation.assemble_cell_matrix(cell_matrices, info, CCL.get());</div>
<div class="line">       proton_transport_equation.assemble_cell_matrix(cell_matrices, info, CCL.get());</div>
<div class="line">       reaction_source.assemble_cell_matrix(cell_matrices, info, CCL.get());</div>
<div class="line">   }</div>
</div><!-- fragment -->Finally, if the mesh contains cells with a material ID that does not correspond to any of the layers defined in the application, we will ask the program to provide an error message: </p>
<div class="fragment"><div class="line">   <span class="keywordflow">else</span></div>
<div class="line">   {</div>
<div class="line">       deallog&lt;&lt;<span class="stringliteral">&quot;Material id: &quot;</span>    &lt;&lt;info.cell-&gt;material_id()&lt;&lt;<span class="stringliteral">&quot; does not correspond to any layer&quot;</span>&lt;&lt;std::endl;</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment -->Using the process specified above, local cell matrices are formed for all three layers and equations. <br/>
 <br/>
 This completes the <code>cell_matrix</code> function. We can now move onto the <code>cell_residual</code> and the right hand side (RHS). <br/>
 <br/>
 The <a class="el" href="classFuelCell_1_1Application_1_1AppCathode.html#ac8843b8c92db8fb767a76d0958cd94c6">cell_residual </a> function works similarly to the <code>cell_matrix</code> member function. The main difference is that in constructing the RHS we are not assembling a matrix, but a vector, which is why <code>cell_vector</code> is passed in the <code>cell_residual</code> function call. <br/>
 The vector were are constructing is given by: </p>
<p class="formulaDsp">
\[ R(i),block(i) = \int_{\Omega} \phi_j a (\nabla u)^n d\Omega + \int_{\Omega} \phi_j f(u^n) d\Omega \]
</p>
<p> <br/>
 In our case this can be written as: </p>
<p class="formulaDsp">
\begin{eqnarray} R(i),block(0) &amp; = &amp; \int_{\Omega} \phi_j D_{O_2} (\nabla x_{O_2})^n d\Omega + \int_{\Omega} \phi_j \left( \frac{i(u^n)}{4F} \right) d\Omega \\ R(i),block(1) &amp; = &amp; \int_{\Omega} \phi_j \sigma_m (\nabla \phi_m)^n d\Omega + \int_{\Omega} \phi_j \left( \frac{i(u^n)}{F} \right) d\Omega \\ R(i),block(2) &amp; = &amp; \int_{\Omega} \phi_j \sigma_s (\nabla \phi_m)^n d\Omega + \int_{\Omega} \phi_j \left( \frac{i(u^n)}{-F} \right) d\Omega \end{eqnarray}
</p>
<p> where \( u^n \) is the solution at the \( n \) iteration in the Newton loop. <br/>
 <br/>
 <code>cell_residual</code> takes two arguments, a <a class="el" href="classBlockVector.html">BlockVector</a> that should be initialized to the local right hand side, i.e. element-wise right hand side, and a CellInfo object that contains information regarding the cell finite element, material id, boundary id and the solution at the quadrature points in the cell. This information is used to setup the right hand side. <br/>
 As in <code>cell_matrix</code>, we first check at which material the cell belongs to and, based on its material id, we use the appropriate Equation class to assemble the right hand side. In this case, this is done by calling the member function <code>assemble_cell_residual</code>.<div class="fragment"><div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> </div>
<div class="line">NAME::AppCathode&lt;dim&gt;::cell_residual(<a class="code" href="classBlockVector.html">AppFrame::FEVector</a>&amp; cell_vector,</div>
<div class="line">                                     <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFApplication.html">DoFApplication&lt;dim&gt;::CellInfo</a>&amp; info)</div>
<div class="line">{ </div>
<div class="line"> <span class="comment">// -- Assertion before starting routine:</span></div>
<div class="line"> <span class="comment">// Make sure vectors are the right size</span></div>
<div class="line"> Assert (cell_vector.n_blocks() == this-&gt;element-&gt;n_blocks(),</div>
<div class="line">     ExcDimensionMismatch (cell_vector.n_blocks(), this-&gt;element-&gt;n_blocks()));</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (CGDL-&gt;belongs_to_material(info.cell-&gt;material_id()))</div>
<div class="line">   { </div>
<div class="line">       ficks_transport_equation.assemble_cell_residual(cell_vector, info, CGDL.get());</div>
<div class="line">       electron_transport_equation.assemble_cell_residual(cell_vector, info, CGDL.get());</div>
<div class="line">   }</div>
<div class="line">   <span class="keywordflow">else</span>  <span class="keywordflow">if</span> (CMPL-&gt;belongs_to_material(info.cell-&gt;material_id()))</div>
<div class="line">   { </div>
<div class="line">       ficks_transport_equation.assemble_cell_residual(cell_vector, info, CMPL.get());</div>
<div class="line">       electron_transport_equation.assemble_cell_residual(cell_vector, info, CMPL.get());</div>
<div class="line">    }</div>
<div class="line">   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (CCL-&gt;belongs_to_material(info.cell-&gt;material_id()))</div>
<div class="line">   {</div>
<div class="line">       ficks_transport_equation.assemble_cell_residual(cell_vector, info, CCL.get());</div>
<div class="line">       electron_transport_equation.assemble_cell_residual(cell_vector, info, CCL.get());</div>
<div class="line">       proton_transport_equation.assemble_cell_residual(cell_vector, info, CCL.get());</div>
<div class="line">       reaction_source.assemble_cell_residual(cell_vector, info, CCL.get());</div>
<div class="line">    }</div>
<div class="line">   <span class="keywordflow">else</span></div>
<div class="line">   {</div>
<div class="line">       deallog&lt;&lt;<span class="stringliteral">&quot;Material id: &quot;</span>    &lt;&lt;info.cell-&gt;material_id()&lt;&lt;<span class="stringliteral">&quot; does not correspond to any layer&quot;</span>&lt;&lt;std::endl;</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment -->Next, we need to define the boundary conditions for the three solution variables. Note that since we are solving a linearized system, the boundary conditions are not for the solution variables oxygen mole fraction, electrical and proton potential, but for their variation, i.e. \( \delta u \) instead of \( u \). Therefore, the variation of each boundary conditon of the nonlinear problem needs to be implemented here. <br/>
 <br/>
Dirichlet boundary conditions on the solution variables have a variation of zero, i.e. if the initial solution satisfies the boundary conditions, the Dirichlet boundary conditions on the variations are that the variation should be zero. <br/>
 <br/>
Imposing a zero Dirichlet boundary condition is done by the <a class="el" href="classFuelCell_1_1Application_1_1AppCathode.html#ad6b845323128fc024dbfc8479a2fa418">dirichlet_bc </a> function. This function fills a std::map named boundary_values with an unsigned int representing the degree of freedom and the Dirichlet value of the boundary condition. In this case, all Dirichlet boundaries will have a zero value.<div class="fragment"><div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> </div>
<div class="line">NAME::AppCathode&lt;dim&gt;::dirichlet_bc(std::map&lt;unsigned int, double&gt;&amp; boundary_values)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
</div><!-- fragment -->We will analyze one boundary at a time. The boundaries are identified using boundary ids, which are integer numbers that are specified when constructing the mesh. Boundary ids are stored in the grid class and are accessed using the <code>get_boundary_id</code> function by passing a string that identifies the requested boundary. In the code below, we want to apply a boundary condition at the membrane/catalyst layer interface. <br/>
 <br/>
 The boundary values can be applied to any of the solution variables. For the case of the membrane/catalyst layer interface we would like to apply a Dirichlet boundary conditon to the electrolyte potential, i.e. the Protonic electrical potential variable, since the potential there is specified. The oxygem mole fraction and electrical potential are not specified at that interface. The <code>comp_mask</code> vector is used to denote whether a solution variable should be specified or not. Therefore, we set the comp_mask corresponding to the proton potential to true, while the others are set to false.We have now identified the variable we want to apply the boundary conditions to and we now need to fill out the boundary_values. To setup the values at each degree of freedom the deal.II function <a href="http://www.dealii.org/7.3.0/doxygen/deal.II/classVectorTools.html#ae81c0e62e5bdfae7f3805c0109542c0c">interpolate_boundary_values</a>, is used. This function takes the <a class="el" href="classDoFHandler.html">DoFHandler</a> stored in *this-&gt;dof, the boundary id, a function which is used to compute the value a the boundary and a comp_mask and it returns boundary_values. <br/>
 <br/>
 In this case, since we want the Dirichlet boundary on the variation of the solution to be zero, we use the deal.II function ZeroFunction&lt;dim&gt;(this-&gt;element-&gt;n_blocks()) which returns zero for any block.<div class="fragment"><div class="line">std::vector&lt;bool&gt; comp_mask (this-&gt;element-&gt;n_blocks(), <span class="keyword">false</span>);</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;</div>
<div class="line"></div>
<div class="line"><span class="comment">// -- boundary component 1: membrane/catalyst layer interface</span></div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">for</span> (i = 0; i &lt; component_names.size(); ++i)</div>
<div class="line">  {</div>
<div class="line">      <span class="keywordflow">if</span> (component_names[i] == <span class="stringliteral">&quot;Protonic electrical potential&quot;</span>)</div>
<div class="line">      {</div>
<div class="line">          comp_mask[i] = <span class="keyword">true</span>;</div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">       }</div>
<div class="line">   }</div>
<div class="line">  VectorTools::interpolate_boundary_values (*this-&gt;dof,</div>
<div class="line">                                            grid-&gt;get_boundary_id(<span class="stringliteral">&quot;c_CL/Membrane&quot;</span>),</div>
<div class="line">                                            ZeroFunction&lt;dim&gt;(this-&gt;element-&gt;n_blocks()),</div>
<div class="line">                                            boundary_values,</div>
<div class="line">                                            comp_mask);</div>
</div><!-- fragment -->For the other two boundary conditions the same process if followed. Since we used a <code> break</code> command once a variable is set to true, then, we reset it to false and then set to true the variable of interest for each boundary condition we want to apply. <br/>
 <br/>
 The area under the rib is in contact with the end plate and therefore allows the transport of electrons, while the area under the gas channel allows the transport of oxygen. The <code>comp_mask</code> is updated each time to reflect this, before calling the <code>interpolate_boundary_values</code> function again. Another function, <a href="http://www.dealii.org/7.0.0/doxygen/deal.II/classMatrixTools.html#aa91cdf2c22c5fbf9dc5e450fa67eb05e">apply_boundary_values</a>, will be used later to apply the BCs to the system matrix.<div class="fragment"><div class="line"><span class="comment">// -- boundary component 2: area underneath ribs</span></div>
<div class="line">comp_mask[i] = <span class="keyword">false</span>; </div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> (this-&gt;boundary_fluxes == <span class="keyword">false</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; component_names.size(); ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (component_names[i] == <span class="stringliteral">&quot;Electronic electrical potential&quot;</span>)</div>
<div class="line">        {</div>
<div class="line">            comp_mask[i] = <span class="keyword">true</span>;</div>
<div class="line">            <span class="keywordflow">break</span>;    </div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    VectorTools::interpolate_boundary_values (*this-&gt;dof,</div>
<div class="line">                                                 grid-&gt;get_boundary_id(<span class="stringliteral">&quot;c_BPP/GDL&quot;</span>),</div>
<div class="line">                                                 ZeroFunction&lt;dim&gt;(this-&gt;element-&gt;n_blocks()),</div>
<div class="line">                                                 boundary_values,</div>
<div class="line">                                                 comp_mask);</div>
<div class="line">}</div>
<div class="line"><span class="comment">// -- boundary component 3: area underneath gas channel</span></div>
<div class="line"><span class="comment">// No Dirichlet boundary conditions for phases but we have Dirichlet BC for gas composition. Since for the linear</span></div>
<div class="line"><span class="comment">//system we solve for delta_u, the dirichlet BC for delta_u are to have the value to be zero</span></div>
<div class="line">comp_mask[i] = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; component_names.size(); ++i)</div>
<div class="line">   {</div>
<div class="line">       <span class="keywordflow">if</span> (component_names[i] == <span class="stringliteral">&quot;Oxygen molar fraction&quot;</span>)</div>
<div class="line">       {</div>
<div class="line">           comp_mask[i] = <span class="keyword">true</span>;</div>
<div class="line">           <span class="keywordflow">break</span>;</div>
<div class="line">       }</div>
<div class="line">   }</div>
<div class="line">   VectorTools::interpolate_boundary_values (*this-&gt;dof,</div>
<div class="line">                                             grid-&gt;get_boundary_id(<span class="stringliteral">&quot;c_Ch/GDL&quot;</span>),</div>
<div class="line">                                             ZeroFunction&lt;dim&gt;(this-&gt;element-&gt;n_blocks()),</div>
<div class="line">                                             boundary_values,</div>
<div class="line">                                             comp_mask);</div>
<div class="line">}</div>
</div><!-- fragment -->Now that system of equations has been set up and the boundary conditions applied, we can develop <code>solve</code> function. <br/>
 <br/>
 The <a class="el" href="classFuelCell_1_1Application_1_1AppCathode.html#a182bbf5eee483cc13fce5a4402bd0fd1">solve </a> function is called from the Newton solver to solve our system of equations. The assembly is not actually done in this function, this is handled by <a class="el" href="namespaceAppFrame.html" title="Functions and classes of the application framework.">AppFrame</a>. The residual is computed by the <a class="el" href="classAppFrame_1_1DoFApplication.html">DoFApplication </a>, a parent of the application class. This class will assemble the RHS for the whole fuel cell, but as we have seen it will need to call <code>cell_residual</code> from our application in order to get the coefficients from a single cell. Similarly, the stiffness matrix is assembled by the <a class="el" href="classAppFrame_1_1BlockMatrixApplication.html">BlockMatrixApplication </a> class and it will call the <code>cell_matrix</code> function from our application when assembling the matrix for the whole fuel cell.The <a class="el" href="classFuelCell_1_1Application_1_1AppCathode.html#a182bbf5eee483cc13fce5a4402bd0fd1">solve </a> function has two input variables. The FEVector (start) is where the solution will be stored after solving the problem. The FEVectors is a collection of vectors and is where the solution and the right hand side are stored. <br/>
 <br/>
 Note that <a class="el" href="classAppFrame_1_1FEVectors.html">FEVectors </a> is a collection of pointers to <a href="http://www.dealii.org/7.0.0/doxygen/deal.II/classBlockVector.html">BlockVector </a> objects. This individual vectors that are being pointed to are labelled with a string which allows us to access them later. The <code>FEVector</code> is simply a single <code><a class="el" href="classBlockVector.html">BlockVector</a></code> object. Newton solver creates the <code>rhs</code> and uses it to contain the solution vector and the residual vector.<div class="fragment"><div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> </div>
<div class="line">NAME::AppCathode&lt;dim&gt;::solve(<a class="code" href="classBlockVector.html">AppFrame::FEVector</a>&amp; start,</div>
<div class="line">                             <span class="keyword">const</span> <a class="code" href="classAppFrame_1_1FEVectors.html" title="The data type used in function calls of Application.">AppFrame::FEVectors</a>&amp; rhs)</div>
<div class="line">{</div>
</div><!-- fragment -->The first step is to assemble our global matrix. Assembling the global system however is not always necessary. Specially if the change in the residual at the Newton iteration is very small. Therefore, we ask using notification if the system needs to be assembled. <br/>
 Notifications is setup in the nonlinear solver which can tell the application not to update the system matrix so it will not enter the block below. In most case, the global system needs to be assembled. </p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (this-&gt;notifications.any())<span class="comment">//if (this-&gt;assemble_reasons)</span></div>
<div class="line">{</div>
</div><!-- fragment -->In order to assemble the global system, we call the assemble member function from the parent <code>BlockMatrixApplication</code>. Assemble needs the solution at the pervious Netwon step, therefore, before calling assemble, we extract the solution vector from the <code>rhs</code> FEVectors object by searching for the vector corresponding to the "Newton iterate" string. Then we call the assemble function in the <code>BlockMatrixApplication</code> class which will assemble the system matrix before clearing any notifications. </p>
<div class="fragment"><div class="line">  <a class="code" href="classAppFrame_1_1FEVectors.html" title="The data type used in function calls of Application.">AppFrame::FEVectors</a> sol;</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ind = rhs.<a class="code" href="classAppFrame_1_1FEVectors.html#ae272ffefa15dc99a17d3938551626be9" title="Find index of a named vector.">find_vector</a>(<span class="stringliteral">&quot;Newton iterate&quot;</span>);</div>
<div class="line">  sol.<a class="code" href="classAppFrame_1_1FEVectors.html#aafb2498d05dc1e2ef90194802b0bf339" title="Add a new vector to the end of the collection.">add_vector</a>(rhs.<a class="code" href="classAppFrame_1_1FEVectors.html#a4d13d31ddbd66c782408acab7279b626" title="Access to a vector stored.">vector</a>(ind),<span class="stringliteral">&quot;Newton iterate&quot;</span>);</div>
<div class="line">  this-&gt;assemble(sol); <span class="comment">//Note the second component of</span></div>
<div class="line">  this-&gt;notifications.clear();<span class="comment">//this-&gt;clear_assemble();</span></div>
<div class="line">}</div>
</div><!-- fragment -->After the global matrix is assembled, the next step is ensuring that our matrix is not singular using the <a class="el" href="classSolverUtils.html" title="This class is used to include routines that are used in the solve() routine of several applications s...">SolverUtils</a> class. Since not all equations are solved in all domains the <code>repair_diagonal</code> function will search the main diagonal and if it finds a zero element, and the corresponding RHS value is zero, it will replaced the zero on the diagonal with an average value from diagonal elements. This is equivalent to adding an equation of type \( \delta u_{DOF,i} = 0\). This is necessary to remove the equations for the domains for which an equation is not solved and it does not affect the solution. Since both the RHS and LHS are zero, adding a 1 in the diagonal is equivalent to saying that the solution should not be updated in that region.<div class="fragment"><div class="line"><span class="comment">// Eliminate zeros in the diagonal</span></div>
<div class="line"><a class="code" href="classSolverUtils.html" title="This class is used to include routines that are used in the solve() routine of several applications s...">SolverUtils</a> diagonal;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index_Newton_iterate = rhs.<a class="code" href="classAppFrame_1_1FEVectors.html#ae272ffefa15dc99a17d3938551626be9" title="Find index of a named vector.">find_vector</a>(<span class="stringliteral">&quot;Newton iterate&quot;</span>);</div>
<div class="line">diagonal.<a class="code" href="classSolverUtils.html#a1ed2e7ed77e8a9ca065d4d01d3dcd245" title="This member function is used to make sure that the BlockSpareMatrix has no zeros in the diagonal...">repair_diagonal</a>(this-&gt;matrix, start, rhs.<a class="code" href="classAppFrame_1_1FEVectors.html#a4d13d31ddbd66c782408acab7279b626" title="Access to a vector stored.">vector</a>(index_Newton_iterate));</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Copy RHS to solution vector</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index_Newton_residual = rhs.<a class="code" href="classAppFrame_1_1FEVectors.html#ae272ffefa15dc99a17d3938551626be9" title="Find index of a named vector.">find_vector</a>(<span class="stringliteral">&quot;Newton residual&quot;</span>);</div>
<div class="line">start = rhs.<a class="code" href="classAppFrame_1_1FEVectors.html#a4d13d31ddbd66c782408acab7279b626" title="Access to a vector stored.">vector</a>(index_Newton_residual);</div>
</div><!-- fragment -->Before we do anything else, we make sure that the start vector has been initialzed to the proper size. Here we compare the size of the solution at the previous time step to the vector where the variation of the solution, i.e. our solution to the linear system will be stored. </p>
<div class="fragment"><div class="line"><span class="comment">// Make sure that the solution is of the same size as the RHS</span></div>
<div class="line">Assert(start.size() == rhs.<a class="code" href="classAppFrame_1_1FEVectors.html#a4d13d31ddbd66c782408acab7279b626" title="Access to a vector stored.">vector</a>(index_Newton_iterate).size(),</div>
<div class="line">       ExcDimensionMismatch(start.size(), rhs.<a class="code" href="classAppFrame_1_1FEVectors.html#a4d13d31ddbd66c782408acab7279b626" title="Access to a vector stored.">vector</a>(index_Newton_iterate).size()));</div>
</div><!-- fragment -->Two linear solvers "UMFPACK" or "GMRES" can be used to solve the system of equations. <br/>
 <br/>
 <a href="http://www.cise.ufl.edu/research/sparse/umfpack/">UMFPACK </a> is a direct solver. It is robust and fast for problems that are fully coupled like in our case. Unfortunately, it has large memory requirements so it can only be used for small problems like a cathode in two dimensions. <br/>
 <br/>
GMRES is an iterative solver. It is one of the very few iterative solvers that can be used to solve non-symmetric, non-positive defined matrices, so we can use it here. In order to improve its performance it is recommeded to use a preconditioner. The preconditioners modies the global matrix to make it easier to solve in minimum number of iterations. GMRES is documented in the <a href="http://www.dealii.org/7.3.0/doxygen/deal.II/group__Solvers.html">solver class in deal.II</a>. <br/>
 <br/>
In this case we hardcoded UMFPACK as our solver so only that solver is explained below: </p>
<div class="fragment"><div class="line">std::string solver_name (<span class="stringliteral">&quot;UMFPACK&quot;</span>); <span class="comment">//(&quot;UMFPACK&quot;) | (&quot;ILU-GMRES&quot;);</span></div>
</div><!-- fragment -->If GMRES is used we simply setup a preconditioner and call GMRS to sovle the problem. Note that the matrix, with boundary conditions already applied is stored in this-&gt;filtred_matrix. </p>
<div class="fragment"><div class="line"><span class="comment">//*********** GMRES with ILU preconditioner *****</span></div>
<div class="line"><span class="keywordflow">if</span> (solver_name.compare(<span class="stringliteral">&quot;ILU-GMRES&quot;</span>) == 0) <span class="comment">//Could also use if (strcmp (solver_name,&quot;ILU-GMRES&quot;) == 0)</span></div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classLinearSolvers_1_1ILUPreconditioner.html" title="This class implements ILU preconditioner.">LinearSolvers::ILUPreconditioner</a> prec(this-&gt;matrix);</div>
<div class="line">  <a class="code" href="classLinearSolvers_1_1GMRESSolver.html" title="This class implements GMRES solver.">LinearSolvers::GMRESSolver</a> solver;</div>
<div class="line">  solver.<a class="code" href="classLinearSolvers_1_1GMRESSolver.html#ac66cf474e8af2be2f8e1eea29a98ef96" title="This function solves the linear system Ax = b where.">solve</a>( this-&gt;filtered_matrix,</div>
<div class="line">                start,</div>
<div class="line">                rhs.<a class="code" href="classAppFrame_1_1FEVectors.html#a4d13d31ddbd66c782408acab7279b626" title="Access to a vector stored.">vector</a>(index_Newton_residual),</div>
<div class="line">                10000,</div>
<div class="line">                1e-12,</div>
<div class="line">                prec.preconditioner );</div>
<div class="line">}</div>
</div><!-- fragment -->If solver "UMFPACK" we cannot use this-&gt;filtered_matrix since the interface to the solver only allows for BlockMatrices to be solved. Fortunately, in addition to this-&gt;filtred_matrix we also store the global matrix without the boundary conditions already applied to it, so we can use that matrix. <br/>
 <br/>
So for UMFPACK, we first apply the boundary conditions to this-&gt;matrix, the RHS and solution. The call <code>this-&gt;dirichlet_bc</code> is actually calling the function in our application as it is a pure function in BlockMatrixApplication, the parent class. The bcs are applied using the deal.II function <a href="http://www.dealii.org/7.0.0/doxygen/deal.II/classMatrixTools.html#a0552ec8c1d935455dc1ce6f096db342b">apply_boundary_values </a> <br/>
 <br/>
After applying the boundary conditions, we create an object of type <a class="el" href="classLinearSolvers_1_1SparseDirectUMFPACKSolver.html" title="This class implements an interface to the sparse direct solver UMFPACK, see the link below http://www...">LinearSolvers::SparseDirectUMFPACKSolver</a> and use it to solve the problem using the solve member function. Solve takes the global matrix and right hand side and returns the solution.<div class="fragment"><div class="line"><span class="comment">//*********** UMFPACK *****</span></div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (solver_name.compare(<span class="stringliteral">&quot;UMFPACK&quot;</span>) == 0)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Apply BC to matrix, rhs and sol</span></div>
<div class="line">  std::map&lt;unsigned int, double&gt; boundary_values;</div>
<div class="line">  this-&gt;dirichlet_bc(boundary_values);</div>
<div class="line"></div>
<div class="line">  MatrixTools::apply_boundary_values(boundary_values,</div>
<div class="line">                                     this-&gt;matrix,</div>
<div class="line">                                     start,</div>
<div class="line">                                     start);</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classLinearSolvers_1_1SparseDirectUMFPACKSolver.html" title="This class implements an interface to the sparse direct solver UMFPACK, see the link below http://www...">LinearSolvers::SparseDirectUMFPACKSolver</a> solver;</div>
<div class="line">  solver.<a class="code" href="classLinearSolvers_1_1SparseDirectUMFPACKSolver.html#ae9474b306fbedb8bf1070bac02e447c3" title="This function solves the linear system Ax = b where.">solve</a>(this-&gt;matrix,</div>
<div class="line">               start,</div>
<div class="line">               start);</div>
<div class="line">}</div>
</div><!-- fragment -->If you wish to implement another solver, you could do it here: </p>
<div class="fragment"><div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> std::type_info&amp; info = <span class="keyword">typeid</span>(*this);</div>
<div class="line">  deallog&lt;&lt;<span class="stringliteral">&quot;Solver not implemented in Class &quot;</span>&lt;&lt;info.name()&lt;&lt;<span class="stringliteral">&quot;. Member function solve()&quot;</span>&lt;&lt;std::endl;</div>
<div class="line">  abort();</div>
<div class="line">}</div>
</div><!-- fragment -->Finally, for adaptive refinement we need to take care of the solution at hanging ndes. This is done using the deal.II function distribute. </p>
<div class="fragment"><div class="line"></div>
<div class="line"><span class="comment">// Distribute solution:</span></div>
<div class="line"><span class="comment"></span><span class="comment">//Return the solution to all the nodes taking into accout the hanging nodes</span></div>
<div class="line">this-&gt;hanging_node_constraints.distribute(start);</div>
</div><!-- fragment --><br/>
 <br/>
 The next function to consider is the <a class="el" href="classFuelCell_1_1Application_1_1AppCathode.html#a1a515a02a50aac048186be46ebc2e431">estimate </a> function. This is used by the adaptive refinement class to find the cells that need coarsening or refining. The member function takes the FEVectors with the solution and uses it to compute an internal variable <code>this-&gt;cell_errors</code> which estimates the error in each cell using an a posteriori error estimator. </p>
<div class="fragment"><div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">double</span> </div>
<div class="line">NAME::AppCathode&lt;dim&gt;::estimate(<span class="keyword">const</span> <a class="code" href="classAppFrame_1_1FEVectors.html" title="The data type used in function calls of Application.">AppFrame::FEVectors</a>&amp; vectors)</div>
<div class="line">{ </div>
</div><!-- fragment --><p> The FEVectors object passed to the function is defined in the adaptive refinement class simply as the solution vector. This function will approximate the error per cell using the Kelly error estimator. The basic principle behind the estimator is to observe the jumps in the gradients of the solution over the faces of the cells, in effect measuring the local smoothness of the solution at each cell. This difference is stored in a <a class="el" href="classVector.html">Vector</a> object called <code>cell_errors</code>, a member function of <a class="el" href="classDoFApplication.html">DoFApplication</a>. This will be used later by the remesh function to choose the cells in most need of refining or coarsening. <br/>
 <br/>
 The first step is to resize the <code>cell_errors</code> <a class="el" href="classVector.html">Vector</a> to be the size of the number of active cells in the entire. </p>
<div class="fragment"><div class="line"><span class="comment">// Reinitialize error estimator vector and set Newmann boundaries:</span></div>
<div class="line">this-&gt;cell_errors.reinit(this-&gt;tr-&gt;n_active_cells());</div>
</div><!-- fragment -->Then, we extract the solution from the <code>vectors</code> and store it in the required object. </p>
<div class="fragment"><div class="line"><span class="comment">// Extract soluton from FEVectors</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ind = vectors.<a class="code" href="classAppFrame_1_1FEVectors.html#ae272ffefa15dc99a17d3938551626be9" title="Find index of a named vector.">find_vector</a>(<span class="stringliteral">&quot;Solution&quot;</span>);</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>&amp; sol = vectors.<a class="code" href="classAppFrame_1_1FEVectors.html#a4d13d31ddbd66c782408acab7279b626" title="Access to a vector stored.">vector</a>(ind);</div>
</div><!-- fragment -->The next step is to use a vector of bools, <code>comp_mask</code> to choose which of our solution variables will be used to compute the error estimator: </p>
<div class="fragment"><div class="line"><span class="comment">//component_mask denote which components of the finite element space shall be used to </span></div>
<div class="line"><span class="comment">//compute the error estimator. If it is left as specified by the default value (i.e. an empty array), all components are </span></div>
<div class="line"><span class="comment">//used.</span></div>
<div class="line">std::vector&lt;bool&gt; comp_mask (this-&gt;element-&gt;n_blocks());</div>
<div class="line"></div>
<div class="line"><span class="comment">// Set refinement flags for material_id = 1</span></div>
<div class="line"><span class="comment">// -- material_id 1: catalyst layer</span></div>
<div class="line">  comp_mask[0] = <span class="keyword">true</span>; <span class="comment">// - comp 1 = x02</span></div>
<div class="line">  comp_mask[1] = <span class="keyword">true</span>; <span class="comment">//true;</span></div>
<div class="line">  comp_mask[2] = <span class="keyword">true</span>; <span class="comment">//true; // - comp 2 = phi_m (membrane phase potential)</span></div>
</div><!-- fragment -->Here we are setting the mask so that the first of the solution variables will be used, i.e. the oxygen molar fraction.Finally, we call the KellyErrorEstimator in deal.II. The estimate function needs a map that describes the location of the Neumann boundary conditions and their values. However in this case we do not have Neumann boundary conditions, so we pass an empty object of type function map. This function will now call the estimate function from the deal.II <a href="http://www.dealii.org/7.0.0/doxygen/deal.II/classKellyErrorEstimator.html">KellyErrorEstimator </a> class. </p>
<div class="fragment"><div class="line"> KellyErrorEstimator&lt;dim&gt;::estimate(*this-&gt;dof,</div>
<div class="line">                                     QGauss&lt;dim-1&gt;(3),</div>
<div class="line">                                     <span class="keyword">typename</span> FunctionMap&lt;dim&gt;::type(),</div>
<div class="line">                                     sol, </div>
<div class="line">                                     this-&gt;cell_errors,</div>
<div class="line">                                     comp_mask);</div>
<div class="line"> </div>
<div class="line"> <span class="keywordflow">return</span> 0.0; </div>
<div class="line">}</div>
</div><!-- fragment -->These are all the classes that are needed by the solver and adaptive refinement loop, the last function to be implemented is the post-processing routine. <br/>
 <br/>
 <code>data_out</code> is used to create the .vtk files that will be used to visualise our solution in Paraview. This member fuction takes a string with the name of the output file we would like to create and the FEVectors object with the solution. </p>
<div class="fragment"><div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> </div>
<div class="line">NAME::AppCathode&lt;dim&gt;::data_out(<span class="keyword">const</span> std::string &amp;basename, </div>
<div class="line">                                <span class="keyword">const</span> <a class="code" href="classAppFrame_1_1FEVectors.html" title="The data type used in function calls of Application.">AppFrame::FEVectors</a> &amp;vectors)</div>
<div class="line">{             </div>
</div><!-- fragment -->When calling this function in adaptive_refinement, we pass the name of data we wish to print out. Once a simulation has run the code will print out both the grid and the solution .vtk files at each refinement level. In data out we are creating the vtk files so we pass the string "fuel_cell-sol-cycle" plus the cycle number of the adaptive refinement loop. We also pass the <code>FEVectors</code> object that contains the solution and the residual.The step in the code is to extract the solution vector from the <code>FEVectors</code> object: </p>
<div class="fragment"><div class="line"><span class="comment">// Read the solution vector out of the many vectors:</span></div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = vectors.<a class="code" href="classAppFrame_1_1FEVectors.html#ae272ffefa15dc99a17d3938551626be9" title="Find index of a named vector.">find_vector</a>(<span class="stringliteral">&quot;Solution&quot;</span>);</div>
<div class="line"> <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>&amp; src = vectors.<a class="code" href="classAppFrame_1_1FEVectors.html#a4d13d31ddbd66c782408acab7279b626" title="Access to a vector stored.">vector</a>(i);</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">const</span> std::string suffix = this-&gt;d_out.default_suffix();</div>
<div class="line"> <span class="keywordflow">if</span> (suffix == <span class="stringliteral">&quot;&quot;</span>) <span class="keywordflow">return</span>;</div>
</div><!-- fragment -->We also begin the initialisation of the <a class="el" href="classAppFrame_1_1DoFApplication.html#aa8562a81e80610c7f2c34b81d941f045">d_out </a> object, which is an <a class="el" href="classDoFApplication.html">DoFApplication</a> object for writing files. <code>d_out</code> is of type <a href="http://www.dealii.org/7.0.0/doxygen/deal.II/classDataOut.html">DataOut </a> from deal.II. We ask it for the suffix which will be appended to the basename passed to the <code>data_out</code> function. This suffix is .vtk in the case of the <code>data_out</code> function. If we were printing the grid, then it would be .eps.<div class="fragment"><div class="line"><span class="comment">// Output solution with its corresponent names:</span></div>
<div class="line">std::vector&lt;std::strings&gt; solution_names;</div>
<div class="line">solution_names.push_back(<span class="stringliteral">&quot;Oxygen_molar_fraction&quot;</span>);</div>
<div class="line">solution_names.push_back(<span class="stringliteral">&quot;Protonic_electrical_potential&quot;</span>);</div>
<div class="line">solution_names.push_back(<span class="stringliteral">&quot;Electronic_electrical_potential&quot;</span>);</div>
<div class="line"><a class="code" href="classAppFrame_1_1DoFApplication.html#a20494f2f33faa9157449ac9d8fdf212b">AppFrame::DoFApplication&lt;dim&gt;::data_out</a>(basename,vectors,solution_names);</div>
</div><!-- fragment -->Next we create a vector of the solution names and then pass it to the <code>d_out</code> object. <br/>
 <br/>
 As well as printing out the solution variables we will also print out the value of the source term at each point in our grid. However when we computed the current density in the cell_residual and cell_matrix classes the values were stored in local (to the function) variables. As such we no longer have access to them so we must compute them again. We start by reinitialising our problem: putting the solution in the required format and creating an object to hold the values of the source term: </p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (this-&gt;element-&gt;n_base_elements() == 1)</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classBlockVector.html">AppFrame::FEVector</a> source;</div>
<div class="line">    source.reinit(src);</div>
<div class="line">    <a class="code" href="classBlockVector.html">AppFrame::FEVector</a> reaction_rate(this-&gt;element-&gt;n_blocks(), </div>
<div class="line">                  this-&gt;element-&gt;base_element(this-&gt;element-&gt;block_to_base_index(0).first).dofs_per_cell);</div>
</div><!-- fragment -->Next we reinitialise the quadrature and finite element objects: </p>
<div class="fragment"><div class="line"><span class="keyword">const</span> Quadrature&lt;dim&gt; dummy_qr (this-&gt;element-&gt;base_element(0).get_generalized_support_points());</div>
<div class="line">std::vector&lt;FEValues&lt;dim&gt;*&gt; fe(this-&gt;element-&gt;n_base_elements());</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;fe.size(); ++i)</div>
<div class="line">   fe[i] = <span class="keyword">new</span> FEValues&lt;dim&gt; (*this-&gt;mapping,</div>
<div class="line">                              this-&gt;element-&gt;base_element(0), </div>
<div class="line">                              dummy_qr, </div>
<div class="line">                              UpdateFlags(update_values    |   update_q_points  |    update_JxW_values));</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = this-&gt;element-&gt;dofs_per_cell;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create vector that related degrees of freedom of the cell with dof of the global system (to assembly global matrix)</span></div>
<div class="line">std::vector&lt;unsigned int&gt; indices_org (dofs_per_cell);</div>
<div class="line">std::vector&lt;unsigned int&gt; indices (dofs_per_cell);</div>
</div><!-- fragment -->Next we are going to loop over all the cells in our grid, and initialise the degrees of freedom for each cell.<div class="fragment"><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> cell;</div>
<div class="line"><span class="keywordflow">for</span> (cell = this-&gt;dof-&gt;begin_active(); cell != this-&gt;dof-&gt;end(); ++cell)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// initialize the vector that relates local element dof to global dof</span></div>
<div class="line">  cell-&gt;get_dof_indices (indices_org);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;indices.size(); ++i)</div>
<div class="line">       indices[this-&gt;block_info.local_renumbering[i]] = indices_org[i];</div>
<div class="line">  <span class="comment">//initialize shape function values for the cell      for (unsigned int i=0; i&lt;fe.size(); ++i)</span></div>
<div class="line">  fe[i]-&gt;reinit ((<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a>) cell);</div>
</div><!-- fragment -->We will then check to see if the cell is in the catalyst layer, if it is we compute the current density in a very similar manner to how it was done in the cell_residual class. </p>
<div class="fragment"><div class="line"><span class="comment">// set material id</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> material_id = cell-&gt;material_id ();</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> (material_id == 4 ||  material_id == 6) <span class="comment">//the material is the catalyst layer</span></div>
<div class="line">{</div>
<div class="line">   <span class="comment">// Since all fe are the same use fe(0) for all elements:</span></div>
<div class="line">    <span class="keyword">const</span> FEValuesBase&lt;dim&gt;&amp; fe_values = *fe[0];</div>
<div class="line">      <span class="comment">// get integration points</span></div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_quad = fe_values.n_quadrature_points;</div>
<div class="line">      std::vector&lt;Point&lt;dim&gt; &gt; point(n_quad);</div>
<div class="line">      point = fe_values.get_quadrature_points();</div>
<div class="line">      <span class="comment">// Create a vector where the values of coefficients at quadrature points are stored:</span></div>
<div class="line">      std::vector&lt;double&gt; values(n_quad);</div>
<div class="line">      <span class="comment">// Create a vector to store solution:</span></div>
<div class="line">      std::vector&lt;std::vector&lt;double&gt; &gt; solution(this-&gt;element-&gt;n_blocks(), std::vector&lt;double&gt; (n_quad, 0.));</div>
<div class="line">      <span class="comment">//</span></div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;this-&gt;element-&gt;n_blocks(); ++i)</div>
<div class="line">    {</div>
<div class="line">      fe_values.get_function_values(src,</div>
<div class="line">                    make_slice(indices, this-&gt;block_info.local.block_start(i), fe_values.dofs_per_cell),</div>
<div class="line">                    solution[i]);</div>
<div class="line">     }</div>
<div class="line">      <span class="comment">// [BC] calculate source term contributions at each quadrature point.</span></div>
<div class="line">      <span class="comment">//Compute values    </span></div>
<div class="line">        std::vector&lt; FuelCellShop::SolutionVariable &gt; solution_variables;</div>
<div class="line">            solution_variables.push_back( <a class="code" href="structFuelCellShop_1_1SolutionVariable.html" title="This structure is used to store values for a particular solution variables, at all quadrature points ...">FuelCellShop::SolutionVariable</a>(&amp;solution[system_management.solution_name_to_index(<span class="stringliteral">&quot;oxygen_molar_fraction&quot;</span>)], <a class="code" href="system__management_8h.html#a905465f7ef35ccf9a9a5fa54e2afd938a4b0cf4d52a8825bdad0e32b865664136">oxygen_molar_fraction</a>) );</div>
<div class="line">            solution_variables.push_back( <a class="code" href="structFuelCellShop_1_1SolutionVariable.html" title="This structure is used to store values for a particular solution variables, at all quadrature points ...">FuelCellShop::SolutionVariable</a>(&amp;solution[system_management.solution_name_to_index(<span class="stringliteral">&quot;protonic_electrical_potential&quot;</span>)], <a class="code" href="system__management_8h.html#a905465f7ef35ccf9a9a5fa54e2afd938a3ea75b563f832072168718e7e30c8b36">protonic_electrical_potential</a>) );</div>
<div class="line">            solution_variables.push_back( <a class="code" href="structFuelCellShop_1_1SolutionVariable.html" title="This structure is used to store values for a particular solution variables, at all quadrature points ...">FuelCellShop::SolutionVariable</a>(&amp;solution[system_management.solution_name_to_index(<span class="stringliteral">&quot;electronic_electrical_potential&quot;</span>)], <a class="code" href="system__management_8h.html#a905465f7ef35ccf9a9a5fa54e2afd938a80fe5fb03110c6b4bc4eba7aae9e20ba">electronic_electrical_potential</a>) );</div>
<div class="line">            </div>
<div class="line">            CCL-&gt;set_solution(solution_variables);</div>
<div class="line">            CCL-&gt;current_density(values);</div>
</div><!-- fragment --><p> Next we account for the stoichiometry of the problem and add the source terms to the solution <code>FEVectors</code> object: </p>
<div class="fragment"><div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_quad; ++q)</div>
<div class="line">       {</div>
<div class="line">         <span class="comment">//</span></div>
<div class="line">         reaction_rate.block(0)(q) = values[q]/(4.*<a class="code" href="namespaceConstants.html#a8cc0e2cdae6a48b609e78b516716feb2" title="Faraday constant = 96483.399242424 C/mol.">Constants::F</a>());  <span class="comment">//Note I loop over the indices of the first component which</span></div>
<div class="line">         reaction_rate.block(1)(q) = values[q];</div>
<div class="line">         reaction_rate.block(2)(q) = -values[q];</div>
<div class="line">        }</div>
<div class="line">         <span class="comment">// Store in the global vector:</span></div>
<div class="line">         <span class="comment">//unsigned int size_source = source.size();</span></div>
<div class="line">         <span class="comment">//std::cout&lt;&lt;&quot;SIZE SOURCE&quot;&lt;&lt;size_source&lt;&lt;&quot;and SIZE REACTION_RATE &quot;&lt;&lt;reaction_rate(3)&lt;&lt;std::endl;</span></div>
<div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;this-&gt;element-&gt;dofs_per_cell; ++i)</div>
<div class="line">       source(indices[i]) = reaction_rate(i);</div>
<div class="line">}</div>
<div class="line">   }</div>
</div><!-- fragment --><p> The fe object is then deleted, and the values of the source terms as well as their names are added to the <code>d_out</code> object. </p>
<div class="fragment"><div class="line">  <span class="comment">// names for source terms</span></div>
<div class="line">  std::vector&lt;std::string&gt; source_names;</div>
<div class="line">  source_names.push_back (<span class="stringliteral">&quot;source_o2&quot;</span>);</div>
<div class="line">  source_names.push_back (<span class="stringliteral">&quot;source_phi_m&quot;</span>);</div>
<div class="line">  source_names.push_back (<span class="stringliteral">&quot;source_phi_s&quot;</span>);</div>
<div class="line">  this-&gt;d_out.add_data_vector(source, source_names, DataOut_DoFData&lt;<a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>, <a class="code" href="fcst__constants_8h.html#a665f17c0bbcd89f2925d9ad4c4b077e5">dim</a>&gt;::type_dof_data, this-&gt;data_interpretation);</div>
<div class="line">  this-&gt;d_out.build_patches();</div>
<div class="line">} <span class="comment">//end if</span></div>
</div><!-- fragment -->Once we have gone over all the cells we are ready to output the .vtks. We create the name of each file,<code>filename</code> and use <code>this-&gt;d_out.write</code> to make the .vtk for that run of the adaptive refinement. </p>
<div class="fragment"><div class="line"> <span class="keyword">const</span> std::string filename = basename + filename1 + suffix;</div>
<div class="line"> deallog &lt;&lt; <span class="stringliteral">&quot;Datafile:&quot;</span> &lt;&lt; filename &lt;&lt; std::endl;</div>
<div class="line"> std::ofstream of (filename.c_str ());</div>
<div class="line">this-&gt;d_out.write (of);</div>
<div class="line"> this-&gt;d_out.clear();</div>
<div class="line">}</div>
</div><!-- fragment --><p> This completes the app_cathode application and now we will move onto how to set up the simulations using parameter files. <br/>
 <br/>
<a class="anchor" id="parameter_file"></a></p>
<h1>The parameter file</h1>
When running a simulation, the FCST code requires two parameter files. The first is the main parameter file mentioned when discussing the different 'levels' in the FCST code. It is used by <a class="el" href="classSimulatorBuilder.html" title="This class is used to initialize and launch simulations or optimization routines.">SimulatorBuilder</a> to set up the simulation. It contains key parameters such as the application, solver and solver method, and tells the simulation if we are using Dakota and the name of the file that contains the physical parameters (among other parameters as we will see). The main parameter for the test case developed for app_cathode is given below. Note that these files are located in the /data folder. There are three folders, analysis, parametric and testing. The analysis folder contains the files needed to run a single simulation, i.e. it will return a single point on a polarisation curve. The parametric folder contains the files needed for a parametric study, i.e. it can return a full polarisation curve. Both of these are templates based around a test case and can be modified to create your own simulations. The final folder is the test case, which also contains a file with expected results from the test case. This file should not be modified and should only be run in order to test the code. </p>
<div class="fragment"><div class="line"><span class="preprocessor">######################################################################</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#  This file is used to simulate an cathode and to obtain</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#  a polarisation curve.</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#   Copyright (C) 2011 by Marc Secanell</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#######################################################################</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">subsection Simulator</div>
<div class="line"> <span class="keyword">set</span> simulator name = cathode</div>
<div class="line"> <span class="keyword">set</span> simulator parameter file name = data_app_cathode_test.prm</div>
<div class="line"> <span class="keyword">set</span> solver name = Newton3ppC</div>
<div class="line"> <span class="keyword">set</span> Dakota direct = <span class="keyword">false</span></div>
<div class="line">end</div>
</div><!-- fragment -->As we can see comments in these .prm files are denoted using a # symbol. The structure is the same as was discussed in the <code>declare_parameters</code> function of the application. Note that we are not saying what the solver method is. Currently, only adaptive refinement has been implemented so this has been set as the default value in the <a class="el" href="classSimulationSelector.html" title="This class is used to select the different applications within FCST.">SimulationSelector</a> class. Therefore we do not need to set it in the parameter file. This should always be considered when setting up a simulation, parameters that you do not set will have default values that will be used and there will be no warning if the default is used. <br/>
 <br/>
Now we can move onto the file containing the bulk of the simulation parameters. The file that will be examined is again for the app_cathode test case. It contains physical data about the fuel cell we wish to model, including dimensions, operating conditions, properties etc. However it also contains information about the grid, the discretisation method, solver information, optimisation and the output. Here, we use the parameter file that is stored in /data/cathode//Secanell_EA07_Numerical_Optimization_PEMFC_Cathode_Electrodes. </p>
<div class="fragment"><div class="line"><span class="preprocessor">######################################################################</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#  File used to reproduce the results from the following paper:</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#  M. Secanell, B. Carnes, A. Suleman and N. Djilali, &quot;Numerical optimization of proton exchange membrane fuel cell cathodes&quot;, Electrochimica Acta, 52, 2007, 2668-2682</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#  This file is used to simulate an cathode and to obtain</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#  a single point on a polarisation curve. It is based on </span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#  the test case and will be called by the </span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#  main_app_cathode_analysis.prm file. </span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#   Copyright (C) 2011-13 by Marc Secanell</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#</span></div>
<div class="line"><span class="preprocessor">######################################################################</span></div>
</div><!-- fragment --><p> <br/>
 The first section of the input file details the grid generation. We can select the type of geometry we want, e.g. a mesh from file, a cathode or a cathodeMPL. In this case a cathode is used. <br/>
The Initial refinement states that the initial mesh will be refined twice before the solution starts. Also, Refinement = adaptive states that we will be using adaptive refinement to solve the problem. The properties are specified in a subsequent subsection. <br/>
 The next two parameters specify how to organize the degrees of freedom. We usually select to Sort by component. If the Sort Cuthill-McKee parameter is set to true then we will use the <a href="http://www.dealii.org/7.0.0/doxygen/deal.II/namespaceDoFRenumbering.html">Cuthill-McKee </a> algorithm to arrange the degrees of freedom, leading to a system matrix with non-zero terms more localised around the main diagonal. Instead we are using sort by component which will allow use to use the block matrix format. Note that the refinement parameter has a comment after adaptive. This just details other options that could be used for this parameter, i.e. we could use global instead of adaptive refinement.<div class="fragment"><div class="line"><span class="preprocessor">###############</span></div>
<div class="line"><span class="preprocessor"></span>subsection Grid generation</div>
<div class="line"><span class="keyword">set</span> Type of mesh = Cathode  # Cathode | CathodeMPL | File</div>
<div class="line"><span class="keyword">set</span> Initial refinement = 2</div>
<div class="line"> <span class="keyword">set</span> Refinement         = adaptive  #global | adaptive</div>
<div class="line"> <span class="keyword">set</span> Sort Cuthill-McKee = <span class="keyword">false</span></div>
<div class="line"> <span class="keyword">set</span> Sort by component  = <span class="keyword">true</span></div>
</div><!-- fragment -->When selecting a cathode geometry, we let the OpenFCST mesh generator generate the geometry for us. Therefore, we need to specify the dimension of the cell as well as a number id that specifies the material type and the boundary type. The parameters that need to be specified for use by the internal mesh generator are given in the following section: </p>
<div class="fragment"><div class="line"> subsection Internal mesh generator parameters</div>
<div class="line"><span class="preprocessor"> #### </span></div>
<div class="line"><span class="preprocessor"></span>    subsection Dimensions</div>
<div class="line">       <span class="keyword">set</span> Cathode current collector width [cm] = 0.1</div>
<div class="line">       <span class="keyword">set</span> Cathode channel width [cm] = 0.1</div>
<div class="line">       <span class="keyword">set</span> Cathode CL thickness [cm] =  1.18e-3</div>
<div class="line">       <span class="keyword">set</span> Cathode GDL thickness [cm] = 1.0e-2</div>
<div class="line">    end</div>
<div class="line"><span class="preprocessor">    ####</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">    #subsection Material ID</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">    #   set Cathode catalyst layer = 4</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">    #   set Cathode gas diffusion layer = 2</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">    #end</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">    ####</span></div>
<div class="line"><span class="preprocessor"></span>    subsection Boundary ID</div>
<div class="line">    <span class="keyword">set</span> c_CL/Membrane = 1</div>
<div class="line">    <span class="keyword">set</span> c_BPP/GDL = 2</div>
<div class="line">    <span class="keyword">set</span> c_Ch/GDL = 3</div>
<div class="line">    <span class="keyword">set</span> c_GDL/CL = 255</div>
<div class="line">    end</div>
<div class="line"> end</div>
<div class="line"><span class="preprocessor"> ####  </span></div>
<div class="line"><span class="preprocessor">end</span></div>
</div><!-- fragment -->Note that Material ID and Boundary IDs are used to relate a layer to a domain in the input file as we will show in the layer section. Note that the symmetric boundaries are given a value of 0 while interior boundaries, such as the one here between the CCL and GDL, must be denoted with 255. <br/>
 <br/>
Next, we move to the System management section. Here we specify the name of the solution variables and equations. For the cathode problem we have three unknowns and three equations as specified. </p>
<div class="fragment"><div class="line"><span class="preprocessor">###############</span></div>
<div class="line"><span class="preprocessor"></span>subsection System management</div>
<div class="line"></div>
<div class="line"><span class="keyword">set</span> Number of solution variables = 3</div>
<div class="line"></div>
<div class="line">subsection Solution variables</div>
<div class="line"> <span class="keyword">set</span> Solution variable 1 = <a class="code" href="system__management_8h.html#a905465f7ef35ccf9a9a5fa54e2afd938a4b0cf4d52a8825bdad0e32b865664136">oxygen_molar_fraction</a></div>
<div class="line"> <span class="keyword">set</span> Solution variable 3 = <a class="code" href="system__management_8h.html#a905465f7ef35ccf9a9a5fa54e2afd938a80fe5fb03110c6b4bc4eba7aae9e20ba">electronic_electrical_potential</a></div>
<div class="line"> <span class="keyword">set</span> Solution variable 2 = <a class="code" href="system__management_8h.html#a905465f7ef35ccf9a9a5fa54e2afd938a3ea75b563f832072168718e7e30c8b36">protonic_electrical_potential</a></div>
<div class="line">end</div>
<div class="line"></div>
<div class="line">subsection Equations</div>
<div class="line"> <span class="keyword">set</span> Equation 1 = Ficks Transport Equation - oxygen</div>
<div class="line"> <span class="keyword">set</span> Equation 3 = Electron Transport Equation</div>
<div class="line"> <span class="keyword">set</span> Equation 2 = Proton Transport Equation</div>
<div class="line">end</div>
<div class="line">end</div>
</div><!-- fragment -->Next we move to the discretisation parameters. In this section we select the type of finite element and the type of quadrature integration. We are using three first order equations, however the commented out parameter part shows another potential option, i.e. a third order element for the first equation and two first order elements. To recap on the how the finite elements are set: In the test case, we are using three first order elements which are defined using: <code>FESystem[FE_Q(1)^3]</code>. If second order elements are required, then we would use: <code>FESystem[FE_Q(2)^3]</code>. To use different elements for an equation, for example first order for the first equation and second order for the two other two, we would write <code>FESystem[FE_Q(1)]-FESystem[FE_Q(2)^2]</code>. In the matrix and residual subsections we are setting the order of the quadrature points relative to the the degrees of freedom. By setting the value to -1 we are actually saying that the order is one more than that of the degrees of freedom.<div class="fragment"><div class="line"><span class="preprocessor">###############</span></div>
<div class="line"><span class="preprocessor"></span>subsection Discretization</div>
<div class="line"> <span class="keyword">set</span> Element = FESystem[FE_Q(1)^3] #FESystem[FE_Q(3)-FE_Q(1)^2] #FESystem[FE_Q(1)^3] #System of three fe</div>
<div class="line"> subsection Matrix</div>
<div class="line">   <span class="keyword">set</span> Quadrature cell = -1</div>
<div class="line">   <span class="keyword">set</span> Quadrature face = -1</div>
<div class="line"> end</div>
<div class="line"> subsection Residual</div>
<div class="line">   <span class="keyword">set</span> Quadrature cell = -1</div>
<div class="line">   <span class="keyword">set</span> Quadrature face = -1</div>
<div class="line"> end</div>
<div class="line">end</div>
</div><!-- fragment -->Next, we define the parameter for adaptive refinement. Once the grid is created, there will be 2 global refinements (Number of Refinements = 2) before any solvers are called. In general we will always use adaptive refinement in our simulations rather than global, while the number of refinements is the number of times we adaptively refine our grid, leading to 5 calls to the Newton solver.<div class="fragment"><div class="line"><span class="preprocessor">###############</span></div>
<div class="line"><span class="preprocessor"></span>subsection Adaptive refinement</div>
<div class="line"> <span class="keyword">set</span> Number of Refinements = 2</div>
<div class="line"> <span class="keyword">set</span> Output initial solution = <span class="keyword">false</span></div>
<div class="line"> <span class="keyword">set</span> Output intermediate solutions = <span class="keyword">false</span></div>
<div class="line"> <span class="keyword">set</span> Output intermediate responses = <span class="keyword">true</span></div>
<div class="line"> <span class="keyword">set</span> Output <span class="keyword">final</span> solution = <span class="keyword">true</span></div>
<div class="line"> <span class="keyword">set</span> Output solution <span class="keywordflow">for</span> transfer = <span class="keyword">false</span></div>
<div class="line"> <span class="keyword">set</span> Read in initial solution from file = <span class="keyword">false</span></div>
<div class="line">end</div>
</div><!-- fragment -->Next is the information for the Newton solver. Here we set parameters such as the tolerance and the maximum number of steps for each iteration.<div class="fragment"><div class="line"><span class="preprocessor">###############</span></div>
<div class="line"><span class="preprocessor"></span>subsection Newton</div>
<div class="line"> <span class="keyword">set</span> Assemble threshold = 0.0</div>
<div class="line"> <span class="keyword">set</span> Debug level        = 0</div>
<div class="line"> <span class="keyword">set</span> Debug residual     = <span class="keyword">false</span></div>
<div class="line"> <span class="keyword">set</span> Debug solution     = <span class="keyword">false</span></div>
<div class="line"> <span class="keyword">set</span> Debug update       = <span class="keyword">false</span></div>
<div class="line"> <span class="keyword">set</span> Max steps          = 100</div>
<div class="line"> <span class="keyword">set</span> Reduction          = 1.e-20</div>
<div class="line"> <span class="keyword">set</span> Tolerance          = 1.e-5</div>
<div class="line">end</div>
</div><!-- fragment -->Now we can move onto the physical parameters describing the fuel cell.First, we set the operating conditions for the fuel cell: </p>
<div class="fragment"><div class="line">subsection Operating conditions</div>
<div class="line">   <span class="keyword">set</span> Temperature cell = 363 #[<a class="code" href="namespaceConstants.html#aa5e92a8c5672b9716adb862563a86d75" title="Boltzmann constant = 8.617332478e-5 eV/K.">K</a>]</div>
<div class="line">   <span class="keyword">set</span> Cathode pressure = 202650 #[Pa] (1 atm)</div>
<div class="line">   <span class="keyword">set</span> Cathode initial oxygen mole fraction (prior to humidification) = 1.0</div>
<div class="line">   <span class="keyword">set</span> Cathode relative humidity = 0.75</div>
<div class="line">   <span class="keyword">set</span> Voltage cell = 0.9 ## Equivalent to dV = 1.2 - 0.9 = 0.3V in paper since OCV = 1.2V</div>
<div class="line">end</div>
</div><!-- fragment -->Next we can move onto layer properties. First, let us set up the gas diffusion layer. <br/>
 First, we specify the type of gas diffusion layer we would like to study. There are several types available such as SGL24BA, DummyGDL and DesignFibrousGDL. DesignFibrousGDL uses effective medium theories in order to determine the effective diffusivity, and electrical conductivity of the catalyst layer based on kinetic theory of gases diffusion coefficients for the gas and bulk properties for the fibers respectively. <br/>
 Once the layer type is defined we select the Material id of the layer. Now, the cells in the mesh with id 2 (Cathode gas diffusion layer) as shown in the GridGeneror section, will take the properties of this layer. <br/>
 Finally, I specify the bulk electrical conductivity and the method to obtain effective properties, in this case Bruggemann even tough Percolation | Tomadakis | Mezedur methods are also implemented. </p>
<div class="fragment"><div class="line">subsection Cathode gas diffusion layer</div>
<div class="line"> </div>
<div class="line">   <span class="keyword">set</span> Gas diffusion layer type = DesignFibrousGDL </div>
<div class="line">   </div>
<div class="line">   <span class="keyword">set</span> Material <span class="keywordtype">id</span> = 2</div>
<div class="line"><span class="preprocessor">   ####</span></div>
<div class="line"><span class="preprocessor"></span>   subsection DesignFibrousGDL</div>
<div class="line"><span class="preprocessor">     ######### Composition: #########</span></div>
<div class="line"><span class="preprocessor"></span>     <span class="keyword">set</span> Porosity = 0.8</div>
<div class="line">     ######### Gas transport #########</div>
<div class="line">     <span class="keyword">set</span> Electrical conductivity = 279.5</div>
<div class="line">     ## Anisotropy</div>
<div class="line">     <span class="keyword">set</span> Anisotropic transport = <span class="keyword">false</span>                                  # (<span class="keywordflow">default</span>) <span class="keyword">false</span></div>
<div class="line">     <span class="keyword">set</span> Method effective transport properties in pores = Bruggemann    # (<span class="keywordflow">default</span>) Bruggemann | Given | Percolation | Tomadakis | Mezedur</div>
<div class="line">     <span class="keyword">set</span> Method effective transport properties in solid = Bruggemann    # (<span class="keywordflow">default</span>) Bruggemann | Given | Percolation</div>
<div class="line">   end</div>
<div class="line"> end</div>
</div><!-- fragment -->Next, we define the catalyst layer properties. Again, we set the material id that corresponds to the layer and select the appropriate layer. A catalyst layer computes all the effective properties but also the current density in the layer. <br/>
 Here we have three options, a DummyCL which would allow the user to set the effective properties directly, a HomogeneousCL and an AgglomerateCL. A homogeneousCL implements a macro-homogeneous model. An AgglomerateCL implements a multi-scale model with an agglomerate model (either analytical or numerical) being solved to predict the current density. <br/>
 In this case, since the article we are trying to reproduce used a macro-homogeneous layer, we select HomogeneousCL as the type of CL. </p>
<div class="fragment"><div class="line"><span class="preprocessor">####</span></div>
<div class="line"><span class="preprocessor"></span>  subsection Cathode catalyst layer</div>
<div class="line"> </div>
<div class="line">   <span class="keyword">set</span> Material <span class="keywordtype">id</span> = 4</div>
<div class="line">   </div>
<div class="line">   <span class="keyword">set</span> Catalyst layer type = HomogeneousCL   #[ DummyCL | AgglomerateCL | HomogeneousCL ]</div>
</div><!-- fragment -->Once the catalyst layer has been selected, we need to specify the materials that form the layer. In this case, we need to specify the type of catalyst, catalyst support and electrolyte. We select Platinum, Carbon black and Nafion repectively. For each one of the materials, we need to specify its properties since this properties are need to obtain effective transport properties and also to predict the current density in the layer. <br/>
 Note that the platinum section is used to describe its kinetic properties rather than physical properties. The physical properties, such as density, used are the default values in the platinum class. Again it is important to keep this in mind when creating a prm file. Also note that the reference concentration has been modified to include the contribution from Henrys Law. </p>
<div class="fragment"><div class="line"><span class="keyword">set</span> Catalyst type = Platinum</div>
<div class="line"><span class="keyword">set</span> Catalyst support type = Carbon Black</div>
<div class="line"><span class="keyword">set</span> Electrolyte type = Nafion</div>
<div class="line"><span class="preprocessor">####</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">subsection Materials</div>
<div class="line"><span class="preprocessor">  ####</span></div>
<div class="line"><span class="preprocessor"></span>  subsection Platinum</div>
<div class="line">     <span class="keyword">set</span> Method <span class="keywordflow">for</span> kinetics parameters (ORR) = Given #Parthasarathy</div>
<div class="line">     <span class="keyword">set</span> Cathodic transfer coefficient (ORR) = 1.0</div>
<div class="line">     <span class="keyword">set</span> Given Open Cell Voltage (ORR) [V] = 1.2</div>
<div class="line">     <span class="keyword">set</span> Reference exchange current density (ORR) [uA/cm2] = 0.0305</div>
<div class="line">     <span class="keyword">set</span> Reference oxygen concentration (ORR) = 1.2e-6</div>
<div class="line"><span class="preprocessor">     #set Reference proton concentration (ORR) = 1.818e-3</span></div>
<div class="line"><span class="preprocessor"></span>     <span class="keyword">set</span> Oxygen reaction order (ORR) = 1.0</div>
<div class="line">  end</div>
<div class="line"><span class="preprocessor">  ####</span></div>
<div class="line"><span class="preprocessor"></span>  subsection Nafion</div>
<div class="line">    <span class="keyword">set</span> Method to compute proton conductivity = Constant # Options are: Constant|Springer|NRE211|Iden11</div>
<div class="line">    <span class="keyword">set</span> Proton conductivity [S/cm] = 0.06                       # Proton conductivity inside the membrane, S/cm</div>
<div class="line">    <span class="keyword">set</span> Oxygen diffusion coefficient [cm^2/s] = 9.726e-6    # From J. Peron et al., “Properties of Nafion NR-211 membranes <span class="keywordflow">for</span> PEMFCs”</div>
<div class="line">    <span class="keyword">set</span> Henry<span class="stringliteral">&#39;s Law Constant for Oxygen [Pa cm^3/mol] = 3.52611e10</span></div>
<div class="line"><span class="stringliteral">  end</span></div>
<div class="line"><span class="stringliteral">  subsection Carbon Black</span></div>
<div class="line"><span class="stringliteral">    set Electrical conductivity [S/cm] = 32.64  # Electrical conductivity of a group of particles packed to have 0% porosity. In S/cm      </span></div>
<div class="line"><span class="stringliteral">  end</span></div>
<div class="line"><span class="stringliteral">end</span></div>
<div class="line"><span class="stringliteral">####</span></div>
</div><!-- fragment -->Once the material has been specified, we can specify the amount of each one of the materials and also the methodology that we need to use to compute the effective properties. subsection ConventionalCL is used to specify such properties for both HomogeneousCL and AgglomerateCL since both layer have the same macro-scale parameters. For an AgglomerateCL model an additional section is needed with further parameters (see data/cathode/Secanell_EA07_MultiVariable_Optimization_PEMFC_Cathodes_Agglomerate_Model). <br/>
In this case, we specify the amount of Pt in our support, the platinum loading (in mg/cm3 !!!), the electrolyte loading and that the effective properties should be obtained using Bruggemann's method. </p>
<div class="fragment"><div class="line"><span class="preprocessor">   ##</span></div>
<div class="line"><span class="preprocessor"></span>   subsection ConventionalCL</div>
<div class="line">     <span class="keyword">set</span> Platinum loading on support (%wt) = .2              </div>
<div class="line">     <span class="keyword">set</span> Platinum loading per unit volume (mg/cm3) = 281.6   </div>
<div class="line">     <span class="keyword">set</span> Electrolyte loading (%wt) = 0.30                    </div>
<div class="line">     <span class="keyword">set</span> Method to compute active area = Marr</div>
<div class="line"><span class="preprocessor">     ######### Pore network #########</span></div>
<div class="line"><span class="preprocessor"></span>     <span class="keyword">set</span> Method effective transport properties in pores = Bruggemann</div>
<div class="line"><span class="preprocessor">     ######### Solid network #########</span></div>
<div class="line"><span class="preprocessor"></span>     <span class="keyword">set</span> Method effective transport properties in solid phase = Bruggemann</div>
<div class="line"><span class="preprocessor">     ######### Ionomer network #########</span></div>
<div class="line"><span class="preprocessor"></span>     <span class="keyword">set</span> Method effective transport properties in electrolyte phase = Bruggemann</div>
<div class="line">   end</div>
<div class="line"><span class="preprocessor">   ##</span></div>
<div class="line"><span class="preprocessor"></span> end</div>
<div class="line">end</div>
</div><!-- fragment -->Once all the layers are specified, we specify if we would like to compute any functionals at post-processing. In this case, we would like to compute the current. </p>
<div class="fragment"><div class="line"><span class="preprocessor">###############</span></div>
<div class="line"><span class="preprocessor"></span>subsection Output Variables</div>
<div class="line"> <span class="keyword">set</span> num_output_vars = 1</div>
<div class="line"> <span class="keyword">set</span> Output_var_0 = current</div>
<div class="line">end</div>
</div><!-- fragment -->Finally, we need to set the output parameters for the simulation. In this case we only wish to set the format of the output. The data output is set to .vtk, which can be read by Paraview and used to visualise our solution profiles. The grid is outputted in a simple .eps files that can be used to view the grid. However it can't be read by the code and used as a grid in a new simulation. </p>
<div class="fragment"><div class="line"><span class="preprocessor">###############</span></div>
<div class="line"><span class="preprocessor"></span>subsection Output</div>
<div class="line"> subsection Data</div>
<div class="line">   <span class="keyword">set</span> Output format = vtk #tecplot</div>
<div class="line"> end</div>
<div class="line"> subsection Grid</div>
<div class="line">   <span class="keyword">set</span> Format = <a class="code" href="namespaceAppShop_1_1Residual_1_1Boundary.html#adce9a63462be763ea3fc9243c6a0c485" title="Elasticity.">eps</a></div>
<div class="line"> end</div>
<div class="line">end</div>
</div><!-- fragment -->This, along with default values, is enough to describe the fuel cell we wish to model.<a class="anchor" id="Results"></a></p>
<h1>Results</h1>
We can see the results from our simulation in the picture below along with the domain of our simulation. The simulation produces a .vtk file that show the 2D profiles of our three solution variables. We can also produce an image of the source term for each of our equations, i.e. the current production profile. The image shows both the GDL and CCL for the oxygen and electronic potential profiles. However because there is no ionomer and no current production in the GDL, we have cut out the GDL for the protonic potential and source term profiles so as to better visualise the CCL. The CCL is still visible in the oxygen molar fraction profile, on the far left, due to the difference in the oxygen diffusion coefficient between the CCL and the CGDL. Note also that the source term profile is heavily weighted to the upper left. This would indicate a relatively slow transport of protons through the membrane. We can also clearly in the oxygen and solid phase potential profiles where the rib and gas channel are. <br/>
 <br/>
The software that is normally used to visualise the results is <a href="http://www.paraview.org/">Paraview</a>, an open source data analysis and visualisation package. An introduction and some exercises are available on the ESDL repository, under the manuals section. Also, the following <a href="http://www.math.tamu.edu/~bangerth/videos.676.32.html">lecture</a> by Wolfgang Bangerth and Timo Heister is also very useful.<table  width="40%" align="center">
<tr>
<td align="center"><div class="image">
<img src="tutorial_domain.png" alt="tutorial_domain.png"/>
</div>
   </td></tr>
</table>
<table  width="40%" align="center">
<tr>
<td align="center"><div class="image">
<img src="tutorial_pic.png" alt="tutorial_pic.png"/>
</div>
 <p class="endtd"></p>
</td></tr>
</table>
The application can also be used with Dakota to produce a polarization curve. The necessary files for producing a polarization curve are given in data/cathode/Secanell_EA07_Numerical_Optimization_PEMFC_Cathode_Electrodes/parametric. Below are the values obtained from a polarization curve study: </p>
<div class="fragment"><div class="line">%eval_id         V_cell         obj_fn </div>
<div class="line">      1          0.828   -1.510047073 </div>
<div class="line">      2   0.8404444444       -1.22595 </div>
<div class="line">      3   0.8528888889   -0.984834143 </div>
<div class="line">      4   0.8653333333  -0.7816117882 </div>
<div class="line">      5   0.8777777778  -0.6118229935 </div>
<div class="line">      6   0.8902222222  -0.4715430691 </div>
<div class="line">      7   0.9026666667  -0.3573065763 </div>
<div class="line">      8   0.9151111111  -0.2659409983 </div>
<div class="line">      9   0.9275555556  -0.1944040981 </div>
<div class="line">     10           0.94  -0.1396915213 </div>
</div><!-- fragment -->This could then be used to produce a polarisation curve. </p>
<table  width="40%" align="center">
<tr>
<td align="center"><div class="image">
<img src="tutorial_polarization.png" alt="tutorial_polarization.png"/>
</div>
   </td></tr>
</table>
<a class="anchor" id="PlainProg"></a> </p>
<h1>The plain program</h1>
<div class="fragment"></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 30 2013 17:15:55 for OpenFCST: The open-source Fuel Cell Simulation Toolbox by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
